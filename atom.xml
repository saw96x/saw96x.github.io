<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Saw96x</title>
  
  <subtitle>Think twice, code once.</subtitle>
  <link href="https://saw96x.github.io/atom.xml" rel="self"/>
  
  <link href="https://saw96x.github.io/"/>
  <updated>2021-08-13T03:08:50.494Z</updated>
  <id>https://saw96x.github.io/</id>
  
  <author>
    <name>Saw96x</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM垃圾回收</title>
    <link href="https://saw96x.github.io/post/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.html"/>
    <id>https://saw96x.github.io/post/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.html</id>
    <published>2021-08-13T03:08:37.000Z</published>
    <updated>2021-08-13T03:08:50.494Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM垃圾回收"><a href="#JVM垃圾回收" class="headerlink" title="JVM垃圾回收"></a>JVM垃圾回收</h1><h2 id="1-如何判断对象可以回收"><a href="#1-如何判断对象可以回收" class="headerlink" title="1. 如何判断对象可以回收"></a>1. 如何判断对象可以回收</h2><h3 id="1-1-简要介绍："><a href="#1-1-简要介绍：" class="headerlink" title="1.1 简要介绍："></a>1.1 简要介绍：</h3><ol><li><p>引用计数法，如果某个对象被引用了，则他的计数加1，不再被引用了，则减1，计数为0则回收。弊端：循环引用，比如a和b相互引用，即使他们两个永远都不再被使用了，但是由于存在引用计数，所以永远都不会被回收。早期python虚拟机采用这种算法。</p></li><li><p>可达性分析算法：首先确定根对象（肯定不能被垃圾回收的对象），进行垃圾回收前对所有对象进行一次扫描，如果被根对象直接或间接应用的对象就不能被回收，如果没有被引用，那么就可以被回收。许多主流的商用程序语言（Java，C#等等）都采用这种算法进行</p><p><img src="https://img-blog.csdnimg.cn/a1dedc915d8b4c4a849f483359dcab00.PNG"></p></li></ol><h3 id="1-2-可达性分析算法："><a href="#1-2-可达性分析算法：" class="headerlink" title="1.2 可达性分析算法："></a>1.2 可达性分析算法：</h3><ul><li><p>Java虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象</p></li><li><p>扫描堆中的对象，看是否能够沿这GC Root对象为起点的引用链找到该对象，找不到，表示可以回收</p><h4 id="哪些对象可以作为GC-Root对象"><a href="#哪些对象可以作为GC-Root对象" class="headerlink" title="哪些对象可以作为GC Root对象"></a>哪些对象可以作为GC Root对象</h4></li></ul><p> SystemClass：由自举/系统类加载器加载的类。例如，rt.jar中所有诸如<a href="https://www.baidu.com/s?wd=java.util&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">java.util</a>.*的类。<br> JNILocal：原生代码中的本地变量，例如用户定义的JNI（Java本地接口，一般用来使Java代码和其他语言代码进行交互）代码或JVM内部代码。<br> JNIGlobal：原生代码中的全局变量，例如用户定义的JNI代码或JVM内部代码。<br> ThreadBlock：当前活跃的线程块中引用的对象。<br> Thread：启动且未停止的线程。<br> BusyMonitor：其wait()或notify()方法被调用，或被同步synchronized的对象。例如，通过调用synchronized(Object)或者进入其某个synchronized方法。静态方法对应类，非静态方法对应对象。<br> JavaLocal：本地变量。例如，仍在线程的栈中的方法输入参数或本地创建的对象。<br> NativeStack：（例如用户定义的JNI代码或JVM内部代码这样的）原生代码的入或出参数。通常发生在许多方法有原生部分，方法参数处理的对象成为GC根对象。例如，参数用于文件、网络I/O或反射。<br> Finalizer：在队列中等待其finalizer运行的对象。<br> Unfinalized：拥有finalize方法，但是还没有被终结且不在finalizer队列的对象。<br> Unreachable：从其他根对象不可达的对象，但是被内存分析器标记为根对象。<br> Unknown：没有根类型的对象。一些转储(dump)，例如IBM可移植对转储文件，没有根信息。对于这些转储，内存分析器解析程序将没有被其他根<a href="https://www.baidu.com/s?wd=%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">对象引用</a>的对象标记为此类根对象。</p><p>如果觉得上面的太复杂，那么简单来说，在Java语言中，可作为GC Roots的对象包括下面4种：</p><ul><li>虚拟机栈（栈帧中的本地变量表）中引用的对象。*</li><li>方法区中类静态属性引用的对象。*</li><li>方法区中常量引用的对象。* </li><li>本地方法栈中JNI（即一般说的Native方法）引用的对象。</li></ul><h3 id="1-3-四种引用"><a href="#1-3-四种引用" class="headerlink" title="1.3 四种引用"></a>1.3 四种引用</h3><p><img src="https://img-blog.csdnimg.cn/12f2c23e724f4dd0b0babbfaa8df9529.PNG"></p><p>此图中，实线表示强引用，虚线表示其余引用 </p><ol><li><p>强引用</p><p><strong>可以被GC Root对象直接或间接的找到，这种关系是强引用</strong>，一般情况下，我们书写的代码基本上形成的引用关系都是强引用，<strong>只有当所有强引用都断开时，对象才会被垃圾回收</strong>，除此之外是绝不可能将其回收的。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">Object o &#x3D; new Object();   &#x2F;&#x2F;  强引用o &#x3D; null; &#x2F;&#x2F;断开强引用，被回收</code></pre></li><li><p>软引用</p><p>在Java中，软引用本质上是一种特殊设计的类，因此软引用实际上是被手动创建出来的，使用SoftReference类创建出来</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">String str &#x3D; new String(&quot;abc&quot;);                                     &#x2F;&#x2F; 强引用SoftReference&lt;String&gt; softRef &#x3D; new SoftReference&lt;String&gt;(str);     &#x2F;&#x2F; str被软引用</code></pre><p> <strong>如果一个对象只具有软引用（通过SoftReference建立），则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些软引用对象的内存。</strong>只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p><p>最具代表性的应用，如浏览器的后退按钮，点击后退要返回到上一个页面，如果重新加载，可能耗时较长，如果将其存储到内存中，则会造成浪费，这时可以使用软引用进行缓存，如果缓存资源充足，那么就将页面保存到缓存中，如果紧张，由于软引用的特性，页面缓存会被垃圾回收器回收。</p><p>可以配合<strong>引用队列</strong>使用，如果软引用它引用的对象被回收时，软引用本身（SoftReference实例）会被放到引用队列中，可以对其方便的进行进一步处理，比如释放SoftReference实例占用的内存。</p></li><li><p>弱引用</p><p>和软引用相似，弱引用对象也要手动创建出来，使用WeakReference建立</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">String str &#x3D; new String(&quot;abc&quot;);                                     &#x2F;&#x2F;强引用WeakReference&lt;String&gt; abcWeakRef &#x3D; new WeakReference&lt;String&gt;(str);  &#x2F;&#x2F;str被弱引用</code></pre><p>和软引用不同的是，<strong>无论空间是否充足，只要垃圾回收器运行了，那么检测到弱引用，就会即刻将其回收</strong>。但是垃圾回收器的线程优先级很低，不太经常运行，所以不会发生马上就会被清理掉的情况。如果这个对象是偶尔的使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么你应该用 WeakReference 来记住此对象。  </p><p>可以配合<strong>引用队列</strong>使用，如果软引用它引用的对象被回收时，软引用本身（WeakReference实例）会被放到引用队列中，可以对其方便的进行进一步处理，比如释放WeakReference实例占用的内存。</p></li><li><p>虚引用</p><p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，<strong>虚引用并不会决定对象的生命周期</strong>。<strong>如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">String str &#x3D; new String(&quot;abc&quot;);                                     &#x2F;&#x2F;强引用PhantomReference&lt;String&gt; ref &#x3D; new PhantomReference&lt;String&gt;(str);  &#x2F;&#x2F;str被虚引用</code></pre><p> 虚引用主要用来跟踪对象被垃圾回收器回收的活动，同时，和软引用以及弱引用不同的是，<strong>虚引用必须要和引用队列一起使用</strong>，下面用一个例子来说明其作用和特征。</p><p>用Java中使用ByteBuffer分配直接内存的例子来说明一下，一个名叫Cleaner的虚引用关联了ByteBuffer实例对象，而我们借助ByteBuffer实例对象分配一些直接内存，当对ByteBuffer实例对象的强引用被断开后，ByteBuffer被回收了，但是其获取的直接内存不能被JVM垃圾回收器释放（因为它是底层的内存），这时候就要通过Cleaner这个虚引用，它进入引用队列，进行后续处理，通过这个虚引用获取到那块直接内存，然后将其释放。</p></li></ol><h3 id="1-4-回收前的筛选判断"><a href="#1-4-回收前的筛选判断" class="headerlink" title="1.4 回收前的筛选判断"></a>1.4 回收前的筛选判断</h3><p>即使在可达性分析算法中不可达的对象，也<strong>并非一定会被垃圾回收</strong>，要真正回收一个对象，至少要经历两次标记过程：</p><ol><li>如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，<strong>筛选的条件是此对象是否有必要执行finalize（）方法</strong>。当对象没有覆盖finalize（）方法，或者finalize（）方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。</li><li>如果这个对象被判定为有必要执行finalize（）方法，那么这个对象将会放置在一个叫做<strong>F-Queue</strong>的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。但<strong>此线程不保证一定会等待finalize()方法运行结束</strong>，这是为了防止发生死循环时其他队列中的对象无法执行finalize()。finalize（）方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，<strong>如果对象要在finalize（）中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可</strong>，如果对象没能在finalize()中建立关联，那么它就会真的被回收了。</li></ol><h2 id="2-垃圾回收算法"><a href="#2-垃圾回收算法" class="headerlink" title="2. 垃圾回收算法"></a>2. 垃圾回收算法</h2><h3 id="2-1-标记-清除算法"><a href="#2-1-标记-清除算法" class="headerlink" title="2.1 标记-清除算法"></a>2.1 标记-清除算法</h3><p>这种算法是最基础的手机算法，言简意赅，算法分为“标记”和“清除”（Mark-Sweep）两个阶段：<strong>首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象</strong>。</p><p>在JVM中，标记过程就是上文说的回收前的筛选判断（两次标记）。这种算法相当简单，但是仍然不经常使用它，它的主要不足有两个：<strong>一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作</strong>。</p><h3 id="2-2-复制算法"><a href="#2-2-复制算法" class="headerlink" title="2.2 复制算法"></a>2.2 复制算法</h3><p>为了解决效率问题，一种称为“复制”（Copying）的收集算法出现了，<strong>它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</strong></p><p>这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将<strong>内存缩小为了原来的一半</strong>，未免太高了一点。</p><h3 id="2-3-标记-整理算法"><a href="#2-3-标记-整理算法" class="headerlink" title="2.3 标记-整理算法"></a>2.3 标记-整理算法</h3><p>还有一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p><p>在JVM中，主要使用的<strong>复制算法</strong>和<strong>标记-整理算法</strong>，他们分别针对不同生命周期的对象。</p><h2 id="3-分代垃圾回收"><a href="#3-分代垃圾回收" class="headerlink" title="3. 分代垃圾回收"></a>3. 分代垃圾回收</h2><p>当前商业虚拟机的垃圾回收都采用<strong>分代收集</strong>的思想，就是根据对象的生命周期将内存划分为几块，一般是把Java堆中分为<strong>新生代和老年代</strong>。</p><p>新生代的区域存储刚被创建出来的对象，一般有研究表明，新生代中的对象98%是“朝生夕死”的，而在经历了n次垃圾回收后仍然存活的对象，则会被放到老年代，一般老年代中的对象生命周期都较长。</p><p>虚拟机对不同的区域采用不同的垃圾回收算法，由于新生代大多数对象生命周期极短，因此采用改良后的复制算法来回收。</p><p>不是按照1:1的比例来划分内存空间，而是<strong>将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。</strong></p><p>HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，因此每次只会浪费10%的空间。但是我们不能断定，某次新生代的垃圾回收之后，10%的内存一定装得下存活的实例对象，因此当Survivor对象不够用时，需要依赖其他内存进行分配担保。</p><p><strong>如果另外一块Survivor空间没有足够空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代。</strong></p><p>对于老年代，虚拟机采用的垃圾回收算法是<strong>标记-整理</strong>算法，一方面老年代对象不多，使用这种算法效率略低可以接受，另一方面也可以清理出整块的内存，方便后续的内存分配。</p><h2 id="4-垃圾收集器"><a href="#4-垃圾收集器" class="headerlink" title="4. 垃圾收集器"></a>4. 垃圾收集器</h2><p><img src="https://img-blog.csdnimg.cn/81b0bee23de84984be80643c396c9131.PNG"></p><p>如图，这是HotSpot虚拟机包含的所有收集器，如果两个收集器存在连线，就说明它们可以搭配使用，虚拟机所处的区域，则表示它是属于新生代收集器还是老年代收集器。</p><h3 id="4-1-Serial收集器"><a href="#4-1-Serial收集器" class="headerlink" title="4.1 Serial收集器"></a>4.1 Serial收集器</h3><p>它是最基本，发展历史最悠久的收集器，它是单线程收集器，在进行垃圾收集时丙戌暂停其他所有线程，直到它收集结束。</p><p>看起来它效率很低，但实际上，<strong>它依然是虚拟机运行在Client（客户端）模式下的默认新生代收集器</strong>。</p><p>它有着自己的优点：简单高效、没有线程交互开销，对于内存没有非常大的新生代已经足够使用了。</p><h3 id="4-2-ParNew收集器"><a href="#4-2-ParNew收集器" class="headerlink" title="4.2 ParNew收集器"></a>4.2 ParNew收集器</h3><p>它是Serial收集器的多线程版本，除此之外它就没什么创新之处了，但<strong>它却是许多运行在Server模式下的虚拟机中首选的新生代收集器</strong>，其中有一个与性能无关但很重要的原因是，除了Serial收集器外，<strong>目前只有它能与CMS收集器（划时代意义的垃圾收集器）配合工作</strong>。</p><h3 id="4-3-Parallel-Scavenge收集器"><a href="#4-3-Parallel-Scavenge收集器" class="headerlink" title="4.3 Parallel Scavenge收集器"></a>4.3 Parallel Scavenge收集器</h3><p>Parallel Scavenge收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器，它的特点是，<strong>此收集器的目标是达到一个可控制的吞吐量（CPU用于运行用户代码的时间与CPU总消耗时间的比值）</strong>，因此它也常被称为“吞吐量优先”收集器。高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p><p>Parallel Scavenge收集器还有一个特点，它有一个参数-XX：+UseAdaptiveSizePolicy值得关注。这是一个开关参数，<strong>当这个参数打开之后，就不需要指定一些列细节参数，虚拟机会根据当前系统的运行情况收集性能监控信</strong><br><strong>息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种调节方式称为GC自适应的调节策略</strong>。</p><h3 id="4-4-Serial-Old收集器"><a href="#4-4-Serial-Old收集器" class="headerlink" title="4.4 Serial Old收集器"></a>4.4 Serial Old收集器</h3><p>它是Serial收集器的老年代版本，同样是单线程收集器，使用“标记-整理”算法，这个收集器的主要意义也是在于给Client模式下的虚拟机使用，如果在Server模式<br>下，那么它主要还有两大用途：一种用途是在JDK 1.5以及之前的版本中与Parallel Scavenge收集器搭配使用，另一种用途就是作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用。</p><h3 id="4-5-Paraller-Old收集器"><a href="#4-5-Paraller-Old收集器" class="headerlink" title="4.5 Paraller Old收集器"></a>4.5 Paraller Old收集器</h3><p>它是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。</p><p>在它出现之前，Parallel Scavenge收集器一直处于比较尴尬的地位。Parallel Scavenge收集器只能和Serial Old收集器配合使用，但是由于Serial Old收集器在服务端应用性能上的拖累，使用了Parallel Scavenge收集器也未必能在整体应用上获得吞吐量最大化的效果，在老年代很大而且硬件比较高级的环境中，这种组合的吞吐量甚至还不一定又ParNew+CMS的组合给力。</p><p>直到Parallel Old收集器出现后，“吞吐量优先”收集器终于有了比较名副其实的应用组合，<strong>在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器</strong>。</p><h3 id="4-6-CMS收集器"><a href="#4-6-CMS收集器" class="headerlink" title="4.6 CMS收集器"></a>4.6 CMS收集器</h3><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。相当一部分Java应用集中在互联网应用的服务端上，这类应用尤其注重服务的响应速度，CMS收集器就很符合这类应用的需求。</p><p>从名字（包含“Mark Sweep”）上就可以看出，CMS收集器是基于“标记—清除”算法实现的，它的运作过程相对于前面几种收集器来说更复杂一些，整个过程分为4个步骤，包括：</p><ol><li>初始标记（CMS initial mark）</li><li>并发标记（CMS concurrent mark）</li><li>重新标记（CMS remark）</li><li>并发清除（CMS concurrent sweep）</li></ol><p>其中，第一步和第三步仍然需要停止所有线程（Stop The World）。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC RootsTracing的过程，而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。</p><p>而耗时最长的并发标记和并非清楚过程收集器线程都可以与用户线程一起工作，所有，从总体来说，CMS收集器的执行是与用户线程一起并发执行的，可以达到低停顿时间。</p><p>虽然它相当优秀，但是它还远远达不到完美的程度，它又以下3个明显的缺点：</p><ol><li><strong>CMS收集器对CPU资源非常敏感。</strong>当CPU不足4个时，CMS对用户程序的影响可能变得很大，甚至可能导致执行速度降低了50%。为了应付这种情况，虚拟机提供了一种称为“增量式并发收集器”（Incremental Concurrent Mark Sweep/i-CMS）的CMS收集器变种。就是在并发标记、清理的时候让GC线程、用户线程交替运行，尽量减少GC线程的独占资源的时间，这样整个垃圾收集的过程会更长，但对用户程序的影响就会显得少一些，也就是速度下降没有那么明显。实际上，他的效果很一般，当前版本不再提倡用户使用。</li><li><strong>CMS收集器无法处理浮动垃圾（Floating Garbage），可能现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。</strong>由于在并发清理解答，用户线程仍在运行，就会产生新垃圾，这些垃圾必须得下一次GC再清理，这种垃圾就被称为“浮动垃圾”。CMS收集器需要预留一部分空间提供并发时其他线程使用，要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败，这时虚拟机将启动后备预案：临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。</li><li><strong>由于采用了“标记-清除“算法，收集结束时会有大量空间碎片产生。</strong>，CMS收集器提供了一个-XX：+UseCMSCompactAtFullCollection开关参数（默认就是开启的），用于在CMS收集器顶不住要进行FullGC时开启内存碎片的合并整理过程，内存整理的过程是无法并发的，空间碎片问题没有了，但停顿时间不得不变长。</li></ol><h3 id="4-7-G1收集器"><a href="#4-7-G1收集器" class="headerlink" title="4.7 G1收集器"></a>4.7 G1收集器</h3><p>G1（Garbage-First）收集器是当今收集器技术发展的最前沿成果之一，G1是一款面向服务端应用的垃圾收集器。HotSpot开发团队赋予它的使命是（在比较长期的）未来可以替换掉JDK 1.5中发布的CMS收集器。和其他收集器相比，它具备如下特点：</p><ol><li>并行与并发</li><li>分代收集</li><li>空间整合，整体上来看是基于<strong>标记-整理</strong>算法实现，局部看是基于<strong>复制</strong>算法实现</li><li>可预测的停顿</li></ol><p>使用G1收集器时，Java堆的内存布局就与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JVM垃圾回收&quot;&gt;&lt;a href=&quot;#JVM垃圾回收&quot; class=&quot;headerlink&quot; title=&quot;JVM垃圾回收&quot;&gt;&lt;/a&gt;JVM垃圾回收&lt;/h1&gt;&lt;h2 id=&quot;1-如何判断对象可以回收&quot;&gt;&lt;a href=&quot;#1-如何判断对象可以回收&quot; class=&quot;</summary>
      
    
    
    
    <category term="技术学习" scheme="https://saw96x.github.io/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Java" scheme="https://saw96x.github.io/tags/Java/"/>
    
    <category term="JVM" scheme="https://saw96x.github.io/tags/JVM/"/>
    
    <category term="源码分析" scheme="https://saw96x.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>HotSpot虚拟机对象探秘</title>
    <link href="https://saw96x.github.io/post/HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E8%B1%A1%E6%8E%A2%E7%A7%98.html"/>
    <id>https://saw96x.github.io/post/HotSpot%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AF%B9%E8%B1%A1%E6%8E%A2%E7%A7%98.html</id>
    <published>2021-08-12T02:55:37.000Z</published>
    <updated>2021-08-12T03:28:47.429Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HotSpot虚拟机对象探秘"><a href="#HotSpot虚拟机对象探秘" class="headerlink" title="HotSpot虚拟机对象探秘"></a>HotSpot虚拟机对象探秘</h1><h2 id="1-对象的创建"><a href="#1-对象的创建" class="headerlink" title="1. 对象的创建"></a>1. 对象的创建</h2><h3 id="1-1-类加载检查"><a href="#1-1-类加载检查" class="headerlink" title="1.1 类加载检查"></a>1.1 类加载检查</h3><p>虚拟机遇到new之后，首先会去常量池中找这个类的<strong>符号引用</strong>，并检查这个符号引用代表的类是否已经被加载、解析和初始化过，如果找到了，就可以根据已有的信息划分空间、分配内存、初始化等等；<strong>如果没找到，那必须先执行相应的类加载过程</strong>，类加载过程以后的笔记在详细说明。</p><h3 id="1-2-内存分配"><a href="#1-2-内存分配" class="headerlink" title="1.2 内存分配"></a>1.2 内存分配</h3><p>类加载检查通过之后，虚拟机将为新生对象分配内存，所需内存大小在类加载完成后就已经完全确定了，<strong>虚拟机要做的只是把一块确定大小的内存从Java堆中划分出来</strong>，怎么划分又要分两种情况看了。</p><ol><li><strong>假设Java堆中内存时绝对规整的</strong>，所有用过的内存都放在一边，空闲的内存放在另一边，那中间再放一个指针作为分界点指示器，那分配内存只要移动指针就完事了，这种分配方式被称为<strong>指针碰撞</strong>。</li><li><strong>假设内存并不是规整的</strong>，使用的内存和空闲的内存相互交错，这时候<strong>虚拟机得维护一个列表</strong>，记录那些内存块是空闲的，分配时就从列表里找到一个够大的空间分配给实例，并更新列表，这种分配方式被称为<strong>空闲列表</strong>。</li></ol><p>选择哪种方式由<strong>Java堆是否规整来决定</strong>，而Java堆是否规整又由<strong>所采用的垃圾收集器是否带有压缩整理功能决定</strong>。</p><p>除了如何划分可用空间外，还有另外需要考虑的问题<strong>线程安全</strong>问题，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。解决这个问题有两种方案，<strong>一种是对分配内存空间的动作进行同步处理，另一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲</strong>（Thread Local Allocation Buffer,TLAB）</p><h3 id="1-3-初始化"><a href="#1-3-初始化" class="headerlink" title="1.3 初始化"></a>1.3 初始化</h3><p>内存分配完成后，<strong>虚拟机需要将分配到的内存空间都初始化为零值</strong>，<strong>如果使用了TLAB，这一工作过程也可以提前至TLAB分配时进行</strong>，这一步保证了对象实例字段在Java代码中不初始化就可以直接使用，这也是Java默认初始值的原理。</p><h3 id="1-4-进行必要的设置"><a href="#1-4-进行必要的设置" class="headerlink" title="1.4 进行必要的设置"></a>1.4 进行必要的设置</h3><p>虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头（Object Header）之中。根据虚拟机当前的运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p><h3 id="1-5-方法的执行"><a href="#1-5-方法的执行" class="headerlink" title="1.5 方法的执行"></a>1.5 <init>方法的执行</h3><p>虚拟机的眼中，新对象已经诞生，但是从Java程序的角度，还差最后一步，执行new指令之后会接着执行＜init＞方法，把对象按照程序员的意愿进行初始化，这样一个真正程序可用的对象才算完全产生出来。</p><h2 id="2-对象的内存布局"><a href="#2-对象的内存布局" class="headerlink" title="2. 对象的内存布局"></a>2. 对象的内存布局</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;HotSpot虚拟机对象探秘&quot;&gt;&lt;a href=&quot;#HotSpot虚拟机对象探秘&quot; class=&quot;headerlink&quot; title=&quot;HotSpot虚拟机对象探秘&quot;&gt;&lt;/a&gt;HotSpot虚拟机对象探秘&lt;/h1&gt;&lt;h2 id=&quot;1-对象的创建&quot;&gt;&lt;a href=</summary>
      
    
    
    
    <category term="技术学习" scheme="https://saw96x.github.io/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Java" scheme="https://saw96x.github.io/tags/Java/"/>
    
    <category term="JVM" scheme="https://saw96x.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存结构</title>
    <link href="https://saw96x.github.io/post/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.html"/>
    <id>https://saw96x.github.io/post/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.html</id>
    <published>2021-08-12T02:01:18.000Z</published>
    <updated>2021-08-12T02:01:08.366Z</updated>
    
    <content type="html"><![CDATA[<p>本篇笔记不定期更新</p><h2 id="内存结构图"><a href="#内存结构图" class="headerlink" title="内存结构图"></a>内存结构图</h2><p>先上图<br><img src="https://img-blog.csdnimg.cn/bf995bbfbfcc4629ab3ef9f83c78d099.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhdzk2eA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>这张图差不多就把JVM的内存结构以及和class源文件，JVM执行引擎，以及操作系统自带的本地方法接口之间的关系囊括进去了。</p><p>下面我们就JVM内存结构的几个组成部分来逐一简单介绍一下</p><h2 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1. 程序计数器"></a>1. 程序计数器</h2><h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><p>Program Counter Register 程序计数器（寄存器）</p><h3 id="1-2-作用"><a href="#1-2-作用" class="headerlink" title="1.2 作用"></a>1.2 作用</h3><ol><li>在执行当前指令时，记住下一条JVM指令的执行地址，所以PCR也被称为寄存器，在物理上通过CPU寄存器实现</li><li>在多线程程序中起到一个记录上下文的作用，方便切换线程时可以继续运行</li><li>字节码解释器通过改变PCR的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要PCR来完成</li><li>如果线程正在执行Java方法，那么PCR记录的市正在执行的虚拟机字节码指令的地址，如果正在执行的是Native方法，这个计数器值则为空（Undefined）</li></ol><h3 id="1-3-特点"><a href="#1-3-特点" class="headerlink" title="1.3 特点"></a>1.3 特点</h3><ul><li>Java支持多线程，而PCR是线程私有的，每个线程都有自己的PCR</li><li>不会存在内存溢出此内存区域，是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域</li><li>生命周期与线程相同</li></ul><h2 id="2-虚拟机栈"><a href="#2-虚拟机栈" class="headerlink" title="2. 虚拟机栈"></a>2. 虚拟机栈</h2><p>栈–线程运行需要的内存空间，由栈帧组成，栈帧看为栈内的元素</p><p>栈帧–每个方法运行时所需要的内存，参数，局部变量，返回地址等等····</p><p>当调用某个方法时，会给栈帧分配内存，并将这个栈帧压入栈中，运行完毕后，会释放内存，也就是弹出栈帧。</p><p>当方法调用方法时，就会压入多个栈帧</p><h3 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h3><p>Java Virtual Machine Stacks</p><ul><li>每个线程运行时需要的内存，称为虚拟机栈</li><li>每个栈由多个栈帧（Frame）祖传，对应着每次方法调用时所占用的内存，一般来说是局部变量</li><li>每个线程只能由一个活动栈帧，对应着当前正在执行的那个方法，也就是目前栈顶的那个栈帧</li><li>线程私有的，生命周期与线程相同</li><li>栈中有局部变量表，存放了编译期可知的各种基本数据类型、对象引用（reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。</li></ul><p>问题辨析</p><ol><li><p>垃圾回收是否涉及栈内存？不涉及，栈内存只和方法有关，方法运行完毕后栈帧出栈，内存自动回收。</p></li><li><p>栈内存分配越大越好吗？不是，内存分配得越大，线程就越少，因为物理内存是确定的，内存分配的越大，能更多次的进行方法递归。一般来说，默认的分配内存已经够用了。</p></li><li><p>方法内的局部变量是否线程安全？</p><p>是的，因为每个线程只对应一个虚拟机栈，和其他方法的线程是互不干扰的，本质上操作的局部变量完全没有关系，因此是线程安全的。但如果不是局部变量，而是静态变量，或者是方法参数、或者是局部变量作为返回值返回了，那么就线程不安全，因为这时不同线程操纵的变量是同一个变量了。</p><p>简单来说，如果方法内局部变量没有逃离方法的作用范围，那么他就是线程安全的</p></li></ol><h3 id="2-2-栈内存溢出"><a href="#2-2-栈内存溢出" class="headerlink" title="2.2 栈内存溢出"></a>2.2 栈内存溢出</h3><p>   -Xss 栈内存分配大小命令</p><p>   StackOverflowError</p><ul><li>栈帧过多导致栈内存溢出，如递归调用但没设置中止条件，或是出现了循环引用问题</li><li>栈帧过大导致栈内存溢出</li></ul><h3 id="2-3-实际演示"><a href="#2-3-实际演示" class="headerlink" title="2.3 实际演示"></a>2.3 实际演示</h3><p>在idea中，通过断点调试，我们可以观测到栈帧的存在<br>运行如下代码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class StackTest &#123;  public static int add(int a, int b) &#123;    return a + b;  &#125;  public static void main(String[] args) &#123;    add(1, 2);  &#x2F;&#x2F;在这句打断点  &#125;&#125;</code></pre><p>程序运行到断点处停止，我们看debugger窗口<br><img src="https://img-blog.csdnimg.cn/bd5113f93e4b4afead467b0d2084cc8c.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhdzk2eA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>可以看得到Frames这个子窗口，这表示的就是栈帧的集合，也就是虚拟机栈，我们的程序在main方法中的add暂停，所以目前栈帧中只有一个main方法，我们运行到下一步看看<br><img src="https://img-blog.csdnimg.cn/52e00e7f2a634217ba041a3cb4d6d410.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhdzk2eA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>可以看到main栈帧的上方有了add，这符合栈后进先出的特点，可以预见，如果addd中继续调用方法，那么add栈帧之上又会有新的栈帧。</p><p>现在我们继续运行程序，让add方法运行完毕<br><img src="https://img-blog.csdnimg.cn/d94890ad9d104242b18f54d08027e2bd.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhdzk2eA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>可以看到add的栈帧消失了，也就是add方法的运行内存被释放了。<br>这个小demo可以看出栈帧扮演的角色和运行方式。</p><h2 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3. 本地方法栈"></a>3. 本地方法栈</h2><p>Native Method Stacks</p><ul><li><p>发挥的作用和虚拟机栈发挥的作用相似，区别只是本地方法栈执行本地方法，虚拟机栈执行Java方法</p></li><li><p>本地方法：Native Method ，不是Java编写的代码，通常是操作系统自带的方法代码。</p></li><li><p>本地方法栈为本地方法的运行提供内存空间</p></li><li><p>在规范中对本地方法栈的实现方式（语言、数据结构）没有强制规定，具体的虚拟机可以自由的实现它，有的虚拟机（Sun HotSpot）甚至将本地方法栈和虚拟机栈合二为一</p></li></ul><h2 id="4-堆"><a href="#4-堆" class="headerlink" title="4. 堆"></a>4. 堆</h2><h3 id="4-1定义"><a href="#4-1定义" class="headerlink" title="4.1定义"></a>4.1定义</h3><p>Heap 堆</p><ul><li>通过new关键字，创建对象都会使用堆内存</li><li>唯一目的就是存放对象实例，这一点在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配，但随着优化技术的产生，将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了</li><li>可以细分为新生代和老年代，再细一点的有Eden空间、From Survivor空间、To Survivor空间等</li><li>根据规范规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，实现时可以实现成固定大小或可扩展的，目前主流虚拟机都是可扩展的</li></ul><p>特点</p><ul><li>它是线程共享的，堆中对象都需要考虑线程安全的问题</li><li>有垃圾回收机制</li><li>对多数应用而言，堆是Java虚拟机所管理的内存中最大的一块</li><li>在虚拟机启动时创建</li></ul><h3 id="4-2-堆内存溢出"><a href="#4-2-堆内存溢出" class="headerlink" title="4.2 堆内存溢出"></a>4.2 堆内存溢出</h3><p>-Xmx 堆内存分配大小命令</p><p>OutOfMemoryError : Java heap space</p><p>垃圾回收：没人用的对象，就作为垃圾被回收</p><p>堆内存溢出：大量的对象被不断创建，同时一直被使用，可能导致堆内存溢出</p><h3 id="4-3-堆内存诊断"><a href="#4-3-堆内存诊断" class="headerlink" title="4.3 堆内存诊断"></a>4.3 堆内存诊断</h3><p>在idea控制台窗口即可运行</p><ol><li>jps工具<ul><li>查看当前系统中有哪些Java进程</li></ul></li><li>jmap工具<ul><li>查看堆内存占用情况 ，不连续，只能查看某一时刻的情况</li><li>jmap -heap 进程id</li></ul></li><li>jconsole<ul><li>图形界面，多功能检测工具，可连续监测</li></ul></li></ol><p>案例：</p><ul><li>垃圾回收后，内存占用率仍然很高</li><li>使用jvisualvm工具，通过堆dump功能查看对象在某一时刻的具体情况，从而做出诊断</li></ul><h2 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5. 方法区"></a>5. 方法区</h2><h3 id="5-1-定义"><a href="#5-1-定义" class="headerlink" title="5.1 定义"></a>5.1 定义</h3><p>Method Area</p><p>方法区是所有Java虚拟机线程共享的区域，它存储了与类结构相关的信息，如成员变量，方法数据，成员方法和构造器的代码部分，运行时常量池。</p><p>方法区在虚拟机启动时就被创建，逻辑上它是堆的组成部分，但具体实现不同的jvm有所不同</p><h3 id="5-2-组成"><a href="#5-2-组成" class="headerlink" title="5.2 组成"></a>5.2 组成</h3><p>待补充</p><h3 id="5-3-方法区内存溢出"><a href="#5-3-方法区内存溢出" class="headerlink" title="5.3 方法区内存溢出"></a>5.3 方法区内存溢出</h3><p>-XX:MaxMetaspaceSize 设置元空间大小</p><p>OutOfMemoryError:Metaspace</p><ul><li>1.8以前会导致永久代内存溢出</li><li>1.8以后会导致元空间内存溢出</li></ul><h3 id="5-4-运行时常量池"><a href="#5-4-运行时常量池" class="headerlink" title="5.4 运行时常量池"></a>5.4 运行时常量池</h3><ul><li>常量池，就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息</li><li>运行时常量池，常量池是 *.class 文件中的，当该类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址</li></ul><h3 id="5-5-StringTable特性"><a href="#5-5-StringTable特性" class="headerlink" title="5.5 StringTable特性"></a>5.5 StringTable特性</h3><ul><li>常量池中的字符串仅是符号，第一次用到时才变为对象</li><li>利用串池的机制，来避免重复创建字符串对象</li><li>字符串变量拼接的原理是StringBuilder（jdk1.8）</li><li>字符串常量拼接的原理是编译期优化</li><li>可以使用intern方法，主动将串池中还没有的字符串对象放入串池<ul><li>1.8中，将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池，会把串池中的对象返回</li><li>1.6中，将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则会把此对象复制一份，再放入串池，会把串池中的对象返回</li></ul></li></ul><h3 id="5-6-StringTable位置"><a href="#5-6-StringTable位置" class="headerlink" title="5.6 StringTable位置"></a>5.6 StringTable位置</h3><ul><li>1.8，StringTable在堆（Heap）中</li><li>1.6，StringTable在永久代（PermGen）中</li></ul><h3 id="5-7-StringTable垃圾回收"><a href="#5-7-StringTable垃圾回收" class="headerlink" title="5.7 StringTable垃圾回收"></a>5.7 StringTable垃圾回收</h3><h3 id="5-8-StringTable性能调优"><a href="#5-8-StringTable性能调优" class="headerlink" title="5.8 StringTable性能调优"></a>5.8 StringTable性能调优</h3><ul><li>StringTable本质上是哈希表，因此调优就是调整桶的个数，适当的把桶的个数调大，减少哈希碰撞   -XX:StringTableSize=桶个数</li><li>考虑将字符串对象是否入池</li><li>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当量池无法再申请到内存时会抛出OutOfMemoryError异常。</li></ul><h2 id="6-直接内存"><a href="#6-直接内存" class="headerlink" title="6. 直接内存"></a>6. 直接内存</h2><h3 id="6-1-定义"><a href="#6-1-定义" class="headerlink" title="6.1 定义"></a>6.1 定义</h3><p>Direct Memory</p><ul><li>常见于NIO（一种基于通道（Channel）与缓<br>冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作）操作，用于数据缓存区</li><li>分配回收成本较高，但读写性能高，因为避免了在Java堆和Native堆中来回复制数据</li><li>不受JVM内存回收管理</li></ul><h3 id="6-2-分配和回收原理"><a href="#6-2-分配和回收原理" class="headerlink" title="6.2 分配和回收原理"></a>6.2 分配和回收原理</h3><ul><li>使用了Unsafe对象完成直接内存的分配回收，并且回收需要主动调用的freeMemory方法</li><li>ByteBuffer的实现类内部，使用了Cleaner（虚引用）来检测ByteBuffer对象，一旦ByteBuffer对象被垃圾回收，那么就会有ReferenceHandler线程通过Cleaner的clean方法调用freeMemory来释放直接内存</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本篇笔记不定期更新&lt;/p&gt;
&lt;h2 id=&quot;内存结构图&quot;&gt;&lt;a href=&quot;#内存结构图&quot; class=&quot;headerlink&quot; title=&quot;内存结构图&quot;&gt;&lt;/a&gt;内存结构图&lt;/h2&gt;&lt;p&gt;先上图&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg</summary>
      
    
    
    
    <category term="技术学习" scheme="https://saw96x.github.io/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Java" scheme="https://saw96x.github.io/tags/Java/"/>
    
    <category term="JVM" scheme="https://saw96x.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 03. 数组中重复的数字的4种解法（Java语言）</title>
    <link href="https://saw96x.github.io/post/%E5%89%91%E6%8C%87%20Offer%2003.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97%E7%9A%844%E7%A7%8D%E8%A7%A3%E6%B3%95%EF%BC%88Java%E8%AF%AD%E8%A8%80%EF%BC%89.html"/>
    <id>https://saw96x.github.io/post/%E5%89%91%E6%8C%87%20Offer%2003.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97%E7%9A%844%E7%A7%8D%E8%A7%A3%E6%B3%95%EF%BC%88Java%E8%AF%AD%E8%A8%80%EF%BC%89.html</id>
    <published>2021-08-04T08:20:41.000Z</published>
    <updated>2021-08-06T13:49:19.956Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目详情"><a href="#题目详情" class="headerlink" title="题目详情"></a>题目详情</h2><p>找出数组中重复的数字。</p><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p><p>示例 1：</p><p>输入：<br>[2, 3, 1, 0, 2, 5, 3]<br>输出：2 或 3 </p><h2 id="解法一：暴力法，双层循环"><a href="#解法一：暴力法，双层循环" class="headerlink" title="解法一：暴力法，双层循环"></a>解法一：暴力法，双层循环</h2><p>直接进行两层循环，对每个数字都逐一比较，空间复杂度O(1)，时间复杂度O(n^2)，总的来说是下下策，执行用时吓死人<br><img src="https://img-blog.csdnimg.cn/3075c099b4af457dbd8c8ffe43a3945f.PNG#pic_center" alt="在这里插入图片描述"><br>Java代码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public int findRepeatNumber_1(int[] nums) &#123;    for (int i &#x3D; 0; i &lt; nums.length; i++)      for (int j &#x3D; i + 1; j &lt; nums.length; j++)        if (nums[i] &#x3D;&#x3D; nums[j])          return nums[i];    return -1;  &#125;</code></pre><h2 id="解法二-排序后相邻的两两比较"><a href="#解法二-排序后相邻的两两比较" class="headerlink" title="解法二 排序后相邻的两两比较"></a>解法二 排序后相邻的两两比较</h2><p>很容易想到的方法，排序后两两比较，空间复杂度O(1)，时间复杂度O(nlogn)，只能说是中下策，但执行用时已经有了相当的改善<br><img src="https://img-blog.csdnimg.cn/9f01f52a148f4f3399936eedf4904588.PNG#pic_center" alt="在这里插入图片描述"><br>Java代码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public int findRepeatNumber_2(int[] nums) &#123;    Arrays.sort(nums);    for (int i &#x3D; 0; i &lt; nums.length - 1; i++) &#123;      if (nums[i] &#x3D;&#x3D; nums[i + 1])        return nums[i];    &#125;    return -1;  &#125;</code></pre><h2 id="解法三-利用数组实现一个map映射"><a href="#解法三-利用数组实现一个map映射" class="headerlink" title="解法三 利用数组实现一个map映射"></a>解法三 利用数组实现一个map映射</h2><p>首先，判断重复，常见的办法就是利用HashMap或是HashSet来判断，但我们观察数组发现，给定的值都是0~n-1，那么我们没必要使用集合类来加重负担，直接用数组就可以完成映射，给定的数组元素为键，出现次数为值。<br>空间复杂度为O(n)，时间复杂度为O(n)，在大多数面试中已经算是可以让人接受的答案了。<br><img src="https://img-blog.csdnimg.cn/44d453122fbd47539088318a84a3b140.PNG#pic_center" alt="在这里插入图片描述"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public int findRepeatNumber_3(int[] nums) &#123;    int[] map &#x3D; new int[nums.length];    for (int i &#x3D; 0; i &lt; nums.length; i++) &#123;      if (map[nums[i]] &#x3D;&#x3D; 0)        map[nums[i]]++;      else        return nums[i];    &#125;    return -1;  &#125;</code></pre><h2 id="解法四-利用重排后的元素碰撞"><a href="#解法四-利用重排后的元素碰撞" class="headerlink" title="解法四 利用重排后的元素碰撞"></a>解法四 利用重排后的元素碰撞</h2><p>解法三已经达到了空间时间复杂度都是O(n)的情况，实际上还能继续优化，达到O(1)的空间复杂度。<br>我们知道，数组中的元素是0~n-1，那么可以想到，如果没有重复的元素，那么排序后，每个元素都应该和它的下标相同，那么如果有重复的元素，那么两个元素就会撞到一起。<br>基于这种思路，我们设计如下算法：对每个元素都进行处理，把它交换到它应该在的位置，如果交换前发现那个位置上的元素和它相等，也就是撞车了，那么很明显这个元素就是重复的数字。<br>每个数字只要进行交换就能找到自己的位置，时间复杂度是O(n)，且没有用到额外的空间，因此空间复杂度只有O(1)</p><p><img src="https://img-blog.csdnimg.cn/5be8fe2d4adf4ba1afedb4e5c97c069e.PNG#pic_center" alt="在这里插入图片描述"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public int findRepeatNumber_4(int[] nums) &#123;    for (int i &#x3D; 0; i &lt; nums.length; i++) &#123;      while (nums[i] !&#x3D; i) &#123;        &#x2F;&#x2F;两个数撞了        if (nums[i] &#x3D;&#x3D; nums[nums[i]]) &#123;          return nums[i];        &#125;        &#x2F;&#x2F;把一个数交换到它应该在的位置        int temp &#x3D; nums[nums[i]];        nums[nums[i]] &#x3D; nums[i];        nums[i] &#x3D; temp;      &#125;    &#125;    return -1;  &#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目详情&quot;&gt;&lt;a href=&quot;#题目详情&quot; class=&quot;headerlink&quot; title=&quot;题目详情&quot;&gt;&lt;/a&gt;题目详情&lt;/h2&gt;&lt;p&gt;找出数组中重复的数字。&lt;/p&gt;
&lt;p&gt;在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些</summary>
      
    
    
    
    <category term="技术学习" scheme="https://saw96x.github.io/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="数据结构与算法" scheme="https://saw96x.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指Offer" scheme="https://saw96x.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>Springboot的自动装配原理浅析</title>
    <link href="https://saw96x.github.io/post/Springboot%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90.html"/>
    <id>https://saw96x.github.io/post/Springboot%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90.html</id>
    <published>2021-08-04T08:16:55.000Z</published>
    <updated>2021-08-06T13:48:29.684Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学习Springboot，不少文章和视频在完成了第一个快速入门的项目之后就直接进入了Springboot运行的原理部分，因此决定写一篇文章加深理解。</p><p>原理的理解主要使用了查看源码和画流程图的方式。</p><h3 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h3><p>对于一个maven项目，我们一般首要分析其pom文件，查看相关依赖。</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;dependencies&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;        &lt;&#x2F;dependency&gt;        &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;            &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;            &lt;scope&gt;test&lt;&#x2F;scope&gt;            &lt;exclusions&gt;                &lt;exclusion&gt;                    &lt;groupId&gt;org.junit.vintage&lt;&#x2F;groupId&gt;                    &lt;artifactId&gt;junit-vintage-engine&lt;&#x2F;artifactId&gt;                &lt;&#x2F;exclusion&gt;            &lt;&#x2F;exclusions&gt;        &lt;&#x2F;dependency&gt;    &lt;&#x2F;dependencies&gt;    &lt;build&gt;        &lt;plugins&gt;            &lt;plugin&gt;                &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;                &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;            &lt;&#x2F;plugin&gt;        &lt;&#x2F;plugins&gt;    &lt;&#x2F;build&gt;</code></pre><p>可以看到依赖方面都是很简单的内容，加入了测试启动器和web启动器以及springboot的build插件，但我们发现了一个不一般的地方，他们都没有版本号！这是为什么呢？<br>   我们往上查看，可以发现这样的父依赖。</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;        &lt;version&gt;2.3.4.RELEASE&lt;&#x2F;version&gt;        &lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;    &lt;&#x2F;parent&gt;</code></pre><p>   我们点进去查看，会发现。。。还有一层父依赖！<br>   <pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"> &lt;parent&gt;  &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;  &lt;artifactId&gt;spring-boot-dependencies&lt;&#x2F;artifactId&gt;  &lt;version&gt;2.3.4.RELEASE&lt;&#x2F;version&gt;&lt;&#x2F;parent&gt;</code></pre><br>   继续点进去查看。</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml">&lt;properties&gt;    &lt;activemq.version&gt;5.15.13&lt;&#x2F;activemq.version&gt;    &lt;antlr2.version&gt;2.7.7&lt;&#x2F;antlr2.version&gt;    &lt;appengine-sdk.version&gt;1.9.82&lt;&#x2F;appengine-sdk.version&gt;    &lt;artemis.version&gt;2.12.0&lt;&#x2F;artemis.version&gt;    &lt;aspectj.version&gt;1.9.6&lt;&#x2F;aspectj.version&gt;    &lt;assertj.version&gt;3.16.1&lt;&#x2F;assertj.version&gt;    &lt;atomikos.version&gt;4.0.6&lt;&#x2F;atomikos.version&gt;    &lt;awaitility.version&gt;4.0.3&lt;&#x2F;awaitility.version&gt;    &lt;bitronix.version&gt;2.1.4&lt;&#x2F;bitronix.version&gt;    &lt;build-helper-maven-plugin.version&gt;3.1.0&lt;&#x2F;build-helper-maven-plugin.version&gt;    &lt;byte-buddy.version&gt;1.10.14&lt;&#x2F;byte-buddy.version&gt;    &lt;caffeine.version&gt;2.8.5&lt;&#x2F;caffeine.version&gt;    &lt;cassandra-driver.version&gt;4.6.1&lt;&#x2F;cassandra-driver.version&gt;    ...........</code></pre><pre class="line-numbers language-none"><code class="language-none">这样的信息就是这些依赖尽头的主体了，这个文件有大量的配置信息，标注了每个可能用到的依赖的版本号，因此我们不用指定依赖的版本，springboot会根据你使用的版本自动给你安排合适的版本，再也不用担心依赖版本的冲突导致的崩溃啦！pom.xml文件我们就说到这里，接下来才是重头戏了！思维导图：![在这里插入图片描述](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;20200929160256862.png#pic_center)### 启动类的@SpringBootApplication注解启动类包括两个重要的部分，一个是@SpringBootApplication注解，另一个是其中的run方法，我们先从这个注解开始说起。首先，这个注解的作用，猜也猜得到，是标注这个应用是一个springboot应用，这样springboot就可以帮我们对其进行自动配置，我们想要了解，spring boot是如何通过注解来自动装配的，装配了什么。老办法，查看源码，我点！&#96;&#96;&#96;java@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan</code></pre><p>以上是@SpringBootApplication注解之下的几个注解，出去那些基础的之外，我们可以看见三个特别显眼的，@SpringBootConfiguration，@ComponentScan，@EnableAutoConfiguration，我们逐个查看他们的源码。</p><h4 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h4><p>他的源码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Configuration</code></pre><p>乏善可陈。。。根据其下的@Configuration可以猜到，它是起到一个标注作用的注解，标志当前应用为一个springboot应用。</p><p>我们回到上一层查看其他注解的源码。</p><h4 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h4><p>这个更没啥好说的了，源码都没必要看了，他的作用是扫描指定包下的组件，将它们加载到Spring的IOC容器之中，很重要，但不是我们探究的重点。</p><p>我们查看最后一个注解的源码。</p><h4 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h4><p>看得出来，他的作用是启用自动配置，我们重点关注如何启用，怎么启用，启用了什么。<br>他的源码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@AutoConfigurationPackage@Import(&#123;AutoConfigurationImportSelector.class&#125;)</code></pre><p>看起来重要的注解就这两个，第一个看翻译是自动配置包，我们点进去查看他的源码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">@Import(&#123;Registrar.class&#125;)</code></pre><p>噢，这是一个注册器，根据相关源码猜测是将bean注册导入到容器之中（若有错误希望指正）。</p><p>我们回头，看看import导入的东西。</p><p>自动配置导入选择器，我们猜测它是导入了需要的配置文件，查看源码：<br><img src="https://img-blog.csdnimg.cn/20200929162249237.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhdzk2eA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>我这里截图还没有截全。。。我们发现其中有相当多的方法，我们的目的是查看如何加载组件的，因此寻找configuration相关的方法。</p><p>找到了！getCandidateConfigurations，获取候选配置，这个方法中又使用了SpringFactoriesLoader，我们继续深入。<br><code>public static final String FACTORIES_RESOURCE_LOCATION = &quot;META-INF/spring.factories&quot;;</code><br>看到了看起来是文件的东西！我们使用全局搜索，发现它在springboot的jar包内，我们再点开来看看</p><p><img src="https://img-blog.csdnimg.cn/20200929162722643.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhdzk2eA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">我们根据源头打开spring.factories ， 看到了很多自动配置的文件；这就是自动配置根源所在！可以随便点开看看，都可以看到这些一个个的都是JavaConfig配置类，而且都注入了一些Bean。</p><p>至此，我们大概明白了Spring boot的自动装配原理了：</p><p>自动配置真正实现是从classpath中搜寻所有的META-INF/spring.factories配置文件 ，并将其中对应的 org.springframework.boot.autoconfigure. 包下的配置项，通过反射实例化为对应标注了 @Configuration的JavaConfig形式的IOC容器配置类 ， 然后将这些都汇总成为一个实例并加载到IOC容器中。</p><p>所以其实刚刚那一大串套娃注解其实都是为了拿到spring.factories。。。我不太懂设计模式，不太懂这样做的意义是什么样的哈哈哈。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ol><li><p>SpringBoot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值</p></li><li><p>将这些值作为自动配置类导入容器 ， 自动配置类就生效 ， 帮我们进行自动配置工作；</p></li><li><p>整个J2EE的整体解决方案和自动配置都在springboot-autoconfigure的jar包中；</p></li><li><p>它会给容器中导入非常多的自动配置类 （xxxAutoConfiguration）, 就是给容器中导入这个场景需要的所有组件 ， 并配置好这些组件 ；</p></li><li><p>有了自动配置类 ， 免去了我们手动编写配置注入功能组件等的工作；</p></li></ol><p>思维导图：<br><img src="https://img-blog.csdnimg.cn/20200929164052679.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhdzk2eA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h3 id="run方法"><a href="#run方法" class="headerlink" title="run方法"></a>run方法</h3><p>分析该方法主要分两部分，一部分是SpringApplication的实例化，二是run方法的执行；<br>SpringApplication</p><p>这个类主要做了以下四件事情：</p><p>1、推断应用的类型是普通的项目还是Web项目</p><p>2、查找并加载所有可用初始化器 ， 设置到initializers属性中</p><p>3、找出所有的应用程序监听器，设置到listeners属性中</p><p>4、推断并设置main方法的定义类，找到运行的主类</p><p>源码分析无力了。。。给大家一张图吧，说的很清楚了，大家可以跟着这张图自己读读源码。</p><p><img src="https://img-blog.csdnimg.cn/20200929163826667.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhdzk2eA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近在学习Springboot，不少文章和视频在完成了第一个快速入门的项目之后就直接进入了Springboot运行的原理部分，因此决定写一篇文章加深理解。&lt;/p&gt;
&lt;p&gt;原理的理解主要使用了查看源码和画流程图的方式。&lt;/p&gt;
&lt;h3 id=&quot;pom-xml&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="技术学习" scheme="https://saw96x.github.io/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Java" scheme="https://saw96x.github.io/tags/Java/"/>
    
    <category term="源码分析" scheme="https://saw96x.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    <category term="SpringBoot" scheme="https://saw96x.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Java new ArrayList(int initialCapacity)初始化容量问题</title>
    <link href="https://saw96x.github.io/post/Java%20new%20ArrayList(int%20initialCapacity)%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AE%B9%E9%87%8F%E9%97%AE%E9%A2%98.html"/>
    <id>https://saw96x.github.io/post/Java%20new%20ArrayList(int%20initialCapacity)%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AE%B9%E9%87%8F%E9%97%AE%E9%A2%98.html</id>
    <published>2021-08-04T07:35:13.000Z</published>
    <updated>2021-08-06T13:49:54.974Z</updated>
    
    <content type="html"><![CDATA[<p>今天看了ArrayList源码，发现了一个不大不小的问题：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public ArrayList(int initialCapacity) &#123;        if (initialCapacity &gt; 0) &#123;            this.elementData &#x3D; new Object[initialCapacity];        &#125; else if (initialCapacity &#x3D;&#x3D; 0) &#123;            this.elementData &#x3D; EMPTY_ELEMENTDATA;        &#125; else &#123;            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+                                               initialCapacity);        &#125;    &#125;</code></pre><p>这个构造函数咋一看问题不大，给elementData底层数组分配空间嘛，初始化数组的大小了<br>但是实际使用时：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">ArrayList&lt;Integer&gt; a &#x3D; new ArrayList(9);a.set(1,5);</code></pre><p>抛出了IndexOutOfBoundsException</p><p>结合源码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public E set(int index, E element) &#123;        Objects.checkIndex(index, size);        E oldValue &#x3D; elementData(index);        elementData[index] &#x3D; element;        return oldValue;    &#125;</code></pre><p>其中第一行首先检测了下标，参数是index和size，而size是元素个数，也就是说，尽管设置了数组的容量，但针对ArrayList中元素的操作，是根据元素的位置，而不是根据容量来操作。也就是说，至少得有个元素才能set它，没有元素就是set个寂寞。</p><p>因此<code>set(1,5)</code>在第一行直接抛出异常了</p><p>综上所述ArrayList(int initialCapacity) 只是<strong>让ArrayList有了容纳 initialCapacity个元素的潜力，并不能对其中的“位置”操作</strong>。</p><p>PS：这个问题在Java核心技术卷1中就有提到，但我当时直接忘了，果然看了源码才理解的透彻。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天看了ArrayList源码，发现了一个不大不小的问题：&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-java&quot; data-language=&quot;java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;public ArrayLi</summary>
      
    
    
    
    <category term="技术学习" scheme="https://saw96x.github.io/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Java" scheme="https://saw96x.github.io/tags/Java/"/>
    
    <category term="源码分析" scheme="https://saw96x.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
</feed>
