<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Saw96x</title>
  
  <subtitle>Think twice, code once.</subtitle>
  <link href="https://saw96x.github.io/atom.xml" rel="self"/>
  
  <link href="https://saw96x.github.io/"/>
  <updated>2021-08-09T12:54:36.967Z</updated>
  <id>https://saw96x.github.io/</id>
  
  <author>
    <name>Saw96x</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JVM垃圾回收</title>
    <link href="https://saw96x.github.io/post/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.html"/>
    <id>https://saw96x.github.io/post/JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.html</id>
    <published>2021-08-08T01:39:37.000Z</published>
    <updated>2021-08-09T12:54:36.967Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM垃圾回收"><a href="#JVM垃圾回收" class="headerlink" title="JVM垃圾回收"></a>JVM垃圾回收</h1><p>持续更新</p><h2 id="1-如何判断对象可以回收"><a href="#1-如何判断对象可以回收" class="headerlink" title="1. 如何判断对象可以回收"></a>1. 如何判断对象可以回收</h2><h3 id="1-1-简要介绍："><a href="#1-1-简要介绍：" class="headerlink" title="1.1 简要介绍："></a>1.1 简要介绍：</h3><ol><li>引用计数法，如果某个对象被引用了，则他的计数加1，不再被引用了，则减1，计数为0则回收。弊端：循环引用，比如a和b相互引用，即使他们两个永远都不再被使用了，但是由于存在引用计数，所以永远都不会被回收。早期python虚拟机采用这种算法。</li><li>可达性分析算法：首先确定根对象（肯定不能被垃圾回收的对象），进行垃圾回收前对所有对象进行一次扫描，如果被根对象直接或间接应用的对象就不能被回收，如果没有被引用，那么就可以被回收。JVM虚拟机采用这种算法进行</li></ol><h3 id="1-2-可达性分析算法："><a href="#1-2-可达性分析算法：" class="headerlink" title="1.2 可达性分析算法："></a>1.2 可达性分析算法：</h3><ul><li><p>Java虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象</p></li><li><p>扫描堆中的对象，看是否能够沿这GC Root对象为起点的引用链找到该对象，找不到，表示可以回收</p><h4 id="哪些对象可以作为GC-Root对象"><a href="#哪些对象可以作为GC-Root对象" class="headerlink" title="哪些对象可以作为GC Root对象"></a>哪些对象可以作为GC Root对象</h4></li></ul><p> SystemClass：由自举/系统类加载器加载的类。例如，rt.jar中所有诸如<a href="https://www.baidu.com/s?wd=java.util&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">java.util</a>.*的类。<br> JNILocal：原生代码中的本地变量，例如用户定义的JNI（Java本地接口，一般用来使Java代码和其他语言代码进行交互）代码或JVM内部代码。<br> JNIGlobal：原生代码中的全局变量，例如用户定义的JNI代码或JVM内部代码。<br> ThreadBlock：当前活跃的线程块中引用的对象。<br> Thread：启动且未停止的线程。<br> BusyMonitor：其wait()或notify()方法被调用，或被同步synchronized的对象。例如，通过调用synchronized(Object)或者进入其某个synchronized方法。静态方法对应类，非静态方法对应对象。<br> JavaLocal：本地变量。例如，仍在线程的栈中的方法输入参数或本地创建的对象。<br> NativeStack：（例如用户定义的JNI代码或JVM内部代码这样的）原生代码的入或出参数。通常发生在许多方法有原生部分，方法参数处理的对象成为GC根对象。例如，参数用于文件、网络I/O或反射。<br> Finalizer：在队列中等待其finalizer运行的对象。<br> Unfinalized：拥有finalize方法，但是还没有被终结且不在finalizer队列的对象。<br> Unreachable：从其他根对象不可达的对象，但是被内存分析器标记为根对象。<br> Unknown：没有根类型的对象。一些转储(dump)，例如IBM可移植对转储文件，没有根信息。对于这些转储，内存分析器解析程序将没有被其他根<a href="https://www.baidu.com/s?wd=%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao">对象引用</a>的对象标记为此类根对象。</p><h3 id="1-3-四种引用"><a href="#1-3-四种引用" class="headerlink" title="1.3 四种引用"></a>1.3 四种引用</h3><p><img src="https://img-blog.csdnimg.cn/12f2c23e724f4dd0b0babbfaa8df9529.PNG"></p><p>此图中，实线表示强引用，虚线表示其余引用 </p><ol><li><p>强引用</p><p><strong>可以被GC Root对象直接或间接的找到，这种关系是强引用</strong>，一般情况下，我们书写的代码基本上形成的引用关系都是强引用，<strong>只有当所有强引用都断开时，对象才会被垃圾回收</strong>，除此之外是绝不可能将其回收的。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Object</span> o <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment">//  强引用</span>o <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">//断开强引用，被回收</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>软引用</p><p>在Java中，软引用本质上是一种特殊设计的类，因此软引用实际上是被手动创建出来的，使用SoftReference类创建出来</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> str <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                     <span class="token comment">// 强引用</span><span class="token class-name">SoftReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> softRef <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SoftReference</span><span class="token operator">&lt;</span><span class="token class-name">String</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// str变为软引用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p> <strong>如果一个对象只具有软引用（通过SoftReference建立），则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些软引用对象的内存。</strong>只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p><p>最具代表性的应用，如浏览器的后退按钮，点击后退要返回到上一个页面，如果重新加载，可能耗时较长，如果将其存储到内存中，则会造成浪费，这时可以使用软引用进行缓存，如果缓存资源充足，那么就将页面保存到缓存中，如果紧张，由于软引用的特性，页面缓存会被垃圾回收器回收。</p><p>可以配合<strong>引用队列</strong>使用，如果软引用它引用的对象被回收时，软引用本身（SoftReference实例）会被放到引用队列中，可以对其方便的进行进一步处理，比如释放SoftReference实例占用的内存。</p></li><li><p>弱引用</p><p>和软引用相似，弱引用对象也要手动创建出来，使用WeakReference建立</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> st r<span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                                     <span class="token comment">//强引用</span><span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span> abcWeakRef <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakReference</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">></span></span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//str变为弱引用</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>和软引用不同的是，<strong>无论空间是否充足，只要垃圾回收器运行了，那么检测到弱引用，就会即刻将其回收</strong>。但是垃圾回收器的线程优先级很低，不太经常运行，所以不会发生马上就会被清理掉的情况。如果这个对象是偶尔的使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么你应该用 WeakReference 来记住此对象。  </p><p>可以配合<strong>引用队列</strong>使用，如果软引用它引用的对象被回收时，软引用本身（WeakReference实例）会被放到引用队列中，可以对其方便的进行进一步处理，比如释放WeakReference实例占用的内存。</p></li><li><p>虚引用</p></li><li><p>终结器引用（额外）</p></li></ol><h2 id="2-垃圾回收算法"><a href="#2-垃圾回收算法" class="headerlink" title="2. 垃圾回收算法"></a>2. 垃圾回收算法</h2><h2 id="3-分代垃圾回收"><a href="#3-分代垃圾回收" class="headerlink" title="3. 分代垃圾回收"></a>3. 分代垃圾回收</h2><h2 id="4-垃圾回收器"><a href="#4-垃圾回收器" class="headerlink" title="4. 垃圾回收器"></a>4. 垃圾回收器</h2><h2 id="5-垃圾回收调优"><a href="#5-垃圾回收调优" class="headerlink" title="5. 垃圾回收调优"></a>5. 垃圾回收调优</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;JVM垃圾回收&quot;&gt;&lt;a href=&quot;#JVM垃圾回收&quot; class=&quot;headerlink&quot; title=&quot;JVM垃圾回收&quot;&gt;&lt;/a&gt;JVM垃圾回收&lt;/h1&gt;&lt;p&gt;持续更新&lt;/p&gt;
&lt;h2 id=&quot;1-如何判断对象可以回收&quot;&gt;&lt;a href=&quot;#1-如何判断对象可</summary>
      
    
    
    
    <category term="技术学习" scheme="https://saw96x.github.io/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Java" scheme="https://saw96x.github.io/tags/Java/"/>
    
    <category term="JVM" scheme="https://saw96x.github.io/tags/JVM/"/>
    
    <category term="源码分析" scheme="https://saw96x.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title>JVM内存结构</title>
    <link href="https://saw96x.github.io/post/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.html"/>
    <id>https://saw96x.github.io/post/JVM%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84.html</id>
    <published>2021-08-06T06:55:18.000Z</published>
    <updated>2021-08-08T01:22:35.896Z</updated>
    
    <content type="html"><![CDATA[<p>本篇笔记不定期更新</p><h2 id="内存结构图"><a href="#内存结构图" class="headerlink" title="内存结构图"></a>内存结构图</h2><p>先上图<br><img src="https://img-blog.csdnimg.cn/bf995bbfbfcc4629ab3ef9f83c78d099.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhdzk2eA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>这张图差不多就把JVM的内存结构以及和class源文件，JVM执行引擎，以及操作系统自带的本地方法接口之间的关系囊括进去了。</p><p>下面我们就JVM内存结构的几个组成部分来逐一简单介绍一下</p><h2 id="1-程序计数器"><a href="#1-程序计数器" class="headerlink" title="1. 程序计数器"></a>1. 程序计数器</h2><h3 id="1-1-定义"><a href="#1-1-定义" class="headerlink" title="1.1 定义"></a>1.1 定义</h3><p>Program Counter Register 程序计数器（寄存器）</p><h3 id="1-2-作用"><a href="#1-2-作用" class="headerlink" title="1.2 作用"></a>1.2 作用</h3><ol><li>在执行当前指令时，记住下一条JVM指令的执行地址，所以PCR也被称为寄存器，在物理上通过CPU寄存器实现</li><li>在多线程程序中起到一个记录上下文的作用，方便切换线程时可以继续运行</li></ol><h3 id="1-3-特点"><a href="#1-3-特点" class="headerlink" title="1.3 特点"></a>1.3 特点</h3><ul><li>Java支持多线程，而PCR是线程私有的，每个线程都有自己的PCR</li><li>不会存在内存溢出</li></ul><h2 id="2-虚拟机栈"><a href="#2-虚拟机栈" class="headerlink" title="2. 虚拟机栈"></a>2. 虚拟机栈</h2><p>栈–线程运行需要的内存空间，由栈帧组成，栈帧看为栈内的元素</p><p>栈帧–每个方法运行时所需要的内存，参数，局部变量，返回地址等等····</p><p>当调用某个方法时，会给栈帧分配内存，并将这个栈帧压入栈中，运行完毕后，会释放内存，也就是弹出栈帧。</p><p>当方法调用方法时，就会压入多个栈帧</p><h3 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h3><p>Java Virtual Machine Stacks</p><ul><li>每个线程运行时需要的内存，称为虚拟机栈</li><li>每个栈由多个栈帧（Frame）祖传，对应着每次方法调用时所占用的内存，一般来说是局部变量</li><li>每个线程只能由一个活动栈帧，对应着当前正在执行的那个方法，也就是目前栈顶的那个栈帧</li></ul><p>问题辨析</p><ol><li><p>垃圾回收是否涉及栈内存？不涉及，栈内存只和方法有关，方法运行完毕后栈帧出栈，内存自动回收。</p></li><li><p>栈内存分配越大越好吗？不是，内存分配得越大，线程就越少，因为物理内存是确定的，内存分配的越大，能更多次的进行方法递归。一般来说，默认的分配内存已经够用了。</p></li><li><p>方法内的局部变量是否线程安全？</p><p>是的，因为每个线程只对应一个虚拟机栈，和其他方法的线程是互不干扰的，本质上操作的局部变量完全没有关系，因此是线程安全的。但如果不是局部变量，而是静态变量，或者是方法参数、或者是局部变量作为返回值返回了，那么就线程不安全，因为这时不同线程操纵的变量是同一个变量了。</p><p>简单来说，如果方法内局部变量没有逃离方法的作用范围，那么他就是线程安全的</p></li></ol><h3 id="2-2-栈内存溢出"><a href="#2-2-栈内存溢出" class="headerlink" title="2.2 栈内存溢出"></a>2.2 栈内存溢出</h3><p>   -Xss 栈内存分配大小命令</p><p>   StackOverflowError</p><ul><li>栈帧过多导致栈内存溢出，如递归调用但没设置中止条件，或是出现了循环引用问题</li><li>栈帧过大导致栈内存溢出</li></ul><h3 id="2-3-实际演示"><a href="#2-3-实际演示" class="headerlink" title="2.3 实际演示"></a>2.3 实际演示</h3><p>在idea中，通过断点调试，我们可以观测到栈帧的存在<br>运行如下代码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StackTest</span> <span class="token punctuation">&#123;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> a<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">return</span> a <span class="token operator">+</span> b<span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span>  <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token function">add</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//在这句打断点</span>  <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>程序运行到断点处停止，我们看debugger窗口<br><img src="https://img-blog.csdnimg.cn/bd5113f93e4b4afead467b0d2084cc8c.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhdzk2eA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>可以看得到Frames这个子窗口，这表示的就是栈帧的集合，也就是虚拟机栈，我们的程序在main方法中的add暂停，所以目前栈帧中只有一个main方法，我们运行到下一步看看<br><img src="https://img-blog.csdnimg.cn/52e00e7f2a634217ba041a3cb4d6d410.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhdzk2eA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>可以看到main栈帧的上方有了add，这符合栈后进先出的特点，可以预见，如果addd中继续调用方法，那么add栈帧之上又会有新的栈帧。</p><p>现在我们继续运行程序，让add方法运行完毕<br><img src="https://img-blog.csdnimg.cn/d94890ad9d104242b18f54d08027e2bd.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhdzk2eA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>可以看到add的栈帧消失了，也就是add方法的运行内存被释放了。<br>这个小demo可以看出栈帧扮演的角色和运行方式。</p><h2 id="3-本地方法栈"><a href="#3-本地方法栈" class="headerlink" title="3. 本地方法栈"></a>3. 本地方法栈</h2><p>Native Method Stacks</p><p>本地方法：Native Method ，不是Java编写的代码，通常是操作系统自带的方法代码。</p><p>本地方法栈为本地方法的运行提供内存空间</p><h2 id="4-堆"><a href="#4-堆" class="headerlink" title="4. 堆"></a>4. 堆</h2><h3 id="4-1定义"><a href="#4-1定义" class="headerlink" title="4.1定义"></a>4.1定义</h3><p>Heap 堆</p><ul><li>通过new关键字，创建对象都会使用堆内存</li></ul><p>特点</p><ul><li>它是线程共享的，堆中对象都需要考虑线程安全的问题</li><li>有垃圾回收机制</li></ul><h3 id="4-2-堆内存溢出"><a href="#4-2-堆内存溢出" class="headerlink" title="4.2 堆内存溢出"></a>4.2 堆内存溢出</h3><p>-Xmx 堆内存分配大小命令</p><p>OutOfMemoryError : Java heap space</p><p>垃圾回收：没人用的对象，就作为垃圾被回收</p><p>堆内存溢出：大量的对象被不断创建，同时一直被使用，可能导致堆内存溢出</p><h3 id="4-3-堆内存诊断"><a href="#4-3-堆内存诊断" class="headerlink" title="4.3 堆内存诊断"></a>4.3 堆内存诊断</h3><p>在idea控制台窗口即可运行</p><ol><li>jps工具<ul><li>查看当前系统中有哪些Java进程</li></ul></li><li>jmap工具<ul><li>查看堆内存占用情况 ，不连续，只能查看某一时刻的情况</li><li>jmap -heap 进程id</li></ul></li><li>jconsole<ul><li>图形界面，多功能检测工具，可连续监测</li></ul></li></ol><p>案例：</p><ul><li>垃圾回收后，内存占用率仍然很高</li><li>使用jvisualvm工具，通过堆dump功能查看对象在某一时刻的具体情况，从而做出诊断</li></ul><h2 id="5-方法区"><a href="#5-方法区" class="headerlink" title="5. 方法区"></a>5. 方法区</h2><h3 id="5-1-定义"><a href="#5-1-定义" class="headerlink" title="5.1 定义"></a>5.1 定义</h3><p>Method Area</p><p>方法区是所有Java虚拟机线程共享的区域，它存储了与类结构相关的信息，如成员变量，方法数据，成员方法和构造器的代码部分，运行时常量池。</p><p>方法区在虚拟机启动时就被创建，逻辑上它是堆的组成部分，但具体实现不同的jvm有所不同</p><h3 id="5-2-组成"><a href="#5-2-组成" class="headerlink" title="5.2 组成"></a>5.2 组成</h3><p>参照官方笔记</p><h3 id="5-3-方法区内存溢出"><a href="#5-3-方法区内存溢出" class="headerlink" title="5.3 方法区内存溢出"></a>5.3 方法区内存溢出</h3><p>-XX:MaxMetaspaceSize 设置元空间大小</p><p>OutOfMemoryError:Metaspace</p><ul><li>1.8以前会导致永久代内存溢出</li><li>1.8以后会导致元空间内存溢出</li></ul><h3 id="5-4-运行时常量池"><a href="#5-4-运行时常量池" class="headerlink" title="5.4 运行时常量池"></a>5.4 运行时常量池</h3><ul><li>常量池，就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息</li><li>运行时常量池，常量池是 *.class 文件中的，当该类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址</li></ul><h3 id="5-5-StringTable特性"><a href="#5-5-StringTable特性" class="headerlink" title="5.5 StringTable特性"></a>5.5 StringTable特性</h3><ul><li>常量池中的字符串仅是符号，第一次用到时才变为对象</li><li>利用串池的机制，来避免重复创建字符串对象</li><li>字符串变量拼接的原理是StringBuilder（jdk1.8）</li><li>字符串常量拼接的原理是编译期优化</li><li>可以使用intern方法，主动将串池中还没有的字符串对象放入串池<ul><li>1.8中，将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池，会把串池中的对象返回</li><li>1.6中，将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则会把此对象复制一份，再放入串池，会把串池中的对象返回</li></ul></li></ul><h3 id="5-6-StringTable位置"><a href="#5-6-StringTable位置" class="headerlink" title="5.6 StringTable位置"></a>5.6 StringTable位置</h3><ul><li>1.8，StringTable在堆（Heap）中</li><li>1.6，StringTable在永久代（PermGen）中</li></ul><h3 id="5-7-StringTable垃圾回收"><a href="#5-7-StringTable垃圾回收" class="headerlink" title="5.7 StringTable垃圾回收"></a>5.7 StringTable垃圾回收</h3><h3 id="5-8-StringTable性能调优"><a href="#5-8-StringTable性能调优" class="headerlink" title="5.8 StringTable性能调优"></a>5.8 StringTable性能调优</h3><ul><li>StringTable本质上是哈希表，因此调优就是调整桶的个数，适当的把桶的个数调大，减少哈希碰撞   -XX:StringTableSize=桶个数</li><li>考虑将字符串对象是否入池</li></ul><h2 id="6-直接内存"><a href="#6-直接内存" class="headerlink" title="6. 直接内存"></a>6. 直接内存</h2><h3 id="6-1-定义"><a href="#6-1-定义" class="headerlink" title="6.1 定义"></a>6.1 定义</h3><p>Direct Memory</p><ul><li>常见于NIO操作，用于数据缓存区</li><li>分配回收成本较高，但读写性能高</li><li>不受JVM内存回收管理</li></ul><h3 id="6-3-分配和回收原理"><a href="#6-3-分配和回收原理" class="headerlink" title="6.3 分配和回收原理"></a>6.3 分配和回收原理</h3><ul><li>使用了Unsafe对象完成直接内存的分配回收，并且回收需要主动调用的freeMemory方法</li><li>ByteBuffer的实现类内部，使用了Cleaner（虚引用）来检测ByteBuffer对象，一旦ByteBuffer对象被垃圾回收，那么就会有ReferenceHandler线程通过Cleaner的clean方法调用freeMemory来释放直接内存</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;本篇笔记不定期更新&lt;/p&gt;
&lt;h2 id=&quot;内存结构图&quot;&gt;&lt;a href=&quot;#内存结构图&quot; class=&quot;headerlink&quot; title=&quot;内存结构图&quot;&gt;&lt;/a&gt;内存结构图&lt;/h2&gt;&lt;p&gt;先上图&lt;br&gt;&lt;img src=&quot;https://img-blog.csdnimg</summary>
      
    
    
    
    <category term="技术学习" scheme="https://saw96x.github.io/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Java" scheme="https://saw96x.github.io/tags/Java/"/>
    
    <category term="JVM" scheme="https://saw96x.github.io/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer 03. 数组中重复的数字的4种解法（Java语言）</title>
    <link href="https://saw96x.github.io/post/%E5%89%91%E6%8C%87%20Offer%2003.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97%E7%9A%844%E7%A7%8D%E8%A7%A3%E6%B3%95%EF%BC%88Java%E8%AF%AD%E8%A8%80%EF%BC%89.html"/>
    <id>https://saw96x.github.io/post/%E5%89%91%E6%8C%87%20Offer%2003.%20%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97%E7%9A%844%E7%A7%8D%E8%A7%A3%E6%B3%95%EF%BC%88Java%E8%AF%AD%E8%A8%80%EF%BC%89.html</id>
    <published>2021-08-04T08:20:41.000Z</published>
    <updated>2021-08-06T13:49:19.956Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目详情"><a href="#题目详情" class="headerlink" title="题目详情"></a>题目详情</h2><p>找出数组中重复的数字。</p><p>在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。</p><p>示例 1：</p><p>输入：<br>[2, 3, 1, 0, 2, 5, 3]<br>输出：2 或 3 </p><h2 id="解法一：暴力法，双层循环"><a href="#解法一：暴力法，双层循环" class="headerlink" title="解法一：暴力法，双层循环"></a>解法一：暴力法，双层循环</h2><p>直接进行两层循环，对每个数字都逐一比较，空间复杂度O(1)，时间复杂度O(n^2)，总的来说是下下策，执行用时吓死人<br><img src="https://img-blog.csdnimg.cn/3075c099b4af457dbd8c8ffe43a3945f.PNG#pic_center" alt="在这里插入图片描述"><br>Java代码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findRepeatNumber_1</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span>          <span class="token keyword">return</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="解法二-排序后相邻的两两比较"><a href="#解法二-排序后相邻的两两比较" class="headerlink" title="解法二 排序后相邻的两两比较"></a>解法二 排序后相邻的两两比较</h2><p>很容易想到的方法，排序后两两比较，空间复杂度O(1)，时间复杂度O(nlogn)，只能说是中下策，但执行用时已经有了相当的改善<br><img src="https://img-blog.csdnimg.cn/9f01f52a148f4f3399936eedf4904588.PNG#pic_center" alt="在这里插入图片描述"><br>Java代码</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findRepeatNumber_2</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>nums<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="解法三-利用数组实现一个map映射"><a href="#解法三-利用数组实现一个map映射" class="headerlink" title="解法三 利用数组实现一个map映射"></a>解法三 利用数组实现一个map映射</h2><p>首先，判断重复，常见的办法就是利用HashMap或是HashSet来判断，但我们观察数组发现，给定的值都是0~n-1，那么我们没必要使用集合类来加重负担，直接用数组就可以完成映射，给定的数组元素为键，出现次数为值。<br>空间复杂度为O(n)，时间复杂度为O(n)，在大多数面试中已经算是可以让人接受的答案了。<br><img src="https://img-blog.csdnimg.cn/44d453122fbd47539088318a84a3b140.PNG#pic_center" alt="在这里插入图片描述"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findRepeatNumber_3</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>nums<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        map<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>      <span class="token keyword">else</span>        <span class="token keyword">return</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="解法四-利用重排后的元素碰撞"><a href="#解法四-利用重排后的元素碰撞" class="headerlink" title="解法四 利用重排后的元素碰撞"></a>解法四 利用重排后的元素碰撞</h2><p>解法三已经达到了空间时间复杂度都是O(n)的情况，实际上还能继续优化，达到O(1)的空间复杂度。<br>我们知道，数组中的元素是0~n-1，那么可以想到，如果没有重复的元素，那么排序后，每个元素都应该和它的下标相同，那么如果有重复的元素，那么两个元素就会撞到一起。<br>基于这种思路，我们设计如下算法：对每个元素都进行处理，把它交换到它应该在的位置，如果交换前发现那个位置上的元素和它相等，也就是撞车了，那么很明显这个元素就是重复的数字。<br>每个数字只要进行交换就能找到自己的位置，时间复杂度是O(n)，且没有用到额外的空间，因此空间复杂度只有O(1)</p><p><img src="https://img-blog.csdnimg.cn/5be8fe2d4adf4ba1afedb4e5c97c069e.PNG#pic_center" alt="在这里插入图片描述"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findRepeatNumber_4</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> i<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token comment">//两个数撞了</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> nums<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>          <span class="token keyword">return</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>        <span class="token comment">//把一个数交换到它应该在的位置</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> nums<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        nums<span class="token punctuation">[</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>      <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span>    <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>  <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目详情&quot;&gt;&lt;a href=&quot;#题目详情&quot; class=&quot;headerlink&quot; title=&quot;题目详情&quot;&gt;&lt;/a&gt;题目详情&lt;/h2&gt;&lt;p&gt;找出数组中重复的数字。&lt;/p&gt;
&lt;p&gt;在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些</summary>
      
    
    
    
    <category term="技术学习" scheme="https://saw96x.github.io/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="数据结构与算法" scheme="https://saw96x.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    <category term="剑指Offer" scheme="https://saw96x.github.io/tags/%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>Springboot的自动装配原理浅析</title>
    <link href="https://saw96x.github.io/post/Springboot%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90.html"/>
    <id>https://saw96x.github.io/post/Springboot%E7%9A%84%E8%87%AA%E5%8A%A8%E8%A3%85%E9%85%8D%E5%8E%9F%E7%90%86%E6%B5%85%E6%9E%90.html</id>
    <published>2021-08-04T08:16:55.000Z</published>
    <updated>2021-08-06T13:48:29.684Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学习Springboot，不少文章和视频在完成了第一个快速入门的项目之后就直接进入了Springboot运行的原理部分，因此决定写一篇文章加深理解。</p><p>原理的理解主要使用了查看源码和画流程图的方式。</p><h3 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h3><p>对于一个maven项目，我们一般首要分析其pom文件，查看相关依赖。</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependencies</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-web<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>scope</span><span class="token punctuation">></span></span>test<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>scope</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusions</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>exclusion</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.junit.vintage<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>junit-vintage-engine<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusion</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>exclusions</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependencies</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugins</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>                <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-maven-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugins</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到依赖方面都是很简单的内容，加入了测试启动器和web启动器以及springboot的build插件，但我们发现了一个不一般的地方，他们都没有版本号！这是为什么呢？<br>   我们往上查看，可以发现这样的父依赖。</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-parent<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.3.4.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>relativePath</span><span class="token punctuation">/></span></span> <span class="token comment">&lt;!-- lookup parent from repository --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>   我们点进去查看，会发现。。。还有一层父依赖！<br>   <pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>parent</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-dependencies<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>2.3.4.RELEASE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>parent</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><br>   继续点进去查看。</p><pre class="line-numbers language-xml" data-language="xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>properties</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>activemq.version</span><span class="token punctuation">></span></span>5.15.13<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>activemq.version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>antlr2.version</span><span class="token punctuation">></span></span>2.7.7<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>antlr2.version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>appengine-sdk.version</span><span class="token punctuation">></span></span>1.9.82<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>appengine-sdk.version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artemis.version</span><span class="token punctuation">></span></span>2.12.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artemis.version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>aspectj.version</span><span class="token punctuation">></span></span>1.9.6<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>aspectj.version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>assertj.version</span><span class="token punctuation">></span></span>3.16.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>assertj.version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>atomikos.version</span><span class="token punctuation">></span></span>4.0.6<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>atomikos.version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>awaitility.version</span><span class="token punctuation">></span></span>4.0.3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>awaitility.version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bitronix.version</span><span class="token punctuation">></span></span>2.1.4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bitronix.version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>build-helper-maven-plugin.version</span><span class="token punctuation">></span></span>3.1.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>build-helper-maven-plugin.version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>byte-buddy.version</span><span class="token punctuation">></span></span>1.10.14<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>byte-buddy.version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>caffeine.version</span><span class="token punctuation">></span></span>2.8.5<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>caffeine.version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>cassandra-driver.version</span><span class="token punctuation">></span></span>4.6.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>cassandra-driver.version</span><span class="token punctuation">></span></span>    ...........<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">这样的信息就是这些依赖尽头的主体了，这个文件有大量的配置信息，标注了每个可能用到的依赖的版本号，因此我们不用指定依赖的版本，springboot会根据你使用的版本自动给你安排合适的版本，再也不用担心依赖版本的冲突导致的崩溃啦！pom.xml文件我们就说到这里，接下来才是重头戏了！思维导图：![在这里插入图片描述](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;20200929160256862.png#pic_center)### 启动类的@SpringBootApplication注解启动类包括两个重要的部分，一个是@SpringBootApplication注解，另一个是其中的run方法，我们先从这个注解开始说起。首先，这个注解的作用，猜也猜得到，是标注这个应用是一个springboot应用，这样springboot就可以帮我们对其进行自动配置，我们想要了解，spring boot是如何通过注解来自动装配的，装配了什么。老办法，查看源码，我点！&#96;&#96;&#96;java@Target(&#123;ElementType.TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Inherited@SpringBootConfiguration@EnableAutoConfiguration@ComponentScan<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>以上是@SpringBootApplication注解之下的几个注解，出去那些基础的之外，我们可以看见三个特别显眼的，@SpringBootConfiguration，@ComponentScan，@EnableAutoConfiguration，我们逐个查看他们的源码。</p><h4 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h4><p>他的源码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token class-name">ElementType</span><span class="token punctuation">.</span>TYPE<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span><span class="token class-name">RetentionPolicy</span><span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Documented</span><span class="token annotation punctuation">@Configuration</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>乏善可陈。。。根据其下的@Configuration可以猜到，它是起到一个标注作用的注解，标志当前应用为一个springboot应用。</p><p>我们回到上一层查看其他注解的源码。</p><h4 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h4><p>这个更没啥好说的了，源码都没必要看了，他的作用是扫描指定包下的组件，将它们加载到Spring的IOC容器之中，很重要，但不是我们探究的重点。</p><p>我们查看最后一个注解的源码。</p><h4 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h4><p>看得出来，他的作用是启用自动配置，我们重点关注如何启用，怎么启用，启用了什么。<br>他的源码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@AutoConfigurationPackage</span><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token class-name">AutoConfigurationImportSelector</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>看起来重要的注解就这两个，第一个看翻译是自动配置包，我们点进去查看他的源码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Import</span><span class="token punctuation">(</span><span class="token punctuation">&#123;</span><span class="token class-name">Registrar</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>噢，这是一个注册器，根据相关源码猜测是将bean注册导入到容器之中（若有错误希望指正）。</p><p>我们回头，看看import导入的东西。</p><p>自动配置导入选择器，我们猜测它是导入了需要的配置文件，查看源码：<br><img src="https://img-blog.csdnimg.cn/20200929162249237.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhdzk2eA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"><br>我这里截图还没有截全。。。我们发现其中有相当多的方法，我们的目的是查看如何加载组件的，因此寻找configuration相关的方法。</p><p>找到了！getCandidateConfigurations，获取候选配置，这个方法中又使用了SpringFactoriesLoader，我们继续深入。<br><code>public static final String FACTORIES_RESOURCE_LOCATION = &quot;META-INF/spring.factories&quot;;</code><br>看到了看起来是文件的东西！我们使用全局搜索，发现它在springboot的jar包内，我们再点开来看看</p><p><img src="https://img-blog.csdnimg.cn/20200929162722643.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhdzk2eA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述">我们根据源头打开spring.factories ， 看到了很多自动配置的文件；这就是自动配置根源所在！可以随便点开看看，都可以看到这些一个个的都是JavaConfig配置类，而且都注入了一些Bean。</p><p>至此，我们大概明白了Spring boot的自动装配原理了：</p><p>自动配置真正实现是从classpath中搜寻所有的META-INF/spring.factories配置文件 ，并将其中对应的 org.springframework.boot.autoconfigure. 包下的配置项，通过反射实例化为对应标注了 @Configuration的JavaConfig形式的IOC容器配置类 ， 然后将这些都汇总成为一个实例并加载到IOC容器中。</p><p>所以其实刚刚那一大串套娃注解其实都是为了拿到spring.factories。。。我不太懂设计模式，不太懂这样做的意义是什么样的哈哈哈。</p><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><ol><li><p>SpringBoot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值</p></li><li><p>将这些值作为自动配置类导入容器 ， 自动配置类就生效 ， 帮我们进行自动配置工作；</p></li><li><p>整个J2EE的整体解决方案和自动配置都在springboot-autoconfigure的jar包中；</p></li><li><p>它会给容器中导入非常多的自动配置类 （xxxAutoConfiguration）, 就是给容器中导入这个场景需要的所有组件 ， 并配置好这些组件 ；</p></li><li><p>有了自动配置类 ， 免去了我们手动编写配置注入功能组件等的工作；</p></li></ol><p>思维导图：<br><img src="https://img-blog.csdnimg.cn/20200929164052679.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhdzk2eA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p><h3 id="run方法"><a href="#run方法" class="headerlink" title="run方法"></a>run方法</h3><p>分析该方法主要分两部分，一部分是SpringApplication的实例化，二是run方法的执行；<br>SpringApplication</p><p>这个类主要做了以下四件事情：</p><p>1、推断应用的类型是普通的项目还是Web项目</p><p>2、查找并加载所有可用初始化器 ， 设置到initializers属性中</p><p>3、找出所有的应用程序监听器，设置到listeners属性中</p><p>4、推断并设置main方法的定义类，找到运行的主类</p><p>源码分析无力了。。。给大家一张图吧，说的很清楚了，大家可以跟着这张图自己读读源码。</p><p><img src="https://img-blog.csdnimg.cn/20200929163826667.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhdzk2eA==,size_16,color_FFFFFF,t_70#pic_center" alt="在这里插入图片描述"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;最近在学习Springboot，不少文章和视频在完成了第一个快速入门的项目之后就直接进入了Springboot运行的原理部分，因此决定写一篇文章加深理解。&lt;/p&gt;
&lt;p&gt;原理的理解主要使用了查看源码和画流程图的方式。&lt;/p&gt;
&lt;h3 id=&quot;pom-xml&quot;&gt;&lt;a href</summary>
      
    
    
    
    <category term="技术学习" scheme="https://saw96x.github.io/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Java" scheme="https://saw96x.github.io/tags/Java/"/>
    
    <category term="源码分析" scheme="https://saw96x.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
    <category term="SpringBoot" scheme="https://saw96x.github.io/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>Java new ArrayList(int initialCapacity)初始化容量问题</title>
    <link href="https://saw96x.github.io/post/Java%20new%20ArrayList(int%20initialCapacity)%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AE%B9%E9%87%8F%E9%97%AE%E9%A2%98.html"/>
    <id>https://saw96x.github.io/post/Java%20new%20ArrayList(int%20initialCapacity)%E5%88%9D%E5%A7%8B%E5%8C%96%E5%AE%B9%E9%87%8F%E9%97%AE%E9%A2%98.html</id>
    <published>2021-08-04T07:35:13.000Z</published>
    <updated>2021-08-06T13:49:54.974Z</updated>
    
    <content type="html"><![CDATA[<p>今天看了ArrayList源码，发现了一个不大不小的问题：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>initialCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> EMPTY_ELEMENTDATA<span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal Capacity: "</span><span class="token operator">+</span>                                               initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">&#125;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个构造函数咋一看问题不大，给elementData底层数组分配空间嘛，初始化数组的大小了<br>但是实际使用时：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">></span></span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">;</span>a<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>抛出了IndexOutOfBoundsException</p><p>结合源码：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token class-name">E</span> element<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>        <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">checkIndex</span><span class="token punctuation">(</span>index<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">E</span> oldValue <span class="token operator">=</span> <span class="token function">elementData</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> element<span class="token punctuation">;</span>        <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>其中第一行首先检测了下标，参数是index和size，而size是元素个数，也就是说，尽管设置了数组的容量，但针对ArrayList中元素的操作，是根据元素的位置，而不是根据容量来操作。也就是说，至少得有个元素才能set它，没有元素就是set个寂寞。</p><p>因此<code>set(1,5)</code>在第一行直接抛出异常了</p><p>综上所述ArrayList(int initialCapacity) 只是<strong>让ArrayList有了容纳 initialCapacity个元素的潜力，并不能对其中的“位置”操作</strong>。</p><p>PS：这个问题在Java核心技术卷1中就有提到，但我当时直接忘了，果然看了源码才理解的透彻。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;今天看了ArrayList源码，发现了一个不大不小的问题：&lt;/p&gt;
&lt;pre class=&quot;line-numbers language-java&quot; data-language=&quot;java&quot;&gt;&lt;code class=&quot;language-java&quot;&gt;&lt;span class=&quot;t</summary>
      
    
    
    
    <category term="技术学习" scheme="https://saw96x.github.io/categories/%E6%8A%80%E6%9C%AF%E5%AD%A6%E4%B9%A0/"/>
    
    
    <category term="Java" scheme="https://saw96x.github.io/tags/Java/"/>
    
    <category term="源码分析" scheme="https://saw96x.github.io/tags/%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
</feed>
