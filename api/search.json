[{"id":"ca5547898d7e053911493b82ed0cb0fa","title":"剑指 Offer 03. 数组中重复的数字的4种解法（Java语言）","content":"题目详情找出数组中重复的数字。\n在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。\n示例 1：\n输入：[2, 3, 1, 0, 2, 5, 3]输出：2 或 3 \n解法一：暴力法，双层循环直接进行两层循环，对每个数字都逐一比较，空间复杂度O(1)，时间复杂度O(n^2)，总的来说是下下策，执行用时吓死人Java代码\npublic int findRepeatNumber_1(int[] nums) &#123;\n    for (int i = 0; i &lt; nums.length; i++)\n      for (int j = i + 1; j &lt; nums.length; j++)\n        if (nums[i] == nums[j])\n          return nums[i];\n    return -1;\n  &#125;\n解法二 排序后相邻的两两比较很容易想到的方法，排序后两两比较，空间复杂度O(1)，时间复杂度O(nlogn)，只能说是中下策，但执行用时已经有了相当的改善Java代码\npublic int findRepeatNumber_2(int[] nums) &#123;\n    Arrays.sort(nums);\n    for (int i = 0; i &lt; nums.length - 1; i++) &#123;\n      if (nums[i] == nums[i + 1])\n        return nums[i];\n    &#125;\n    return -1;\n  &#125;\n解法三 利用数组实现一个map映射首先，判断重复，常见的办法就是利用HashMap或是HashSet来判断，但我们观察数组发现，给定的值都是0~n-1，那么我们没必要使用集合类来加重负担，直接用数组就可以完成映射，给定的数组元素为键，出现次数为值。空间复杂度为O(n)，时间复杂度为O(n)，在大多数面试中已经算是可以让人接受的答案了。\npublic int findRepeatNumber_3(int[] nums) &#123;\n    int[] map = new int[nums.length];\n    for (int i = 0; i &lt; nums.length; i++) &#123;\n      if (map[nums[i]] == 0)\n        map[nums[i]]++;\n      else\n        return nums[i];\n    &#125;\n    return -1;\n  &#125;\n解法四 利用重排后的元素碰撞解法三已经达到了空间时间复杂度都是O(n)的情况，实际上还能继续优化，达到O(1)的空间复杂度。我们知道，数组中的元素是0~n-1，那么可以想到，如果没有重复的元素，那么排序后，每个元素都应该和它的下标相同，那么如果有重复的元素，那么两个元素就会撞到一起。基于这种思路，我们设计如下算法：对每个元素都进行处理，把它交换到它应该在的位置，如果交换前发现那个位置上的元素和它相等，也就是撞车了，那么很明显这个元素就是重复的数字。每个数字只要进行交换就能找到自己的位置，时间复杂度是O(n)，且没有用到额外的空间，因此空间复杂度只有O(1)\n\npublic int findRepeatNumber_4(int[] nums) &#123;\n    for (int i = 0; i &lt; nums.length; i++) &#123;\n      while (nums[i] != i) &#123;\n        //两个数撞了\n        if (nums[i] == nums[nums[i]]) &#123;\n          return nums[i];\n        &#125;\n        //把一个数交换到它应该在的位置\n        int temp = nums[nums[i]];\n        nums[nums[i]] = nums[i];\n        nums[i] = temp;\n      &#125;\n    &#125;\n    return -1;\n  &#125;\n","slug":"剑指 Offer 03. 数组中重复的数字的4种解法（Java语言）","date":"2021-08-04T08:20:41.000Z","categories_index":"","tags_index":"数据结构与算法,剑指Offer","author_index":"南望"},{"id":"809380e59300e634907b381d0433de40","title":"Springboot的自动装配原理浅析","content":"最近在学习Springboot，不少文章和视频在完成了第一个快速入门的项目之后就直接进入了Springboot运行的原理部分，因此决定写一篇文章加深理解。\n原理的理解主要使用了查看源码和画流程图的方式。\npom.xml对于一个maven项目，我们一般首要分析其pom文件，查看相关依赖。\n&lt;dependencies>\n        &lt;dependency>\n            &lt;groupId>org.springframework.boot&lt;/groupId>\n            &lt;artifactId>spring-boot-starter-web&lt;/artifactId>\n        &lt;/dependency>\n\n        &lt;dependency>\n            &lt;groupId>org.springframework.boot&lt;/groupId>\n            &lt;artifactId>spring-boot-starter-test&lt;/artifactId>\n            &lt;scope>test&lt;/scope>\n            &lt;exclusions>\n                &lt;exclusion>\n                    &lt;groupId>org.junit.vintage&lt;/groupId>\n                    &lt;artifactId>junit-vintage-engine&lt;/artifactId>\n                &lt;/exclusion>\n            &lt;/exclusions>\n        &lt;/dependency>\n    &lt;/dependencies>\n\n    &lt;build>\n        &lt;plugins>\n            &lt;plugin>\n                &lt;groupId>org.springframework.boot&lt;/groupId>\n                &lt;artifactId>spring-boot-maven-plugin&lt;/artifactId>\n            &lt;/plugin>\n        &lt;/plugins>\n    &lt;/build>\n可以看到依赖方面都是很简单的内容，加入了测试启动器和web启动器以及springboot的build插件，但我们发现了一个不一般的地方，他们都没有版本号！这是为什么呢？   我们往上查看，可以发现这样的父依赖。\n&lt;parent>\n        &lt;groupId>org.springframework.boot&lt;/groupId>\n        &lt;artifactId>spring-boot-starter-parent&lt;/artifactId>\n        &lt;version>2.3.4.RELEASE&lt;/version>\n        &lt;relativePath/> &lt;!-- lookup parent from repository -->\n    &lt;/parent>\n   我们点进去查看，会发现。。。还有一层父依赖！    &lt;parent>\n  &lt;groupId>org.springframework.boot&lt;/groupId>\n  &lt;artifactId>spring-boot-dependencies&lt;/artifactId>\n  &lt;version>2.3.4.RELEASE&lt;/version>\n&lt;/parent>   继续点进去查看。\n&lt;properties>\n    &lt;activemq.version>5.15.13&lt;/activemq.version>\n    &lt;antlr2.version>2.7.7&lt;/antlr2.version>\n    &lt;appengine-sdk.version>1.9.82&lt;/appengine-sdk.version>\n    &lt;artemis.version>2.12.0&lt;/artemis.version>\n    &lt;aspectj.version>1.9.6&lt;/aspectj.version>\n    &lt;assertj.version>3.16.1&lt;/assertj.version>\n    &lt;atomikos.version>4.0.6&lt;/atomikos.version>\n    &lt;awaitility.version>4.0.3&lt;/awaitility.version>\n    &lt;bitronix.version>2.1.4&lt;/bitronix.version>\n    &lt;build-helper-maven-plugin.version>3.1.0&lt;/build-helper-maven-plugin.version>\n    &lt;byte-buddy.version>1.10.14&lt;/byte-buddy.version>\n    &lt;caffeine.version>2.8.5&lt;/caffeine.version>\n    &lt;cassandra-driver.version>4.6.1&lt;/cassandra-driver.version>\n    ...........\n这样的信息就是这些依赖尽头的主体了，这个文件有大量的配置信息，标注了每个可能用到的依赖的版本号，因此我们不用指定依赖的版本，springboot会根据你使用的版本自动给你安排合适的版本，再也不用担心依赖版本的冲突导致的崩溃啦！\n\npom.xml文件我们就说到这里，接下来才是重头戏了！\n\n思维导图：\n\t![在这里插入图片描述](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;20200929160256862.png#pic_center)\n\n### 启动类的@SpringBootApplication注解\n启动类包括两个重要的部分，一个是@SpringBootApplication注解，另一个是其中的run方法，我们先从这个注解开始说起。\n\n首先，这个注解的作用，猜也猜得到，是标注这个应用是一个springboot应用，这样springboot就可以帮我们对其进行自动配置，我们想要了解，spring boot是如何通过注解来自动装配的，装配了什么。\n\n老办法，查看源码，我点！\n&#96;&#96;&#96;java\n@Target(&#123;ElementType.TYPE&#125;)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@SpringBootConfiguration\n@EnableAutoConfiguration\n@ComponentScan\n以上是@SpringBootApplication注解之下的几个注解，出去那些基础的之外，我们可以看见三个特别显眼的，@SpringBootConfiguration，@ComponentScan，@EnableAutoConfiguration，我们逐个查看他们的源码。\n@SpringBootConfiguration他的源码：\n@Target(&#123;ElementType.TYPE&#125;)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Configuration\n乏善可陈。。。根据其下的@Configuration可以猜到，它是起到一个标注作用的注解，标志当前应用为一个springboot应用。\n我们回到上一层查看其他注解的源码。\n@ComponentScan这个更没啥好说的了，源码都没必要看了，他的作用是扫描指定包下的组件，将它们加载到Spring的IOC容器之中，很重要，但不是我们探究的重点。\n我们查看最后一个注解的源码。\n@EnableAutoConfiguration看得出来，他的作用是启用自动配置，我们重点关注如何启用，怎么启用，启用了什么。他的源码：\n@AutoConfigurationPackage\n@Import(&#123;AutoConfigurationImportSelector.class&#125;)\n看起来重要的注解就这两个，第一个看翻译是自动配置包，我们点进去查看他的源码：\n@Import(&#123;Registrar.class&#125;)\n噢，这是一个注册器，根据相关源码猜测是将bean注册导入到容器之中（若有错误希望指正）。\n我们回头，看看import导入的东西。\n自动配置导入选择器，我们猜测它是导入了需要的配置文件，查看源码：我这里截图还没有截全。。。我们发现其中有相当多的方法，我们的目的是查看如何加载组件的，因此寻找configuration相关的方法。\n找到了！getCandidateConfigurations，获取候选配置，这个方法中又使用了SpringFactoriesLoader，我们继续深入。public static final String FACTORIES_RESOURCE_LOCATION = &quot;META-INF/spring.factories&quot;;看到了看起来是文件的东西！我们使用全局搜索，发现它在springboot的jar包内，我们再点开来看看\n我们根据源头打开spring.factories ， 看到了很多自动配置的文件；这就是自动配置根源所在！可以随便点开看看，都可以看到这些一个个的都是JavaConfig配置类，而且都注入了一些Bean。\n至此，我们大概明白了Spring boot的自动装配原理了：\n自动配置真正实现是从classpath中搜寻所有的META-INF/spring.factories配置文件 ，并将其中对应的 org.springframework.boot.autoconfigure. 包下的配置项，通过反射实例化为对应标注了 @Configuration的JavaConfig形式的IOC容器配置类 ， 然后将这些都汇总成为一个实例并加载到IOC容器中。\n所以其实刚刚那一大串套娃注解其实都是为了拿到spring.factories。。。我不太懂设计模式，不太懂这样做的意义是什么样的哈哈哈。\n结论\nSpringBoot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值\n\n将这些值作为自动配置类导入容器 ， 自动配置类就生效 ， 帮我们进行自动配置工作；\n\n整个J2EE的整体解决方案和自动配置都在springboot-autoconfigure的jar包中；\n\n它会给容器中导入非常多的自动配置类 （xxxAutoConfiguration）, 就是给容器中导入这个场景需要的所有组件 ， 并配置好这些组件 ；\n\n有了自动配置类 ， 免去了我们手动编写配置注入功能组件等的工作；\n\n\n思维导图：\nrun方法分析该方法主要分两部分，一部分是SpringApplication的实例化，二是run方法的执行；SpringApplication\n这个类主要做了以下四件事情：\n1、推断应用的类型是普通的项目还是Web项目\n2、查找并加载所有可用初始化器 ， 设置到initializers属性中\n3、找出所有的应用程序监听器，设置到listeners属性中\n4、推断并设置main方法的定义类，找到运行的主类\n源码分析无力了。。。给大家一张图吧，说的很清楚了，大家可以跟着这张图自己读读源码。\n\n","slug":"Springboot的自动装配原理浅析","date":"2021-08-04T08:16:55.000Z","categories_index":"","tags_index":"Java,源码分析,SpringBoot","author_index":"南望"},{"id":"3a69b8fada749b74d26a9663c4985507","title":"Java new ArrayList(int initialCapacity)初始化容量问题","content":"今天看了ArrayList源码，发现了一个不大不小的问题：\npublic ArrayList(int initialCapacity) &#123;\n        if (initialCapacity > 0) &#123;\n            this.elementData = new Object[initialCapacity];\n        &#125; else if (initialCapacity == 0) &#123;\n            this.elementData = EMPTY_ELEMENTDATA;\n        &#125; else &#123;\n            throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                               initialCapacity);\n        &#125;\n    &#125;\n\n这个构造函数咋一看问题不大，给elementData底层数组分配空间嘛，初始化数组的大小了但是实际使用时：\nArrayList&lt;Integer> a = new ArrayList(9);\na.set(1,5);\n抛出了IndexOutOfBoundsException\n结合源码：\npublic E set(int index, E element) &#123;\n        Objects.checkIndex(index, size);\n        E oldValue = elementData(index);\n        elementData[index] = element;\n        return oldValue;\n    &#125;\n其中第一行首先检测了下标，参数是index和size，而size是元素个数，也就是说，尽管设置了数组的容量，但针对ArrayList中元素的操作，是根据元素的位置，而不是根据容量来操作。也就是说，至少得有个元素才能set它，没有元素就是set个寂寞。\n因此set(1,5)在第一行直接抛出异常了\n综上所述ArrayList(int initialCapacity) 只是让ArrayList有了容纳 initialCapacity个元素的潜力，并不能对其中的“位置”操作。\nPS：这个问题在Java核心技术卷1中就有提到，但我当时直接忘了，果然看了源码才理解的透彻。\n","slug":"Java new ArrayList(int initialCapacity)初始化容量问题","date":"2021-08-04T07:35:13.000Z","categories_index":"技术学习","tags_index":"Java,源码分析","author_index":"南望"}]