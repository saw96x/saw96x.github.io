[{"id":"b4694def951abc4bafb5168cc2a7630a","title":"JVM垃圾回收","content":"JVM垃圾回收1. 如何判断对象可以回收1.1 简要介绍：\n引用计数法，如果某个对象被引用了，则他的计数加1，不再被引用了，则减1，计数为0则回收。弊端：循环引用，比如a和b相互引用，即使他们两个永远都不再被使用了，但是由于存在引用计数，所以永远都不会被回收。早期python虚拟机采用这种算法。\n\n可达性分析算法：首先确定根对象（肯定不能被垃圾回收的对象），进行垃圾回收前对所有对象进行一次扫描，如果被根对象直接或间接应用的对象就不能被回收，如果没有被引用，那么就可以被回收。许多主流的商用程序语言（Java，C#等等）都采用这种算法进行\n\n\n\n1.2 可达性分析算法：\nJava虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象\n\n扫描堆中的对象，看是否能够沿这GC Root对象为起点的引用链找到该对象，找不到，表示可以回收\n哪些对象可以作为GC Root对象\n\n SystemClass：由自举/系统类加载器加载的类。例如，rt.jar中所有诸如java.util.*的类。 JNILocal：原生代码中的本地变量，例如用户定义的JNI（Java本地接口，一般用来使Java代码和其他语言代码进行交互）代码或JVM内部代码。 JNIGlobal：原生代码中的全局变量，例如用户定义的JNI代码或JVM内部代码。 ThreadBlock：当前活跃的线程块中引用的对象。 Thread：启动且未停止的线程。 BusyMonitor：其wait()或notify()方法被调用，或被同步synchronized的对象。例如，通过调用synchronized(Object)或者进入其某个synchronized方法。静态方法对应类，非静态方法对应对象。 JavaLocal：本地变量。例如，仍在线程的栈中的方法输入参数或本地创建的对象。 NativeStack：（例如用户定义的JNI代码或JVM内部代码这样的）原生代码的入或出参数。通常发生在许多方法有原生部分，方法参数处理的对象成为GC根对象。例如，参数用于文件、网络I/O或反射。 Finalizer：在队列中等待其finalizer运行的对象。 Unfinalized：拥有finalize方法，但是还没有被终结且不在finalizer队列的对象。 Unreachable：从其他根对象不可达的对象，但是被内存分析器标记为根对象。 Unknown：没有根类型的对象。一些转储(dump)，例如IBM可移植对转储文件，没有根信息。对于这些转储，内存分析器解析程序将没有被其他根对象引用的对象标记为此类根对象。\n如果觉得上面的太复杂，那么简单来说，在Java语言中，可作为GC Roots的对象包括下面4种：\n\n虚拟机栈（栈帧中的本地变量表）中引用的对象。*\n方法区中类静态属性引用的对象。*\n方法区中常量引用的对象。* \n本地方法栈中JNI（即一般说的Native方法）引用的对象。\n\n1.3 四种引用\n此图中，实线表示强引用，虚线表示其余引用 \n\n强引用\n可以被GC Root对象直接或间接的找到，这种关系是强引用，一般情况下，我们书写的代码基本上形成的引用关系都是强引用，只有当所有强引用都断开时，对象才会被垃圾回收，除此之外是绝不可能将其回收的。\nObject o &#x3D; new Object();   &#x2F;&#x2F;  强引用\no &#x3D; null; &#x2F;&#x2F;断开强引用，被回收\n软引用\n在Java中，软引用本质上是一种特殊设计的类，因此软引用实际上是被手动创建出来的，使用SoftReference类创建出来\nString str &#x3D; new String(&quot;abc&quot;);                                     &#x2F;&#x2F; 强引用\nSoftReference&lt;String&gt; softRef &#x3D; new SoftReference&lt;String&gt;(str);     &#x2F;&#x2F; str被软引用\n\n 如果一个对象只具有软引用（通过SoftReference建立），则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些软引用对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。\n最具代表性的应用，如浏览器的后退按钮，点击后退要返回到上一个页面，如果重新加载，可能耗时较长，如果将其存储到内存中，则会造成浪费，这时可以使用软引用进行缓存，如果缓存资源充足，那么就将页面保存到缓存中，如果紧张，由于软引用的特性，页面缓存会被垃圾回收器回收。\n可以配合引用队列使用，如果软引用它引用的对象被回收时，软引用本身（SoftReference实例）会被放到引用队列中，可以对其方便的进行进一步处理，比如释放SoftReference实例占用的内存。\n\n弱引用\n和软引用相似，弱引用对象也要手动创建出来，使用WeakReference建立\nString str &#x3D; new String(&quot;abc&quot;);                                     &#x2F;&#x2F;强引用\nWeakReference&lt;String&gt; abcWeakRef &#x3D; new WeakReference&lt;String&gt;(str);  &#x2F;&#x2F;str被弱引用\n\n和软引用不同的是，无论空间是否充足，只要垃圾回收器运行了，那么检测到弱引用，就会即刻将其回收。但是垃圾回收器的线程优先级很低，不太经常运行，所以不会发生马上就会被清理掉的情况。如果这个对象是偶尔的使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么你应该用 WeakReference 来记住此对象。  \n可以配合引用队列使用，如果软引用它引用的对象被回收时，软引用本身（WeakReference实例）会被放到引用队列中，可以对其方便的进行进一步处理，比如释放WeakReference实例占用的内存。\n\n虚引用\n“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。\nString str &#x3D; new String(&quot;abc&quot;);                                     &#x2F;&#x2F;强引用\nPhantomReference&lt;String&gt; ref &#x3D; new PhantomReference&lt;String&gt;(str);  &#x2F;&#x2F;str被虚引用\n\n 虚引用主要用来跟踪对象被垃圾回收器回收的活动，同时，和软引用以及弱引用不同的是，虚引用必须要和引用队列一起使用，下面用一个例子来说明其作用和特征。\n用Java中使用ByteBuffer分配直接内存的例子来说明一下，一个名叫Cleaner的虚引用关联了ByteBuffer实例对象，而我们借助ByteBuffer实例对象分配一些直接内存，当对ByteBuffer实例对象的强引用被断开后，ByteBuffer被回收了，但是其获取的直接内存不能被JVM垃圾回收器释放（因为它是底层的内存），这时候就要通过Cleaner这个虚引用，它进入引用队列，进行后续处理，通过这个虚引用获取到那块直接内存，然后将其释放。\n\n\n1.4 回收前的筛选判断即使在可达性分析算法中不可达的对象，也并非一定会被垃圾回收，要真正回收一个对象，至少要经历两次标记过程：\n\n如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize（）方法。当对象没有覆盖finalize（）方法，或者finalize（）方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。\n如果这个对象被判定为有必要执行finalize（）方法，那么这个对象将会放置在一个叫做F-Queue的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。但此线程不保证一定会等待finalize()方法运行结束，这是为了防止发生死循环时其他队列中的对象无法执行finalize()。finalize（）方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize（）中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，如果对象没能在finalize()中建立关联，那么它就会真的被回收了。\n\n2. 垃圾回收算法2.1 标记-清除算法这种算法是最基础的手机算法，言简意赅，算法分为“标记”和“清除”（Mark-Sweep）两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。\n在JVM中，标记过程就是上文说的回收前的筛选判断（两次标记）。这种算法相当简单，但是仍然不经常使用它，它的主要不足有两个：一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。\n2.2 复制算法为了解决效率问题，一种称为“复制”（Copying）的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。\n这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为了原来的一半，未免太高了一点。\n2.3 标记-整理算法还有一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。\n在JVM中，主要使用的复制算法和标记-整理算法，他们分别针对不同生命周期的对象。\n3. 分代垃圾回收当前商业虚拟机的垃圾回收都采用分代收集的思想，它建立在两个分代假说之上：\n\n弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。\n强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。\n\n基于这两种假说，分代收集策略把Java堆划分出不同的区域，根据年龄（熬过垃圾回收的次数）将其分为新生代和老年代。\n新生代的区域存储刚被创建出来的对象，一般有研究表明，新生代中的对象98%是“朝生夕死”的，而在经历了n次垃圾回收后仍然存活的对象，则会被放到老年代，一般老年代中的对象生命周期都较长。\n虚拟机对不同的区域采用不同的垃圾回收算法，由于新生代大多数对象生命周期极短，因此采用改良后的复制算法来回收。\n不是按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。\nHotSpot虚拟机默认Eden和Survivor的大小比例是8:1，因此每次只会浪费10%的空间。但是我们不能断定，某次新生代的垃圾回收之后，10%的内存一定装得下存活的实例对象，因此当Survivor对象不够用时，需要依赖其他内存进行分配担保。\n如果另外一块Survivor空间没有足够空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代。\n对于老年代，虚拟机采用的垃圾回收算法是标记-整理算法，一方面老年代对象不多，使用这种算法效率略低可以接受，另一方面也可以清理出整块的内存，方便后续的内存分配。\n但是，分代收集并非只是简单划分内存区域那么容易，它至少存在一个明显的困难：对象之间会存在跨代引用。\n假如要现在进行一次只局限于新生代区域内的收集（Minor GC），但新生代中的对象是完全有可能被老年代所引用的，为了找出该区域中的存活对象，不得不在固定的GC Roots之外，再额外遍历整个老年代中所有对象来确保可达性分析结果的正确性，反过来也是一样。\n这种方案虽然理论上可行，但是会带来很大的性能负担，为了解决这个问题，第三条假说诞生了：跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数。\n依据这条假说，只需在新生代上建立一个全局的数据结构（该结构被称为“记忆集”，Remembered Set），这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描。虽然这种方法需要在对象改变引用关系（如将自己或者某个属性赋值）时维护记录数据的正确性，会增加一些运行时的开销，但比起收集时扫描整个老年代来说仍然是划算的。\n4. 垃圾收集器\n如图，这是HotSpot虚拟机包含的所有收集器，如果两个收集器存在连线，就说明它们可以搭配使用，虚拟机所处的区域，则表示它是属于新生代收集器还是老年代收集器。\n4.1 Serial收集器它是最基本，发展历史最悠久的收集器，它是单线程收集器，在进行垃圾收集时丙戌暂停其他所有线程，直到它收集结束。\n看起来它效率很低，但实际上，它依然是虚拟机运行在Client（客户端）模式下的默认新生代收集器。\n它有着自己的优点：简单高效、没有线程交互开销，对于内存没有非常大的新生代已经足够使用了。\n4.2 ParNew收集器它是Serial收集器的多线程版本，除此之外它就没什么创新之处了，但它却是不少运行在Server模式下的虚拟机中的新生代收集器（主要是JDK7之前，它甚至是Server模式下新生代的首选），其中有一个与性能无关但很重要的原因是，除了Serial收集器外，目前只有它能与CMS收集器（划时代意义的垃圾收集器）配合工作。\n但随着垃圾收集器技术的不断改进，更先进的G1收集器带着CMS继承者和替代者的光环登场。G1是一个面向全堆的收集器，不需要其他新生代收集器的配合工作，所以自JDK 9开始，ParNew加CMS收集器的组合就不再是官方推荐的服务端模式下的收集器解决方案了。官方希望它能完全被G1所取代。读者也可以理解为从此以后，ParNew合并入CMS，成为它专门处理新生代的组成部分。ParNew可以说是HotSpot虚拟机中第一款退出历史舞台的垃圾收集器。\n4.3 Parallel Scavenge收集器Parallel Scavenge收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器，它的特点是，此收集器的目标是达到一个可控制的吞吐量（CPU用于运行用户代码的时间与CPU总消耗时间的比值），因此它也常被称为“吞吐量优先”收集器。高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。\nParallel Scavenge收集器还有一个特点，它有一个参数-XX：+UseAdaptiveSizePolicy值得关注。这是一个开关参数，当这个参数打开之后，就不需要指定一些列细节参数，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种调节方式称为GC自适应的调节策略。\n4.4 Serial Old收集器它是Serial收集器的老年代版本，同样是单线程收集器，使用“标记-整理”算法，这个收集器的主要意义也是在于给Client模式下的虚拟机使用，如果在Server模式下，那么它主要还有两大用途：一种用途是在JDK 1.5以及之前的版本中与Parallel Scavenge收集器搭配使用，另一种用途就是作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure（后文介绍）时使用。\n4.5 Paraller Old收集器它是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。\n在它出现之前，Parallel Scavenge收集器一直处于比较尴尬的地位。Parallel Scavenge收集器只能和Serial Old收集器配合使用，但是由于Serial Old收集器在服务端应用性能上的拖累，使用了Parallel Scavenge收集器也未必能在整体应用上获得吞吐量最大化的效果，在老年代很大而且硬件比较高级的环境中，这种组合的吞吐量甚至还不一定又ParNew+CMS的组合给力。\n直到Parallel Old收集器出现后，“吞吐量优先”收集器终于有了比较名副其实的应用组合，在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。\n4.6 CMS收集器CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。相当一部分Java应用集中在互联网应用的服务端上，这类应用尤其注重服务的响应速度，CMS收集器就很符合这类应用的需求。\n从名字（包含“Mark Sweep”）上就可以看出，CMS收集器是基于“标记—清除”算法实现的，它的运作过程相对于前面几种收集器来说更复杂一些，整个过程分为4个步骤，包括：\n\n初始标记（CMS initial mark）\n并发标记（CMS concurrent mark）\n重新标记（CMS remark）\n并发清除（CMS concurrent sweep）\n\n其中，第一步和第三步仍然需要停止所有线程（Stop The World）。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC RootsTracing的过程，而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。\n而耗时最长的并发标记和并非清楚过程收集器线程都可以与用户线程一起工作，所有，从总体来说，CMS收集器的执行是与用户线程一起并发执行的，可以达到低停顿时间。\n虽然它相当优秀，但是它还远远达不到完美的程度，它又以下3个明显的缺点：\n\nCMS收集器对CPU资源非常敏感。当CPU不足4个时，CMS对用户程序的影响可能变得很大，甚至可能导致执行速度降低了50%。为了应付这种情况，虚拟机提供了一种称为“增量式并发收集器”（Incremental Concurrent Mark Sweep/i-CMS）的CMS收集器变种。就是在并发标记、清理的时候让GC线程、用户线程交替运行，尽量减少GC线程的独占资源的时间，这样整个垃圾收集的过程会更长，但对用户程序的影响就会显得少一些，也就是速度下降没有那么明显。实际上，他的效果很一般，当前版本不再提倡用户使用。\nCMS收集器无法处理浮动垃圾（Floating Garbage），可能现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。由于在并发清理解答，用户线程仍在运行，就会产生新垃圾，这些垃圾必须得下一次GC再清理，这种垃圾就被称为“浮动垃圾”。CMS收集器需要预留一部分空间提供并发时其他线程使用，要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败，这时虚拟机将启动后备预案：临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。\n由于采用了“标记-清除“算法，收集结束时会有大量空间碎片产生。，CMS收集器提供了一个-XX：+UseCMSCompactAtFullCollection开关参数（默认就是开启的），用于在CMS收集器顶不住要进行FullGC时开启内存碎片的合并整理过程，内存整理的过程是无法并发的，空间碎片问题没有了，但停顿时间不得不变长。\n\n4.7 G1收集器G1（Garbage-First）收集器是当今收集器技术发展的最前沿成果之一，G1是一款面向服务端应用的垃圾收集器。HotSpot开发团队赋予它的使命是（在比较长期的）未来可以替换掉JDK 1.5中发布的CMS收集器。和其他收集器相比，它具备如下特点：\n\n并行与并发\n分代收集\n空间整合，整体上来看是基于标记-整理算法实现，局部看是基于复制算法实现\n可预测的停顿\n\n使用G1收集器时，Java堆的内存布局就与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。\nG1收集器的实现较为复杂，有空专门写一篇笔记来介绍G1收集器。\n除了这7种收集器之外，还有其他更先进，更复杂的收集器，如ZGC，Shenandoah收集器等，本文并未描述（因为真的很复杂）。\n4.8 如何选择垃圾收集器这个问题的答案主要受三个方向影响：\n\n应用程序的主要关注点是什么？\n运行应用的基础设施如何？\n使用JDK的发行商是什么？\n\n5. 内存分配与回收策略5.1 两种回收新生代GC（Minor GC）：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。\n老年代GC（Major GC/Full GC）：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。Major GC的速度一般会比Minor GC慢10倍以上。\n5.2 对象优先在Eden区分配大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。\n虚拟机提供了-XX：+PrintGCDetails这个收集器日志参数，告诉虚拟机在发生垃圾收集行为时打印内存回收日志，并且在进程退出的时候输出当前的内存各区域分配情况。\n5.3 大对象直接进入老年代所谓的大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组。\n大对象对虚拟机的内存分配来说就是一个坏消息（替Java虚拟机抱怨一句，比遇到一个大对象更加坏的消息就是遇到一群“朝生夕灭”的“短命大对象”，写程序的时候应当避免）\n经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。\n虚拟机提供了一个**-XX：PretenureSizeThreshold**参数，令大于这个设置值的对象直接在老年代分配。目的是为了防止Eden和两个survivor区之间发生大量内存复制。\n5.4 长期存活的对象将进入老年代虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。\n对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就将会被晋升到老年代中。\n对象晋升老年代的年龄阈值，可以通过参数**-XX：MaxTenuringThreshold**设置\n5.5 动态对象年龄判定为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代。\n如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。\n5.6 空间分配担保前面提到过，新生代使用复制收集算法，但为了内存利用率，只使用其中一个Survivor空间来作为轮换备份，因此当出现大量对在MinorGC后仍然存活的情况（最极端的情况就是内存回收后新生代中所有对象都存活），就需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代。\n在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。\n如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。\n","slug":"JVM垃圾回收","date":"2021-08-15T08:16:37.000Z","categories_index":"学习笔记","tags_index":"Java,JVM,深入理解Java虚拟机,源码分析","author_index":"南望"},{"id":"c26847ef99f42b8a854d63bbf2df96ed","title":"HotSpot虚拟机对象探秘","content":"HotSpot虚拟机对象探秘1. 对象的创建1.1 类加载检查虚拟机遇到new之后，首先会去常量池中找这个类的符号引用，并检查这个符号引用代表的类是否已经被加载、解析和初始化过，如果找到了，就可以根据已有的信息划分空间、分配内存、初始化等等；如果没找到，那必须先执行相应的类加载过程，类加载过程以后的笔记在详细说明。\n1.2 内存分配类加载检查通过之后，虚拟机将为新生对象分配内存，所需内存大小在类加载完成后就已经完全确定了，虚拟机要做的只是把一块确定大小的内存从Java堆中划分出来，怎么划分又要分两种情况看了。\n\n假设Java堆中内存时绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，那中间再放一个指针作为分界点指示器，那分配内存只要移动指针就完事了，这种分配方式被称为指针碰撞。\n假设内存并不是规整的，使用的内存和空闲的内存相互交错，这时候虚拟机得维护一个列表，记录那些内存块是空闲的，分配时就从列表里找到一个够大的空间分配给实例，并更新列表，这种分配方式被称为空闲列表。\n\n选择哪种方式由Java堆是否规整来决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。\n除了如何划分可用空间外，还有另外需要考虑的问题线程安全问题，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。解决这个问题有两种方案，一种是对分配内存空间的动作进行同步处理，另一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer,TLAB）\n1.3 初始化内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值，如果使用了TLAB，这一工作过程也可以提前至TLAB分配时进行，这一步保证了对象实例字段在Java代码中不初始化就可以直接使用，这也是Java默认初始值的原理。\n1.4 进行必要的设置虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头（Object Header）之中。根据虚拟机当前的运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。\n1.5 方法的执行虚拟机的眼中，新对象已经诞生，但是从Java程序的角度，还差最后一步，执行new指令之后会接着执行＜init＞方法，把对象按照程序员的意愿进行初始化，这样一个真正程序可用的对象才算完全产生出来。\n2. 对象的内存布局在HotSpot中，对象在堆中的存储布局可以分为三个部分：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。\n2.1 对象头对象头部分包括两类信息，第一类是用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。\n这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32个比特和64个比特，官方称其为“Mark Word”，考虑到空间效率，它为设计为一个有着动态定义的数据结构，以便在极小的空间内存储尽量多的数据，根据对象的状态复用自己的存储空间。例如在32位的HotSpot虚拟机中，如对象未被同步锁锁定的状态下，Mark Word的32个比特存储空间中的25个比特用于存储对象哈希码，4个比特用于存储对象分代年龄，2个比特用于存储锁标志位，1个比特固定为0。\n第二类信息是类型指针，即对象指向它的类型元数据的指针，JVM通过它来确定该对象是哪个类的实例，但并非所有JVM实现都必须保存类型指针。如果对象是一个数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是如果数组的长度是不确定的，将无法通过元数据中的信息推断出数组的大小。\n2.2 实例数据这部分是对象真正存储的有效信息，即我们定义的各种类型的字段，父类继承的和子类定义的字段都会被记录起来。\n这部分的存储顺序会受到虚拟机分配策略参数（-XX：FieldsAllocationStyle参数）和字段在Java源码中定义顺序的影响。HotSpot虚拟机默认的分配顺序为longs/doubles、ints、shorts/chars、bytes/booleans、oops（OrdinaryObject Pointers，OOPs）。\n从默认的分配策略可以看出，相同宽度的字段总放在一起存放，在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。如果HotSpot虚拟机的+XX：CompactFields参数值为true（默认就为true），那子类之中较窄的变量也允许插入父类变量的空隙之中，以节省出一点点空间。\n2.3 对齐填充第三部分是对齐填充，这并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，因此，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。\n3. 对象的访问定位在Java中，我们要使用一个对象，会通过栈上的reference（引用）来操作堆中的具体实例对象，在JVM规范中并没有定义引用应该通过什么方式实现，因此对象的访问方式也是因机而异，主流的方式有两种：使用句柄，直接指针。\n3.1 使用句柄访问如果使用句柄访问的话，Java堆中将可能会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息。其结构如图所示\n\n使用句柄访问的最大好处是reference中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。\n3.2 使用直接指针访问·如果使用直接指针访问的话，Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销，如图所示\n\n使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销，由于对象访问在Java中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本，就本书讨论的主要虚拟机HotSpot而言，它主要使用第二种方式进行对象访问。\n","slug":"HotSpot虚拟机对象探秘","date":"2021-08-14T01:49:37.000Z","categories_index":"学习笔记","tags_index":"Java,JVM,深入理解Java虚拟机","author_index":"南望"},{"id":"f0feb27731f09def8e6fa03e806c3c89","title":"JVM内存结构","content":"本篇笔记不定期更新\n内存结构图先上图这张图差不多就把JVM的内存结构以及和class源文件，JVM执行引擎，以及操作系统自带的本地方法接口之间的关系囊括进去了。\n下面我们就JVM内存结构的几个组成部分来逐一简单介绍一下\n1. 程序计数器1.1 定义Program Counter Register 程序计数器（寄存器）\n1.2 作用\n在执行当前指令时，记住下一条JVM指令的执行地址，所以PCR也被称为寄存器，在物理上通过CPU寄存器实现\n在多线程程序中起到一个记录上下文的作用，方便切换线程时可以继续运行\n字节码解释器通过改变PCR的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要PCR来完成\n如果线程正在执行Java方法，那么PCR记录的市正在执行的虚拟机字节码指令的地址，如果正在执行的是Native方法，这个计数器值则为空（Undefined）\n\n1.3 特点\nJava支持多线程，而PCR是线程私有的，每个线程都有自己的PCR\n不会存在内存溢出此内存区域，是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域\n生命周期与线程相同\n\n2. 虚拟机栈栈–线程运行需要的内存空间，由栈帧组成，栈帧看为栈内的元素\n栈帧–每个方法运行时所需要的内存，参数，局部变量，返回地址等等····\n当调用某个方法时，会给栈帧分配内存，并将这个栈帧压入栈中，运行完毕后，会释放内存，也就是弹出栈帧。\n当方法调用方法时，就会压入多个栈帧\n2.1 定义Java Virtual Machine Stacks\n\n每个线程运行时需要的内存，称为虚拟机栈\n每个栈由多个栈帧（Frame）祖传，对应着每次方法调用时所占用的内存，一般来说是局部变量\n每个线程只能由一个活动栈帧，对应着当前正在执行的那个方法，也就是目前栈顶的那个栈帧\n线程私有的，生命周期与线程相同\n栈中有局部变量表，存放了编译期可知的各种基本数据类型、对象引用（reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。\n\n问题辨析\n\n垃圾回收是否涉及栈内存？不涉及，栈内存只和方法有关，方法运行完毕后栈帧出栈，内存自动回收。\n\n栈内存分配越大越好吗？不是，内存分配得越大，线程就越少，因为物理内存是确定的，内存分配的越大，能更多次的进行方法递归。一般来说，默认的分配内存已经够用了。\n\n方法内的局部变量是否线程安全？\n是的，因为每个线程只对应一个虚拟机栈，和其他方法的线程是互不干扰的，本质上操作的局部变量完全没有关系，因此是线程安全的。但如果不是局部变量，而是静态变量，或者是方法参数、或者是局部变量作为返回值返回了，那么就线程不安全，因为这时不同线程操纵的变量是同一个变量了。\n简单来说，如果方法内局部变量没有逃离方法的作用范围，那么他就是线程安全的\n\n\n2.2 栈内存溢出   -Xss 栈内存分配大小命令\n   StackOverflowError\n\n栈帧过多导致栈内存溢出，如递归调用但没设置中止条件，或是出现了循环引用问题\n栈帧过大导致栈内存溢出\n\n2.3 实际演示在idea中，通过断点调试，我们可以观测到栈帧的存在运行如下代码\npublic class StackTest &#123;\n  public static int add(int a, int b) &#123;\n    return a + b;\n  &#125;\n\n  public static void main(String[] args) &#123;\n    add(1, 2);  &#x2F;&#x2F;在这句打断点\n  &#125;\n&#125;\n程序运行到断点处停止，我们看debugger窗口可以看得到Frames这个子窗口，这表示的就是栈帧的集合，也就是虚拟机栈，我们的程序在main方法中的add暂停，所以目前栈帧中只有一个main方法，我们运行到下一步看看可以看到main栈帧的上方有了add，这符合栈后进先出的特点，可以预见，如果addd中继续调用方法，那么add栈帧之上又会有新的栈帧。\n现在我们继续运行程序，让add方法运行完毕可以看到add的栈帧消失了，也就是add方法的运行内存被释放了。这个小demo可以看出栈帧扮演的角色和运行方式。\n3. 本地方法栈Native Method Stacks\n\n发挥的作用和虚拟机栈发挥的作用相似，区别只是本地方法栈执行本地方法，虚拟机栈执行Java方法\n\n本地方法：Native Method ，不是Java编写的代码，通常是操作系统自带的方法代码。\n\n本地方法栈为本地方法的运行提供内存空间\n\n在规范中对本地方法栈的实现方式（语言、数据结构）没有强制规定，具体的虚拟机可以自由的实现它，有的虚拟机（Sun HotSpot）甚至将本地方法栈和虚拟机栈合二为一\n\n\n4. 堆4.1定义Heap 堆\n\n通过new关键字，创建对象都会使用堆内存\n唯一目的就是存放对象实例，这一点在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配，但随着优化技术的产生，将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了\n可以细分为新生代和老年代，再细一点的有Eden空间、From Survivor空间、To Survivor空间等\n根据规范规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，实现时可以实现成固定大小或可扩展的，目前主流虚拟机都是可扩展的\n\n特点\n\n它是线程共享的，堆中对象都需要考虑线程安全的问题\n有垃圾回收机制\n对多数应用而言，堆是Java虚拟机所管理的内存中最大的一块\n在虚拟机启动时创建\n\n4.2 堆内存溢出-Xmx 堆内存分配大小命令\nOutOfMemoryError : Java heap space\n垃圾回收：没人用的对象，就作为垃圾被回收\n堆内存溢出：大量的对象被不断创建，同时一直被使用，可能导致堆内存溢出\n4.3 堆内存诊断在idea控制台窗口即可运行\n\njps工具\n查看当前系统中有哪些Java进程\n\n\njmap工具\n查看堆内存占用情况 ，不连续，只能查看某一时刻的情况\njmap -heap 进程id\n\n\njconsole\n图形界面，多功能检测工具，可连续监测\n\n\n\n案例：\n\n垃圾回收后，内存占用率仍然很高\n使用jvisualvm工具，通过堆dump功能查看对象在某一时刻的具体情况，从而做出诊断\n\n5. 方法区5.1 定义Method Area\n方法区是所有Java虚拟机线程共享的区域，它存储了与类结构相关的信息，如成员变量，方法数据，成员方法和构造器的代码部分，运行时常量池。\n方法区在虚拟机启动时就被创建，逻辑上它是堆的组成部分，但具体实现不同的jvm有所不同\n5.2 组成待补充\n5.3 方法区内存溢出-XX:MaxMetaspaceSize 设置元空间大小\nOutOfMemoryError:Metaspace\n\n1.8以前会导致永久代内存溢出\n1.8以后会导致元空间内存溢出\n\n5.4 运行时常量池\n常量池，就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息\n运行时常量池，常量池是 *.class 文件中的，当该类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址\n\n5.5 StringTable特性\n常量池中的字符串仅是符号，第一次用到时才变为对象\n利用串池的机制，来避免重复创建字符串对象\n字符串变量拼接的原理是StringBuilder（jdk1.8）\n字符串常量拼接的原理是编译期优化\n可以使用intern方法，主动将串池中还没有的字符串对象放入串池\n1.8中，将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池，会把串池中的对象返回\n1.6中，将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则会把此对象复制一份，再放入串池，会把串池中的对象返回\n\n\n\n5.6 StringTable位置\n1.8，StringTable在堆（Heap）中\n1.6，StringTable在永久代（PermGen）中\n\n5.7 StringTable垃圾回收5.8 StringTable性能调优\nStringTable本质上是哈希表，因此调优就是调整桶的个数，适当的把桶的个数调大，减少哈希碰撞   -XX:StringTableSize=桶个数\n考虑将字符串对象是否入池\n既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当量池无法再申请到内存时会抛出OutOfMemoryError异常。\n\n6. 直接内存6.1 定义Direct Memory\n\n常见于NIO（一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作）操作，用于数据缓存区\n分配回收成本较高，但读写性能高，因为避免了在Java堆和Native堆中来回复制数据\n不受JVM内存回收管理\n\n6.2 分配和回收原理\n使用了Unsafe对象完成直接内存的分配回收，并且回收需要主动调用的freeMemory方法\nByteBuffer的实现类内部，使用了Cleaner（虚引用）来检测ByteBuffer对象，一旦ByteBuffer对象被垃圾回收，那么就会有ReferenceHandler线程通过Cleaner的clean方法调用freeMemory来释放直接内存\n\n","slug":"JVM内存结构","date":"2021-08-12T02:01:18.000Z","categories_index":"学习笔记","tags_index":"Java,JVM,深入理解Java虚拟机","author_index":"南望"},{"id":"581c1d5b4dc9ad92f487897aa0f3fdd0","title":"JVM中的类文件结构","content":"JVM中的类文件结构Class文件是一组以8个字节为基础单位的二进制流，各个数据项目中严格按照顺序紧凑排列在一起，中间没有任何分隔符，当遇到了占位8个自己以上空间的数据项时，则会按照高位在前的方式分割成8个字节进行存储。\n1. Class文件格式Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：“无符号数”和“表”。后面的解析都要以这种数据类型为基础。\n\n无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。\n表是由多个无符号数或者其他表作为数据项构成的复合数据类型，为了便于区分，所有表的命名都习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上也可以视作是一张表。\n\n2. Class文件结构2.1 魔数与Class文件的版本每个Class文件的头4个字节被称为魔数（Magic Number），它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。很多文件格式都采用这种方式进行格式验证。\n使用魔数当然是基于安全考量，扩展名可以随意改动嘛。Class文件的魔数取得很有“浪漫气息”，值为0xCAFEBABE（咖啡宝贝？）\n紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6个字节是次版本号（Minor Version），第7和第8个字节是主版本号（Major Version），版本号主要用来判断当前的虚拟机能否运行此class文件，高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件（即使文件格式并未发生变化），这是规范中明确定义的。\n2.2 常量池在版本号之后的是常量池入口，常量池可以比喻为Class文件里的资源仓库，它是Class文件结构中与其他项目关联最多的数据，通常也是占用Class文件空间最大的数据项目之一，另外，它还是在Class文件中第一个出现的表类型数据项目。\n常量池的入口有一项u2类型的数据，表示常量池容量计数值（constant_pool_count），和编程语言习惯不同的是，这个计数是从1开始的而非0，这样做的目的在于，如果后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义，可以把索引值设置为0来表示。只有常量池是例外，其他的结构的容量计数都从0开始。\n","slug":"JVM中的类文件结构","date":"2021-08-15T08:25:04.000Z","categories_index":"学习笔记","tags_index":"Java,JVM,深入理解Java虚拟机","author_index":"南望"},{"id":"199a087d49b9cdfd27d9b5eda9606895","title":"带图形界面的贪吃蛇","content":"比较早的代码了，属于典型的为了面向对象而面向对象的代码。。。运行环境VS2019，图形由easyx库实现：https://easyx.cn/。\n已经在注释中写出了出现的eaysx库函数的基本作用，注释前带“*”的是easyx的库函数，详情请查阅文档https://docs.easyx.cn/zh-cn/intro\n完整的源码见最下方\n\n成品\n基本游戏框架搭建main函数：\n#include &quot;Snake.h&quot;\nusing namespace std;\nint main()\n&#123;\n\tSnake my_snake;\n\tmy_snake.startup();\n\twhile (1)\n\t&#123;\n\t\tmy_snake.clean();\n\t\tmy_snake.UpdateWithoutInput();\n\t\tmy_snake.UpdateWithInput();\n\t\tmy_snake.show();\n\t&#125;\n\tmy_snake.gameover();\n\treturn 0;\n&#125;\n第一行通过无参的构造函数初始化数据，包括界面宽度等等startup开始生成画面进入循环，包括：\n\n清除旧画面\n更新无需用户输入的数据\n更新需要用户输入的数据\n根据更新后的数据生成新画面，从而达到动画效果\n\n（退出游戏的部分在UpdateWithoutInput中。）\nSnake类#pragma once\n#include&lt;graphics.h&gt;\n#include&lt;Windows.h&gt;\n#include&lt;conio.h&gt;\n#include&lt;ctime&gt;\n#include&lt;vector&gt;\n#include&lt;cstdlib&gt;\nusing namespace std;\nclass Snake\n&#123;\npublic:\n\tSnake();\n\tbool check();&#x2F;&#x2F;检测生成的食物是否和蛇重合了\n\tvoid SnakeMove();\n\tvoid startup();\n\tvoid clean();\n\tvoid show();\n\tvoid UpdateWithoutInput();\n\tvoid UpdateWithInput();\n\tvoid gameover();\nprivate:\n\tint High;\n\tint Width;\n\tint Background;\n\tint dir;&#x2F;&#x2F;方向\n\tint score;\n\tint speed;&#x2F;&#x2F;画面更新速度，动态难度\n\tint food_x, food_y;\n\tvector&lt;int&gt; snake_x, snake_y; &#x2F;&#x2F;蛇的每一节的坐标\n&#125;;\n\n食物只出现一次，所以直接用int类型作为坐标蛇的长度理论上来说是可以无限增长的，因此使用vector来保存蛇的每一节的坐标。\n初始化初始化的函数包括Snake的无参构造函数和startup函数：\nSnake::Snake() \n&#123;\n\tHigh &#x3D; 720;\n\tWidth &#x3D; 1280;\n\tBackground &#x3D; LIGHTGRAY;&#x2F;&#x2F;*easyx的颜色宏\n\tdir &#x3D; 5;&#x2F;&#x2F;方向参考1235键位，类似wasd\n\tscore &#x3D; 0;\n\tspeed &#x3D; 300;\n\tfood_x &#x3D; rand() % (Width-40) + 21; &#x2F;&#x2F;限定食物出现在屏幕范围内\n\tfood_y &#x3D; rand() % (High-40) + 21;\n\tsnake_x.resize(4), snake_y.resize(4);&#x2F;&#x2F;蛇的初始长度为4\n&#125;\nvoid Snake::startup() \n&#123;\n\tsrand((unsigned int)(time)(NULL));\n\tinitgraph(Width, High);&#x2F;&#x2F;*easyx初始化函数，以参数生成相应分辨率的窗口\n\tsetbkcolor(Background);&#x2F;&#x2F;*设置背景色\n\tcleardevice();&#x2F;&#x2F;*清空原有背景\n\t\n\tfor (int i &#x3D; 0; i &lt; 4; i++)&#x2F;&#x2F;初始化蛇的坐标数据\n\t&#123;\n\t\tsnake_x[i] &#x3D; Width &#x2F; 2 - 40 * i;\n\t\tsnake_y[i] &#x3D; High &#x2F; 2;\n\t&#125;\n\t\n\tBeginBatchDraw();&#x2F;&#x2F;*\n\t&#x2F;&#x2F;这个函数用于开始批量绘图。\n\t&#x2F;&#x2F;执行后，任何绘图操作都将暂时不输出到绘图窗口上，\n\t&#x2F;&#x2F;直到执行 FlushBatchDraw 或 EndBatchDraw 才将之前的绘图输出。\n\t&#x2F;&#x2F;主要的用处是保证刷新画面不发生屏幕闪烁\n&#125;\n\n动画效果void Snake::clean() \n&#123;\n\tsetlinecolor(Background);&#x2F;&#x2F;*设置线的颜色\n\tsetfillcolor(Background);&#x2F;&#x2F;*设置填充色\n\tfor (unsigned i &#x3D; 0; i &lt; snake_x.size(); i++)\n\t&#123;\n\t\tfillcircle(snake_x[i], snake_y[i], 20);&#x2F;&#x2F;*画圆\n\t&#125;\n&#125;\n\nvoid Snake::show() \n&#123;\n\tfor (unsigned i &#x3D; 0; i &lt; snake_x.size(); i++) \n\t&#123;\n\t\tif (i &#x3D;&#x3D; 0) \n\t\t&#123;\n\t\t\tsetfillcolor(LIGHTMAGENTA);\n\t\t\tfillcircle(snake_x[i], snake_y[i], 20);\n\t\t&#125;\n\t\telse \n\t\t&#123;\n\t\t\tsetfillcolor(LIGHTRED);\n\t\t\tfillcircle(snake_x[i], snake_y[i], 20);\n\t\t&#125;\n\t&#125;\n\t\n\tFlushBatchDraw();&#x2F;&#x2F;*与BeginBatchDraw配合使用\n\tsetfillcolor(YELLOW);\n\t&#x2F;&#x2F;*以下均为字体设置与字体显示，用于显示分数\n\tTCHAR s[5];\n\tfillcircle(food_x, food_y, 20);\n\tsettextstyle(60, 0, _T(&quot;宋体&quot;));\n\tsettextcolor(RGB(25, 32, 94));\n\t_stprintf_s(s, 5, _T(&quot;%d&quot;), score);\n\touttextxy(430, 620, _T(&quot;Score:&quot;));\n\touttextxy(640, 620, s);\n\n\tSleep(speed);&#x2F;&#x2F;用sleep控制速度，speed越小蛇动的越快\n&#125;\n\n动画效果通过clean和show配合。\nclean绘制背景色的圆，达到擦除的效果，然后show再绘制新的圆，达成动画效果。\n蛇的移动这个地方算是核心了\nvoid Snake::SnakeMove() \n&#123;\n\tsrand((unsigned int)(time)(NULL));\n\t&#x2F;&#x2F;如果蛇头的坐标和食物的坐标有一定程度的重合，那么在蛇尾增加新的坐标\n\tif (food_x &gt;&#x3D; snake_x[0] - 20 &amp;&amp;\n\t\tfood_x &lt;&#x3D; snake_x[0] + 20 &amp;&amp;\n\t\tfood_y &gt;&#x3D; snake_y[0] - 20 &amp;&amp;\n\t\tfood_y &lt;&#x3D; snake_y[0] + 20) \n\t&#123;\n\t\tif (dir &#x3D;&#x3D; 1) \n\t\t&#123;\n\t\t\tsnake_x.push_back(snake_x[snake_x.size() - 1] + 40);\n\t\t\tsnake_y.push_back(snake_y[snake_y.size() - 1]);\n\t\t&#125;\n\t\telse if (dir &#x3D;&#x3D; 2)\n\t\t&#123;\n\t\t\tsnake_x.push_back(snake_x[snake_x.size() - 1]);\n\t\t\tsnake_y.push_back(snake_y[snake_y.size() - 1] - 40);\n\t\t&#125;\n\t\telse if (dir &#x3D;&#x3D; 3) \n\t\t&#123;\n\t\t\tsnake_x.push_back(snake_x[snake_x.size() - 1] - 40);\n\t\t\tsnake_y.push_back(snake_y[snake_y.size() - 1]);\n\t\t&#125;\n\t\telse if (dir &#x3D;&#x3D; 5) \n\t\t&#123;\n\t\t\tsnake_x.push_back(snake_x[snake_x.size() - 1]);\n\t\t\tsnake_y.push_back(snake_y[snake_y.size() - 1] + 40);\n\t\t&#125;\n\t\t\n\t\tscore++;&#x2F;&#x2F;加分\n\t\tif (speed &gt;&#x3D; 150) &#x2F;&#x2F;调整速度\n\t\t&#123;\n\t\t\tspeed -&#x3D; 5 * score;\n\t\t&#125;\n\t\t&#x2F;&#x2F;擦除旧食物，更新食物的坐标\n\t\tsetlinecolor(Background)；\n\t\tsetfillcolor(Background);\n\t\tfillcircle(food_x, food_y, 20);\n\t\tfood_x &#x3D; rand() % (Width - 40) + 21;\n\t\tfood_y &#x3D; rand() % (High - 40) + 21;\n\t\t&#x2F;&#x2F;如果生成的食物坐标和蛇重合了，再更新食物的坐标,check是检测是否重合的函数。\n\t\twhile (!check()) \n\t\t&#123;\n\t\t\tfood_x &#x3D; rand() % (Width - 40) + 21;\n\t\t\tfood_y &#x3D; rand() % (High - 40) + 21;\n\t\t&#125;\n\t&#125;\n\t&#x2F;&#x2F;蛇移动，通过从后往前迭代更新坐标，形成移动\n\tfor (int i &#x3D; snake_x.size() - 1; i &gt; 0; i--)\n\t&#123;\n\t\tsnake_x[i] &#x3D; snake_x[i - 1];\n\t\tsnake_y[i] &#x3D; snake_y[i - 1];\n\t&#125;\n\t&#x2F;&#x2F;头节点根据方向特殊处理\n\tif (dir &#x3D;&#x3D; 1) \n\t&#123;\n\t\tsnake_x[0] &#x3D; snake_x[1] - 40;\n\t\tsnake_y[0] &#x3D; snake_y[1];\n\t&#125;\n\telse if (dir &#x3D;&#x3D; 2) \n\t&#123;\n\t\tsnake_x[0] &#x3D; snake_x[1];\n\t\tsnake_y[0] &#x3D; snake_y[1] + 40;\n\t&#125;\n\telse if (dir &#x3D;&#x3D; 3) \n\t&#123;\n\t\tsnake_x[0] &#x3D; snake_x[1] + 40;\n\t\tsnake_y[0] &#x3D; snake_y[1];\n\t&#125;\n\telse if (dir &#x3D;&#x3D; 5) \n\t&#123;\n\t\tsnake_x[0] &#x3D; snake_x[1];\n\t\tsnake_y[0] &#x3D; snake_y[1] - 40;\n\t&#125;\n\t&#x2F;&#x2F;检测是否撞墙或者咬到自己了\n\tfor (unsigned i &#x3D; 1; i &lt; snake_x.size(); i++)\n\t&#123;\n\t\tif ((snake_x[0] &gt;&#x3D; snake_x[i] - 20 &amp;&amp;\n\t\t\tsnake_x[0] &lt;&#x3D; snake_x[i] + 20 &amp;&amp;\n\t\t\tsnake_y[0] &gt;&#x3D; snake_y[i] - 20 &amp;&amp;\n\t\t\tsnake_y[0] &lt;&#x3D; snake_y[i] + 20) ||\n\t\t\t((snake_x[0] - 20 &lt;&#x3D; 0) ||\n\t\t\t(snake_x[0] + 20 &gt;&#x3D; 1280) ||\n\t\t\t\t(snake_y[0] - 20 &lt;&#x3D; 0) ||\n\t\t\t\t(snake_y[0] + 20 &gt;&#x3D; 720))) \n\t\t&#123;&#x2F;&#x2F;停留三秒退出游戏\n\t\t\tSleep(3000);\n\t\t\texit(0);\n\t\t&#125;\n\t&#125;\n&#125;\n\nbool Snake::check() \n&#123;\n\tfor (int i &#x3D; 0; i &lt; snake_x.size(); i++) \n\t&#123;\n\t\tif ((food_x &gt;&#x3D; snake_x[i] - 40 &amp;&amp; food_x &lt;&#x3D; snake_x[i] + 40) &amp;&amp;\n\t\t\t(food_y &gt;&#x3D; snake_y[i] - 40 &amp;&amp; food_y &lt;&#x3D; snake_y[i] + 40))\n\t\t\treturn false;\n\t&#125;\n\treturn true;\n&#125;\n数据更新void Snake::UpdateWithoutInput() \n&#123;\n\tSnakeMove();\n&#125;\nvoid Snake::UpdateWithInput()\n&#123;\n\tchar input;\n\tif (_kbhit()) &#x2F;&#x2F;kbhit检测是否敲击键盘\n\t&#123;&#x2F;&#x2F;用getch获取用户输入，然后作条件判断来确定蛇如何移动\n\t\tinput &#x3D; _getch();\n\t\tif ((input &#x3D;&#x3D; &#39;a&#39; || input &#x3D;&#x3D; &#39;1&#39;) &amp;&amp; dir !&#x3D; 3) &#x2F;&#x2F;无法向当前方向的方向移动，下同\n\t\t&#123;\n\t\t\tdir &#x3D; 1;\n\t\t\tSnakeMove();\n\t\t&#125;\n\t\telse if ((input &#x3D;&#x3D; &#39;s&#39; || input &#x3D;&#x3D; &#39;2&#39;) &amp;&amp; dir !&#x3D; 5)\n\t\t&#123;\n\t\t\tdir &#x3D; 2;\n\t\t\tSnakeMove();\n\t\t&#125;\n\t\telse if ((input &#x3D;&#x3D; &#39;w&#39; || input &#x3D;&#x3D; &#39;5&#39;) &amp;&amp; dir !&#x3D; 2) \n\t\t&#123;\n\t\t\tdir &#x3D; 5;\n\t\t\tSnakeMove();\n\t\t&#125;\n\t\telse if ((input &#x3D;&#x3D; &#39;d&#39; || input &#x3D;&#x3D; &#39;3&#39;) &amp;&amp; dir !&#x3D; 1)\n\t\t&#123;\n\t\t\tdir &#x3D; 3;\n\t\t\tSnakeMove();\n\t\t&#125;\n\t\tif (input &#x3D;&#x3D; 27) &#x2F;&#x2F;如果按esc就暂停游戏，esc的ASCII码是27\n\t\t&#123;\n\t\t\tinput &#x3D; &#39;n&#39;;\n\t\t\twhile (1) \n\t\t\t&#123;\n\t\t\t\tinput &#x3D; _getch();\n\t\t\t\tif (input &#x3D;&#x3D; 27)\n\t\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\n\n结束游戏void Snake::gameover() \n&#123;\n\tEndBatchDraw();&#x2F;&#x2F;*配合另外两个BatchDraw\n\tclosegraph();&#x2F;&#x2F;*关闭窗口\n&#125;\n\n源码#include&lt;graphics.h&gt;\n#include&lt;Windows.h&gt;\n#include&lt;conio.h&gt;\n#include&lt;ctime&gt;\n#include&lt;vector&gt;\n#include&lt;cstdlib&gt;\nusing namespace std;\nclass Snake\n&#123;\npublic:\n\tSnake();\n\tbool check();&#x2F;&#x2F;检测生成的食物是否和蛇重合了\n\tvoid SnakeMove();\n\tvoid startup();\n\tvoid clean();\n\tvoid show();\n\tvoid UpdateWithoutInput();\n\tvoid UpdateWithInput();\n\tvoid gameover();\nprivate:\n\tint High;\n\tint Width;\n\tint Background;\n\tint dir;&#x2F;&#x2F;方向\n\tint score;\n\tint speed;&#x2F;&#x2F;画面更新速度，动态难度\n\tint food_x, food_y;\n\tvector&lt;int&gt; snake_x, snake_y; &#x2F;&#x2F;蛇的每一节的坐标\n&#125;;\nSnake::Snake()\n&#123;\n\tHigh &#x3D; 720;\n\tWidth &#x3D; 1280;\n\tBackground &#x3D; LIGHTGRAY;&#x2F;&#x2F;easyx的颜色宏\n\tdir &#x3D; 5;&#x2F;&#x2F;方向参考1235键位，类似wasd\n\tscore &#x3D; 0;\n\tspeed &#x3D; 300;\n\tfood_x &#x3D; rand() % (Width - 40) + 21; &#x2F;&#x2F;限定食物出现在屏幕范围内\n\tfood_y &#x3D; rand() % (High - 40) + 21;\n\tsnake_x.resize(4), snake_y.resize(4);&#x2F;&#x2F;蛇的初始长度为4\n&#125;\nbool Snake::check()\n&#123;\n\tfor (int i &#x3D; 0; i &lt; snake_x.size(); i++)\n\t&#123;\n\t\tif ((food_x &gt;&#x3D; snake_x[i] - 40 &amp;&amp; food_x &lt;&#x3D; snake_x[i] + 40) &amp;&amp;\n\t\t\t(food_y &gt;&#x3D; snake_y[i] - 40 &amp;&amp; food_y &lt;&#x3D; snake_y[i] + 40))\n\t\t\treturn false;\n\t&#125;\n\treturn true;\n&#125;\nvoid Snake::SnakeMove()\n&#123;\n\tsrand((unsigned int)(time)(NULL));\n\t&#x2F;&#x2F;如果蛇头的坐标和食物的坐标有一定程度的重合，那么在蛇尾增加新的坐标\n\tif (food_x &gt;&#x3D; snake_x[0] - 20 &amp;&amp;\n\t\tfood_x &lt;&#x3D; snake_x[0] + 20 &amp;&amp;\n\t\tfood_y &gt;&#x3D; snake_y[0] - 20 &amp;&amp;\n\t\tfood_y &lt;&#x3D; snake_y[0] + 20)\n\t&#123;\n\t\tif (dir &#x3D;&#x3D; 1)\n\t\t&#123;\n\t\t\tsnake_x.push_back(snake_x[snake_x.size() - 1] + 40);\n\t\t\tsnake_y.push_back(snake_y[snake_y.size() - 1]);\n\t\t&#125;\n\t\telse if (dir &#x3D;&#x3D; 2)\n\t\t&#123;\n\t\t\tsnake_x.push_back(snake_x[snake_x.size() - 1]);\n\t\t\tsnake_y.push_back(snake_y[snake_y.size() - 1] - 40);\n\t\t&#125;\n\t\telse if (dir &#x3D;&#x3D; 3)\n\t\t&#123;\n\t\t\tsnake_x.push_back(snake_x[snake_x.size() - 1] - 40);\n\t\t\tsnake_y.push_back(snake_y[snake_y.size() - 1]);\n\t\t&#125;\n\t\telse if (dir &#x3D;&#x3D; 5)\n\t\t&#123;\n\t\t\tsnake_x.push_back(snake_x[snake_x.size() - 1]);\n\t\t\tsnake_y.push_back(snake_y[snake_y.size() - 1] + 40);\n\t\t&#125;\n\n\t\tscore++;&#x2F;&#x2F;加分\n\t\tif (speed &gt;&#x3D; 150) &#x2F;&#x2F;调整速度\n\t\t&#123;\n\t\t\tspeed -&#x3D; 5 * score;\n\t\t&#125;\n\t\t&#x2F;&#x2F;擦除旧食物，更新食物的坐标\n\t\tsetlinecolor(Background);\n\t\t\tsetfillcolor(Background);\n\t\tfillcircle(food_x, food_y, 20);\n\t\tfood_x &#x3D; rand() % (Width - 40) + 21;\n\t\tfood_y &#x3D; rand() % (High - 40) + 21;\n\t\t&#x2F;&#x2F;如果生成的食物坐标和蛇重合了，再更新食物的坐标,check是检测是否重合的函数。\n\t\twhile (!check())\n\t\t&#123;\n\t\t\tfood_x &#x3D; rand() % (Width - 40) + 21;\n\t\t\tfood_y &#x3D; rand() % (High - 40) + 21;\n\t\t&#125;\n\t&#125;\n\t&#x2F;&#x2F;蛇移动，通过从后往前迭代更新坐标，形成移动\n\tfor (int i &#x3D; snake_x.size() - 1; i &gt; 0; i--)\n\t&#123;\n\t\tsnake_x[i] &#x3D; snake_x[i - 1];\n\t\tsnake_y[i] &#x3D; snake_y[i - 1];\n\t&#125;\n\t&#x2F;&#x2F;头节点根据方向特殊处理\n\tif (dir &#x3D;&#x3D; 1)\n\t&#123;\n\t\tsnake_x[0] &#x3D; snake_x[1] - 40;\n\t\tsnake_y[0] &#x3D; snake_y[1];\n\t&#125;\n\telse if (dir &#x3D;&#x3D; 2)\n\t&#123;\n\t\tsnake_x[0] &#x3D; snake_x[1];\n\t\tsnake_y[0] &#x3D; snake_y[1] + 40;\n\t&#125;\n\telse if (dir &#x3D;&#x3D; 3)\n\t&#123;\n\t\tsnake_x[0] &#x3D; snake_x[1] + 40;\n\t\tsnake_y[0] &#x3D; snake_y[1];\n\t&#125;\n\telse if (dir &#x3D;&#x3D; 5)\n\t&#123;\n\t\tsnake_x[0] &#x3D; snake_x[1];\n\t\tsnake_y[0] &#x3D; snake_y[1] - 40;\n\t&#125;\n\t&#x2F;&#x2F;检测是否撞墙或者咬到自己了\n\tfor (unsigned i &#x3D; 1; i &lt; snake_x.size(); i++)\n\t&#123;\n\t\tif ((snake_x[0] &gt;&#x3D; snake_x[i] - 20 &amp;&amp;\n\t\t\tsnake_x[0] &lt;&#x3D; snake_x[i] + 20 &amp;&amp;\n\t\t\tsnake_y[0] &gt;&#x3D; snake_y[i] - 20 &amp;&amp;\n\t\t\tsnake_y[0] &lt;&#x3D; snake_y[i] + 20) ||\n\t\t\t((snake_x[0] - 20 &lt;&#x3D; 0) ||\n\t\t\t\t(snake_x[0] + 20 &gt;&#x3D; 1280) ||\n\t\t\t\t(snake_y[0] - 20 &lt;&#x3D; 0) ||\n\t\t\t\t(snake_y[0] + 20 &gt;&#x3D; 720)))\n\t\t&#123;&#x2F;&#x2F;停留三秒退出游戏\n\t\t\tSleep(3000);\n\t\t\texit(0);\n\t\t&#125;\n\t&#125;\n&#125;\nvoid Snake::startup()\n&#123;\n\tsrand((unsigned int)(time)(NULL));\n\tinitgraph(Width, High);\n\tsetbkcolor(Background);\n\tcleardevice();\n\tfor (int i &#x3D; 0; i &lt; 4; i++)\n\t&#123;\n\t\tsnake_x[i] &#x3D; Width &#x2F; 2 - 40 * i;\n\t\tsnake_y[i] &#x3D; High &#x2F; 2;\n\t&#125;\n\tBeginBatchDraw();\n&#125;\nvoid Snake::clean()\n&#123;\n\tsetlinecolor(Background);&#x2F;&#x2F;设置线的颜色\n\tsetfillcolor(Background);&#x2F;&#x2F;设置填充色\n\tfor (unsigned i &#x3D; 0; i &lt; snake_x.size(); i++)\n\t&#123;\n\t\tfillcircle(snake_x[i], snake_y[i], 20);&#x2F;&#x2F;画圆\n\t&#125;\n&#125;\nvoid Snake::show()\n&#123;\n\tfor (unsigned i &#x3D; 0; i &lt; snake_x.size(); i++)\n\t&#123;\n\t\tif (i &#x3D;&#x3D; 0)\n\t\t&#123;\n\t\t\tsetfillcolor(LIGHTMAGENTA);\n\t\t\tfillcircle(snake_x[i], snake_y[i], 20);\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tsetfillcolor(LIGHTRED);\n\t\t\tfillcircle(snake_x[i], snake_y[i], 20);\n\t\t&#125;\n\t&#125;\n\n\tFlushBatchDraw();&#x2F;&#x2F;与BeginBatchDraw配合使用\n\tsetfillcolor(YELLOW);\n\t&#x2F;&#x2F;以下均为字体设置与字体显示，用于显示分数\n\tTCHAR s[5];\n\tfillcircle(food_x, food_y, 20);\n\tsettextstyle(60, 0, _T(&quot;宋体&quot;));\n\tsettextcolor(RGB(25, 32, 94));\n\t_stprintf_s(s, 5, _T(&quot;%d&quot;), score);\n\touttextxy(430, 620, _T(&quot;Score:&quot;));\n\touttextxy(640, 620, s);\n\n\tSleep(speed);&#x2F;&#x2F;用sleep控制速度，speed越小蛇动的越快\n&#125;\nvoid Snake::UpdateWithoutInput()\n&#123;\n\tSnakeMove();\n&#125;\nvoid Snake::UpdateWithInput()\n&#123;\n\tchar input;\n\tif (_kbhit())\n\t&#123;\n\t\tinput &#x3D; _getch();\n\t\tif ((input &#x3D;&#x3D; &#39;a&#39; || input &#x3D;&#x3D; &#39;1&#39;) &amp;&amp; dir !&#x3D; 3)\n\t\t&#123;\n\t\t\tdir &#x3D; 1;\n\t\t\tSnakeMove();\n\t\t&#125;\n\t\telse if ((input &#x3D;&#x3D; &#39;s&#39; || input &#x3D;&#x3D; &#39;2&#39;) &amp;&amp; dir !&#x3D; 5)\n\t\t&#123;\n\t\t\tdir &#x3D; 2;\n\t\t\tSnakeMove();\n\t\t&#125;\n\t\telse if ((input &#x3D;&#x3D; &#39;w&#39; || input &#x3D;&#x3D; &#39;5&#39;) &amp;&amp; dir !&#x3D; 2)\n\t\t&#123;\n\t\t\tdir &#x3D; 5;\n\t\t\tSnakeMove();\n\t\t&#125;\n\t\telse if ((input &#x3D;&#x3D; &#39;d&#39; || input &#x3D;&#x3D; &#39;3&#39;) &amp;&amp; dir !&#x3D; 1)\n\t\t&#123;\n\t\t\tdir &#x3D; 3;\n\t\t\tSnakeMove();\n\t\t&#125;\n\t\tif (input &#x3D;&#x3D; 27)\n\t\t&#123;\n\t\t\tinput &#x3D; &#39;n&#39;;\n\t\t\twhile (1)\n\t\t\t&#123;\n\t\t\t\tinput &#x3D; _getch();\n\t\t\t\tif (input &#x3D;&#x3D; 27)\n\t\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\nvoid Snake::gameover()\n&#123;\n\tEndBatchDraw();\n\tclosegraph();\n&#125;\n\nint main()\n&#123;\n\tSnake my_snake;\n\tmy_snake.startup();\n\twhile (1)\n\t&#123;\n\t\tmy_snake.clean();\n\t\tmy_snake.UpdateWithoutInput();\n\t\tmy_snake.UpdateWithInput();\n\t\tmy_snake.show();\n\t&#125;\n\tmy_snake.gameover();\n\treturn 0;\n&#125;\n","slug":"带图形界面的贪吃蛇","date":"2021-08-13T03:40:46.000Z","categories_index":"技术分享","tags_index":"小游戏,C++","author_index":"南望"},{"id":"ca5547898d7e053911493b82ed0cb0fa","title":"剑指 Offer 03. 数组中重复的数字的4种解法（Java语言）","content":"题目详情找出数组中重复的数字。\n在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。\n示例 1：\n输入：[2, 3, 1, 0, 2, 5, 3]输出：2 或 3 \n解法一：暴力法，双层循环直接进行两层循环，对每个数字都逐一比较，空间复杂度O(1)，时间复杂度O(n^2)，总的来说是下下策，执行用时吓死人Java代码\npublic int findRepeatNumber_1(int[] nums) &#123;\n    for (int i &#x3D; 0; i &lt; nums.length; i++)\n      for (int j &#x3D; i + 1; j &lt; nums.length; j++)\n        if (nums[i] &#x3D;&#x3D; nums[j])\n          return nums[i];\n    return -1;\n  &#125;\n解法二 排序后相邻的两两比较很容易想到的方法，排序后两两比较，空间复杂度O(1)，时间复杂度O(nlogn)，只能说是中下策，但执行用时已经有了相当的改善Java代码\npublic int findRepeatNumber_2(int[] nums) &#123;\n    Arrays.sort(nums);\n    for (int i &#x3D; 0; i &lt; nums.length - 1; i++) &#123;\n      if (nums[i] &#x3D;&#x3D; nums[i + 1])\n        return nums[i];\n    &#125;\n    return -1;\n  &#125;\n解法三 利用数组实现一个map映射首先，判断重复，常见的办法就是利用HashMap或是HashSet来判断，但我们观察数组发现，给定的值都是0~n-1，那么我们没必要使用集合类来加重负担，直接用数组就可以完成映射，给定的数组元素为键，出现次数为值。空间复杂度为O(n)，时间复杂度为O(n)，在大多数面试中已经算是可以让人接受的答案了。\npublic int findRepeatNumber_3(int[] nums) &#123;\n    int[] map &#x3D; new int[nums.length];\n    for (int i &#x3D; 0; i &lt; nums.length; i++) &#123;\n      if (map[nums[i]] &#x3D;&#x3D; 0)\n        map[nums[i]]++;\n      else\n        return nums[i];\n    &#125;\n    return -1;\n  &#125;\n解法四 利用重排后的元素碰撞解法三已经达到了空间时间复杂度都是O(n)的情况，实际上还能继续优化，达到O(1)的空间复杂度。我们知道，数组中的元素是0~n-1，那么可以想到，如果没有重复的元素，那么排序后，每个元素都应该和它的下标相同，那么如果有重复的元素，那么两个元素就会撞到一起。基于这种思路，我们设计如下算法：对每个元素都进行处理，把它交换到它应该在的位置，如果交换前发现那个位置上的元素和它相等，也就是撞车了，那么很明显这个元素就是重复的数字。每个数字只要进行交换就能找到自己的位置，时间复杂度是O(n)，且没有用到额外的空间，因此空间复杂度只有O(1)\n\npublic int findRepeatNumber_4(int[] nums) &#123;\n    for (int i &#x3D; 0; i &lt; nums.length; i++) &#123;\n      while (nums[i] !&#x3D; i) &#123;\n        &#x2F;&#x2F;两个数撞了\n        if (nums[i] &#x3D;&#x3D; nums[nums[i]]) &#123;\n          return nums[i];\n        &#125;\n        &#x2F;&#x2F;把一个数交换到它应该在的位置\n        int temp &#x3D; nums[nums[i]];\n        nums[nums[i]] &#x3D; nums[i];\n        nums[i] &#x3D; temp;\n      &#125;\n    &#125;\n    return -1;\n  &#125;\n","slug":"剑指 Offer 03. 数组中重复的数字的4种解法（Java语言）","date":"2021-08-04T08:20:41.000Z","categories_index":"学习笔记","tags_index":"数据结构与算法,剑指Offer","author_index":"南望"},{"id":"809380e59300e634907b381d0433de40","title":"Springboot的自动装配原理浅析","content":"最近在学习Springboot，不少文章和视频在完成了第一个快速入门的项目之后就直接进入了Springboot运行的原理部分，因此决定写一篇文章加深理解。\n原理的理解主要使用了查看源码和画流程图的方式。\npom.xml对于一个maven项目，我们一般首要分析其pom文件，查看相关依赖。\n&lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;\n            &lt;scope&gt;test&lt;&#x2F;scope&gt;\n            &lt;exclusions&gt;\n                &lt;exclusion&gt;\n                    &lt;groupId&gt;org.junit.vintage&lt;&#x2F;groupId&gt;\n                    &lt;artifactId&gt;junit-vintage-engine&lt;&#x2F;artifactId&gt;\n                &lt;&#x2F;exclusion&gt;\n            &lt;&#x2F;exclusions&gt;\n        &lt;&#x2F;dependency&gt;\n    &lt;&#x2F;dependencies&gt;\n\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n                &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;\n            &lt;&#x2F;plugin&gt;\n        &lt;&#x2F;plugins&gt;\n    &lt;&#x2F;build&gt;\n可以看到依赖方面都是很简单的内容，加入了测试启动器和web启动器以及springboot的build插件，但我们发现了一个不一般的地方，他们都没有版本号！这是为什么呢？   我们往上查看，可以发现这样的父依赖。\n&lt;parent&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;2.3.4.RELEASE&lt;&#x2F;version&gt;\n        &lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;\n    &lt;&#x2F;parent&gt;\n   我们点进去查看，会发现。。。还有一层父依赖！    &lt;parent&gt;\n  &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;spring-boot-dependencies&lt;&#x2F;artifactId&gt;\n  &lt;version&gt;2.3.4.RELEASE&lt;&#x2F;version&gt;\n&lt;&#x2F;parent&gt;   继续点进去查看。\n&lt;properties&gt;\n    &lt;activemq.version&gt;5.15.13&lt;&#x2F;activemq.version&gt;\n    &lt;antlr2.version&gt;2.7.7&lt;&#x2F;antlr2.version&gt;\n    &lt;appengine-sdk.version&gt;1.9.82&lt;&#x2F;appengine-sdk.version&gt;\n    &lt;artemis.version&gt;2.12.0&lt;&#x2F;artemis.version&gt;\n    &lt;aspectj.version&gt;1.9.6&lt;&#x2F;aspectj.version&gt;\n    &lt;assertj.version&gt;3.16.1&lt;&#x2F;assertj.version&gt;\n    &lt;atomikos.version&gt;4.0.6&lt;&#x2F;atomikos.version&gt;\n    &lt;awaitility.version&gt;4.0.3&lt;&#x2F;awaitility.version&gt;\n    &lt;bitronix.version&gt;2.1.4&lt;&#x2F;bitronix.version&gt;\n    &lt;build-helper-maven-plugin.version&gt;3.1.0&lt;&#x2F;build-helper-maven-plugin.version&gt;\n    &lt;byte-buddy.version&gt;1.10.14&lt;&#x2F;byte-buddy.version&gt;\n    &lt;caffeine.version&gt;2.8.5&lt;&#x2F;caffeine.version&gt;\n    &lt;cassandra-driver.version&gt;4.6.1&lt;&#x2F;cassandra-driver.version&gt;\n    ...........\n这样的信息就是这些依赖尽头的主体了，这个文件有大量的配置信息，标注了每个可能用到的依赖的版本号，因此我们不用指定依赖的版本，springboot会根据你使用的版本自动给你安排合适的版本，再也不用担心依赖版本的冲突导致的崩溃啦！\n\npom.xml文件我们就说到这里，接下来才是重头戏了！\n\n思维导图：\n\t![在这里插入图片描述](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;20200929160256862.png#pic_center)\n\n### 启动类的@SpringBootApplication注解\n启动类包括两个重要的部分，一个是@SpringBootApplication注解，另一个是其中的run方法，我们先从这个注解开始说起。\n\n首先，这个注解的作用，猜也猜得到，是标注这个应用是一个springboot应用，这样springboot就可以帮我们对其进行自动配置，我们想要了解，spring boot是如何通过注解来自动装配的，装配了什么。\n\n老办法，查看源码，我点！\n&#96;&#96;&#96;java\n@Target(&#123;ElementType.TYPE&#125;)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@SpringBootConfiguration\n@EnableAutoConfiguration\n@ComponentScan\n以上是@SpringBootApplication注解之下的几个注解，出去那些基础的之外，我们可以看见三个特别显眼的，@SpringBootConfiguration，@ComponentScan，@EnableAutoConfiguration，我们逐个查看他们的源码。\n@SpringBootConfiguration他的源码：\n@Target(&#123;ElementType.TYPE&#125;)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Configuration\n乏善可陈。。。根据其下的@Configuration可以猜到，它是起到一个标注作用的注解，标志当前应用为一个springboot应用。\n我们回到上一层查看其他注解的源码。\n@ComponentScan这个更没啥好说的了，源码都没必要看了，他的作用是扫描指定包下的组件，将它们加载到Spring的IOC容器之中，很重要，但不是我们探究的重点。\n我们查看最后一个注解的源码。\n@EnableAutoConfiguration看得出来，他的作用是启用自动配置，我们重点关注如何启用，怎么启用，启用了什么。他的源码：\n@AutoConfigurationPackage\n@Import(&#123;AutoConfigurationImportSelector.class&#125;)\n看起来重要的注解就这两个，第一个看翻译是自动配置包，我们点进去查看他的源码：\n@Import(&#123;Registrar.class&#125;)\n噢，这是一个注册器，根据相关源码猜测是将bean注册导入到容器之中（若有错误希望指正）。\n我们回头，看看import导入的东西。\n自动配置导入选择器，我们猜测它是导入了需要的配置文件，查看源码：我这里截图还没有截全。。。我们发现其中有相当多的方法，我们的目的是查看如何加载组件的，因此寻找configuration相关的方法。\n找到了！getCandidateConfigurations，获取候选配置，这个方法中又使用了SpringFactoriesLoader，我们继续深入。public static final String FACTORIES_RESOURCE_LOCATION = &quot;META-INF/spring.factories&quot;;看到了看起来是文件的东西！我们使用全局搜索，发现它在springboot的jar包内，我们再点开来看看\n我们根据源头打开spring.factories ， 看到了很多自动配置的文件；这就是自动配置根源所在！可以随便点开看看，都可以看到这些一个个的都是JavaConfig配置类，而且都注入了一些Bean。\n至此，我们大概明白了Spring boot的自动装配原理了：\n自动配置真正实现是从classpath中搜寻所有的META-INF/spring.factories配置文件 ，并将其中对应的 org.springframework.boot.autoconfigure. 包下的配置项，通过反射实例化为对应标注了 @Configuration的JavaConfig形式的IOC容器配置类 ， 然后将这些都汇总成为一个实例并加载到IOC容器中。\n所以其实刚刚那一大串套娃注解其实都是为了拿到spring.factories。。。我不太懂设计模式，不太懂这样做的意义是什么样的哈哈哈。\n结论\nSpringBoot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值\n\n将这些值作为自动配置类导入容器 ， 自动配置类就生效 ， 帮我们进行自动配置工作；\n\n整个J2EE的整体解决方案和自动配置都在springboot-autoconfigure的jar包中；\n\n它会给容器中导入非常多的自动配置类 （xxxAutoConfiguration）, 就是给容器中导入这个场景需要的所有组件 ， 并配置好这些组件 ；\n\n有了自动配置类 ， 免去了我们手动编写配置注入功能组件等的工作；\n\n\n思维导图：\nrun方法分析该方法主要分两部分，一部分是SpringApplication的实例化，二是run方法的执行；SpringApplication\n这个类主要做了以下四件事情：\n1、推断应用的类型是普通的项目还是Web项目\n2、查找并加载所有可用初始化器 ， 设置到initializers属性中\n3、找出所有的应用程序监听器，设置到listeners属性中\n4、推断并设置main方法的定义类，找到运行的主类\n源码分析无力了。。。给大家一张图吧，说的很清楚了，大家可以跟着这张图自己读读源码。\n\n","slug":"Springboot的自动装配原理浅析","date":"2021-08-04T08:16:55.000Z","categories_index":"技术分享","tags_index":"Java,源码分析,SpringBoot","author_index":"南望"},{"id":"3a69b8fada749b74d26a9663c4985507","title":"Java new ArrayList(int initialCapacity)初始化容量问题","content":"今天看了ArrayList源码，发现了一个不大不小的问题：\npublic ArrayList(int initialCapacity) &#123;\n        if (initialCapacity &gt; 0) &#123;\n            this.elementData &#x3D; new Object[initialCapacity];\n        &#125; else if (initialCapacity &#x3D;&#x3D; 0) &#123;\n            this.elementData &#x3D; EMPTY_ELEMENTDATA;\n        &#125; else &#123;\n            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+\n                                               initialCapacity);\n        &#125;\n    &#125;\n\n这个构造函数咋一看问题不大，给elementData底层数组分配空间嘛，初始化数组的大小了但是实际使用时：\nArrayList&lt;Integer&gt; a &#x3D; new ArrayList(9);\na.set(1,5);\n抛出了IndexOutOfBoundsException\n结合源码：\npublic E set(int index, E element) &#123;\n        Objects.checkIndex(index, size);\n        E oldValue &#x3D; elementData(index);\n        elementData[index] &#x3D; element;\n        return oldValue;\n    &#125;\n其中第一行首先检测了下标，参数是index和size，而size是元素个数，也就是说，尽管设置了数组的容量，但针对ArrayList中元素的操作，是根据元素的位置，而不是根据容量来操作。也就是说，至少得有个元素才能set它，没有元素就是set个寂寞。\n因此set(1,5)在第一行直接抛出异常了\n综上所述ArrayList(int initialCapacity) 只是让ArrayList有了容纳 initialCapacity个元素的潜力，并不能对其中的“位置”操作。\nPS：这个问题在Java核心技术卷1中就有提到，但我当时直接忘了，果然看了源码才理解的透彻。\n","slug":"Java new ArrayList(int initialCapacity)初始化容量问题","date":"2021-08-04T07:35:13.000Z","categories_index":"问题记录","tags_index":"Java,源码分析","author_index":"南望"}]