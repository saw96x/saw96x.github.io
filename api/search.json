[{"id":"3a69b8fada749b74d26a9663c4985507","title":"Java new ArrayList(int initialCapacity)初始化容量问题","content":"今天看了ArrayList源码，发现了一个不大不小的问题：\npublic ArrayList(int initialCapacity) &#123;\n        if (initialCapacity > 0) &#123;\n            this.elementData = new Object[initialCapacity];\n        &#125; else if (initialCapacity == 0) &#123;\n            this.elementData = EMPTY_ELEMENTDATA;\n        &#125; else &#123;\n            throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                               initialCapacity);\n        &#125;\n    &#125;\n\n这个构造函数咋一看问题不大，给elementData底层数组分配空间嘛，初始化数组的大小了但是实际使用时：\nArrayList&lt;Integer> a = new ArrayList(9);\na.set(1,5);\n抛出了IndexOutOfBoundsException\n结合源码：\npublic E set(int index, E element) &#123;\n        Objects.checkIndex(index, size);\n        E oldValue = elementData(index);\n        elementData[index] = element;\n        return oldValue;\n    &#125;\n其中第一行首先检测了下标，参数是index和size，而size是元素个数，也就是说，尽管设置了数组的容量，但针对ArrayList中元素的操作，是根据元素的位置，而不是根据容量来操作。也就是说，至少得有个元素才能set它，没有元素就是set个寂寞。\n因此set(1,5)在第一行直接抛出异常了\n综上所述ArrayList(int initialCapacity) 只是让ArrayList有了容纳 initialCapacity个元素的潜力，并不能对其中的“位置”操作。\nPS：这个问题在Java核心技术卷1中就有提到，但我当时直接忘了，果然看了源码才理解的透彻。\n","slug":"Java new ArrayList(int initialCapacity)初始化容量问题","date":"2021-08-04T07:35:13.000Z","categories_index":"技术学习","tags_index":"Java,源码分析","author_index":"南望"}]