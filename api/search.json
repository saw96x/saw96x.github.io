[{"id":"b4694def951abc4bafb5168cc2a7630a","title":"JVM垃圾回收","content":"JVM垃圾回收1. 如何判断对象可以回收1.1 简要介绍：\n引用计数法，如果某个对象被引用了，则他的计数加1，不再被引用了，则减1，计数为0则回收。弊端：循环引用，比如a和b相互引用，即使他们两个永远都不再被使用了，但是由于存在引用计数，所以永远都不会被回收。早期python虚拟机采用这种算法。\n\n可达性分析算法：首先确定根对象（肯定不能被垃圾回收的对象），进行垃圾回收前对所有对象进行一次扫描，如果被根对象直接或间接应用的对象就不能被回收，如果没有被引用，那么就可以被回收。许多主流的商用程序语言（Java，C#等等）都采用这种算法进行\n\n\n\n1.2 可达性分析算法：\nJava虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象\n\n扫描堆中的对象，看是否能够沿这GC Root对象为起点的引用链找到该对象，找不到，表示可以回收\n哪些对象可以作为GC Root对象\n\n SystemClass：由自举/系统类加载器加载的类。例如，rt.jar中所有诸如java.util.*的类。 JNILocal：原生代码中的本地变量，例如用户定义的JNI（Java本地接口，一般用来使Java代码和其他语言代码进行交互）代码或JVM内部代码。 JNIGlobal：原生代码中的全局变量，例如用户定义的JNI代码或JVM内部代码。 ThreadBlock：当前活跃的线程块中引用的对象。 Thread：启动且未停止的线程。 BusyMonitor：其wait()或notify()方法被调用，或被同步synchronized的对象。例如，通过调用synchronized(Object)或者进入其某个synchronized方法。静态方法对应类，非静态方法对应对象。 JavaLocal：本地变量。例如，仍在线程的栈中的方法输入参数或本地创建的对象。 NativeStack：（例如用户定义的JNI代码或JVM内部代码这样的）原生代码的入或出参数。通常发生在许多方法有原生部分，方法参数处理的对象成为GC根对象。例如，参数用于文件、网络I/O或反射。 Finalizer：在队列中等待其finalizer运行的对象。 Unfinalized：拥有finalize方法，但是还没有被终结且不在finalizer队列的对象。 Unreachable：从其他根对象不可达的对象，但是被内存分析器标记为根对象。 Unknown：没有根类型的对象。一些转储(dump)，例如IBM可移植对转储文件，没有根信息。对于这些转储，内存分析器解析程序将没有被其他根对象引用的对象标记为此类根对象。\n如果觉得上面的太复杂，那么简单来说，在Java语言中，可作为GC Roots的对象包括下面4种：\n\n虚拟机栈（栈帧中的本地变量表）中引用的对象。*\n方法区中类静态属性引用的对象。*\n方法区中常量引用的对象。* \n本地方法栈中JNI（即一般说的Native方法）引用的对象。\n\n1.3 四种引用\n此图中，实线表示强引用，虚线表示其余引用 \n\n强引用\n可以被GC Root对象直接或间接的找到，这种关系是强引用，一般情况下，我们书写的代码基本上形成的引用关系都是强引用，只有当所有强引用都断开时，对象才会被垃圾回收，除此之外是绝不可能将其回收的。\nObject o &#x3D; new Object();   &#x2F;&#x2F;  强引用\no &#x3D; null; &#x2F;&#x2F;断开强引用，被回收\n软引用\n在Java中，软引用本质上是一种特殊设计的类，因此软引用实际上是被手动创建出来的，使用SoftReference类创建出来\nString str &#x3D; new String(&quot;abc&quot;);                                     &#x2F;&#x2F; 强引用\nSoftReference&lt;String&gt; softRef &#x3D; new SoftReference&lt;String&gt;(str);     &#x2F;&#x2F; str被软引用\n\n 如果一个对象只具有软引用（通过SoftReference建立），则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些软引用对象的内存。只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。\n最具代表性的应用，如浏览器的后退按钮，点击后退要返回到上一个页面，如果重新加载，可能耗时较长，如果将其存储到内存中，则会造成浪费，这时可以使用软引用进行缓存，如果缓存资源充足，那么就将页面保存到缓存中，如果紧张，由于软引用的特性，页面缓存会被垃圾回收器回收。\n可以配合引用队列使用，如果软引用它引用的对象被回收时，软引用本身（SoftReference实例）会被放到引用队列中，可以对其方便的进行进一步处理，比如释放SoftReference实例占用的内存。\n\n弱引用\n和软引用相似，弱引用对象也要手动创建出来，使用WeakReference建立\nString str &#x3D; new String(&quot;abc&quot;);                                     &#x2F;&#x2F;强引用\nWeakReference&lt;String&gt; abcWeakRef &#x3D; new WeakReference&lt;String&gt;(str);  &#x2F;&#x2F;str被弱引用\n\n和软引用不同的是，无论空间是否充足，只要垃圾回收器运行了，那么检测到弱引用，就会即刻将其回收。但是垃圾回收器的线程优先级很低，不太经常运行，所以不会发生马上就会被清理掉的情况。如果这个对象是偶尔的使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么你应该用 WeakReference 来记住此对象。  \n可以配合引用队列使用，如果软引用它引用的对象被回收时，软引用本身（WeakReference实例）会被放到引用队列中，可以对其方便的进行进一步处理，比如释放WeakReference实例占用的内存。\n\n虚引用\n“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。\nString str &#x3D; new String(&quot;abc&quot;);                                     &#x2F;&#x2F;强引用\nPhantomReference&lt;String&gt; ref &#x3D; new PhantomReference&lt;String&gt;(str);  &#x2F;&#x2F;str被虚引用\n\n 虚引用主要用来跟踪对象被垃圾回收器回收的活动，同时，和软引用以及弱引用不同的是，虚引用必须要和引用队列一起使用，下面用一个例子来说明其作用和特征。\n用Java中使用ByteBuffer分配直接内存的例子来说明一下，一个名叫Cleaner的虚引用关联了ByteBuffer实例对象，而我们借助ByteBuffer实例对象分配一些直接内存，当对ByteBuffer实例对象的强引用被断开后，ByteBuffer被回收了，但是其获取的直接内存不能被JVM垃圾回收器释放（因为它是底层的内存），这时候就要通过Cleaner这个虚引用，它进入引用队列，进行后续处理，通过这个虚引用获取到那块直接内存，然后将其释放。\n\n\n1.4 回收前的筛选判断即使在可达性分析算法中不可达的对象，也并非一定会被垃圾回收，要真正回收一个对象，至少要经历两次标记过程：\n\n如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize（）方法。当对象没有覆盖finalize（）方法，或者finalize（）方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。\n如果这个对象被判定为有必要执行finalize（）方法，那么这个对象将会放置在一个叫做F-Queue的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。但此线程不保证一定会等待finalize()方法运行结束，这是为了防止发生死循环时其他队列中的对象无法执行finalize()。finalize（）方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要在finalize（）中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，如果对象没能在finalize()中建立关联，那么它就会真的被回收了。\n\n2. 垃圾回收算法2.1 标记-清除算法这种算法是最基础的手机算法，言简意赅，算法分为“标记”和“清除”（Mark-Sweep）两个阶段：首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。\n在JVM中，标记过程就是上文说的回收前的筛选判断（两次标记）。这种算法相当简单，但是仍然不经常使用它，它的主要不足有两个：一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。\n2.2 复制算法为了解决效率问题，一种称为“复制”（Copying）的收集算法出现了，它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。\n这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将内存缩小为了原来的一半，未免太高了一点。\n2.3 标记-整理算法还有一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。\n在JVM中，主要使用的复制算法和标记-整理算法，他们分别针对不同生命周期的对象。\n3. 分代垃圾回收当前商业虚拟机的垃圾回收都采用分代收集的思想，就是根据对象的生命周期将内存划分为几块，一般是把Java堆中分为新生代和老年代。\n新生代的区域存储刚被创建出来的对象，一般有研究表明，新生代中的对象98%是“朝生夕死”的，而在经历了n次垃圾回收后仍然存活的对象，则会被放到老年代，一般老年代中的对象生命周期都较长。\n虚拟机对不同的区域采用不同的垃圾回收算法，由于新生代大多数对象生命周期极短，因此采用改良后的复制算法来回收。\n不是按照1:1的比例来划分内存空间，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。\nHotSpot虚拟机默认Eden和Survivor的大小比例是8:1，因此每次只会浪费10%的空间。但是我们不能断定，某次新生代的垃圾回收之后，10%的内存一定装得下存活的实例对象，因此当Survivor对象不够用时，需要依赖其他内存进行分配担保。\n如果另外一块Survivor空间没有足够空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代。\n对于老年代，虚拟机采用的垃圾回收算法是标记-整理算法，一方面老年代对象不多，使用这种算法效率略低可以接受，另一方面也可以清理出整块的内存，方便后续的内存分配。\n4. 垃圾收集器\n如图，这是HotSpot虚拟机包含的所有收集器，如果两个收集器存在连线，就说明它们可以搭配使用，虚拟机所处的区域，则表示它是属于新生代收集器还是老年代收集器。\n4.1 Serial收集器它是最基本，发展历史最悠久的收集器，它是单线程收集器，在进行垃圾收集时丙戌暂停其他所有线程，直到它收集结束。\n看起来它效率很低，但实际上，它依然是虚拟机运行在Client（客户端）模式下的默认新生代收集器。\n它有着自己的优点：简单高效、没有线程交互开销，对于内存没有非常大的新生代已经足够使用了。\n4.2 ParNew收集器它是Serial收集器的多线程版本，除此之外它就没什么创新之处了，它第一次实现了让垃圾收集线程与用户线程同时工作\n5. 垃圾回收调优","slug":"JVM垃圾回收","date":"2021-08-12T07:11:37.000Z","categories_index":"技术学习","tags_index":"Java,JVM,源码分析","author_index":"南望"},{"id":"f0feb27731f09def8e6fa03e806c3c89","title":"JVM内存结构","content":"本篇笔记不定期更新\n内存结构图先上图这张图差不多就把JVM的内存结构以及和class源文件，JVM执行引擎，以及操作系统自带的本地方法接口之间的关系囊括进去了。\n下面我们就JVM内存结构的几个组成部分来逐一简单介绍一下\n1. 程序计数器1.1 定义Program Counter Register 程序计数器（寄存器）\n1.2 作用\n在执行当前指令时，记住下一条JVM指令的执行地址，所以PCR也被称为寄存器，在物理上通过CPU寄存器实现\n在多线程程序中起到一个记录上下文的作用，方便切换线程时可以继续运行\n字节码解释器通过改变PCR的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要PCR来完成\n如果线程正在执行Java方法，那么PCR记录的市正在执行的虚拟机字节码指令的地址，如果正在执行的是Native方法，这个计数器值则为空（Undefined）\n\n1.3 特点\nJava支持多线程，而PCR是线程私有的，每个线程都有自己的PCR\n不会存在内存溢出此内存区域，是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域\n生命周期与线程相同\n\n2. 虚拟机栈栈–线程运行需要的内存空间，由栈帧组成，栈帧看为栈内的元素\n栈帧–每个方法运行时所需要的内存，参数，局部变量，返回地址等等····\n当调用某个方法时，会给栈帧分配内存，并将这个栈帧压入栈中，运行完毕后，会释放内存，也就是弹出栈帧。\n当方法调用方法时，就会压入多个栈帧\n2.1 定义Java Virtual Machine Stacks\n\n每个线程运行时需要的内存，称为虚拟机栈\n每个栈由多个栈帧（Frame）祖传，对应着每次方法调用时所占用的内存，一般来说是局部变量\n每个线程只能由一个活动栈帧，对应着当前正在执行的那个方法，也就是目前栈顶的那个栈帧\n线程私有的，生命周期与线程相同\n栈中有局部变量表，存放了编译期可知的各种基本数据类型、对象引用（reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。\n\n问题辨析\n\n垃圾回收是否涉及栈内存？不涉及，栈内存只和方法有关，方法运行完毕后栈帧出栈，内存自动回收。\n\n栈内存分配越大越好吗？不是，内存分配得越大，线程就越少，因为物理内存是确定的，内存分配的越大，能更多次的进行方法递归。一般来说，默认的分配内存已经够用了。\n\n方法内的局部变量是否线程安全？\n是的，因为每个线程只对应一个虚拟机栈，和其他方法的线程是互不干扰的，本质上操作的局部变量完全没有关系，因此是线程安全的。但如果不是局部变量，而是静态变量，或者是方法参数、或者是局部变量作为返回值返回了，那么就线程不安全，因为这时不同线程操纵的变量是同一个变量了。\n简单来说，如果方法内局部变量没有逃离方法的作用范围，那么他就是线程安全的\n\n\n2.2 栈内存溢出   -Xss 栈内存分配大小命令\n   StackOverflowError\n\n栈帧过多导致栈内存溢出，如递归调用但没设置中止条件，或是出现了循环引用问题\n栈帧过大导致栈内存溢出\n\n2.3 实际演示在idea中，通过断点调试，我们可以观测到栈帧的存在运行如下代码\npublic class StackTest &#123;\n  public static int add(int a, int b) &#123;\n    return a + b;\n  &#125;\n\n  public static void main(String[] args) &#123;\n    add(1, 2);  &#x2F;&#x2F;在这句打断点\n  &#125;\n&#125;\n程序运行到断点处停止，我们看debugger窗口可以看得到Frames这个子窗口，这表示的就是栈帧的集合，也就是虚拟机栈，我们的程序在main方法中的add暂停，所以目前栈帧中只有一个main方法，我们运行到下一步看看可以看到main栈帧的上方有了add，这符合栈后进先出的特点，可以预见，如果addd中继续调用方法，那么add栈帧之上又会有新的栈帧。\n现在我们继续运行程序，让add方法运行完毕可以看到add的栈帧消失了，也就是add方法的运行内存被释放了。这个小demo可以看出栈帧扮演的角色和运行方式。\n3. 本地方法栈Native Method Stacks\n\n发挥的作用和虚拟机栈发挥的作用相似，区别只是本地方法栈执行本地方法，虚拟机栈执行Java方法\n\n本地方法：Native Method ，不是Java编写的代码，通常是操作系统自带的方法代码。\n\n本地方法栈为本地方法的运行提供内存空间\n\n在规范中对本地方法栈的实现方式（语言、数据结构）没有强制规定，具体的虚拟机可以自由的实现它，有的虚拟机（Sun HotSpot）甚至将本地方法栈和虚拟机栈合二为一\n\n\n4. 堆4.1定义Heap 堆\n\n通过new关键字，创建对象都会使用堆内存\n唯一目的就是存放对象实例，这一点在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配，但随着优化技术的产生，将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了\n可以细分为新生代和老年代，再细一点的有Eden空间、From Survivor空间、To Survivor空间等\n根据规范规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，实现时可以实现成固定大小或可扩展的，目前主流虚拟机都是可扩展的\n\n特点\n\n它是线程共享的，堆中对象都需要考虑线程安全的问题\n有垃圾回收机制\n对多数应用而言，堆是Java虚拟机所管理的内存中最大的一块\n在虚拟机启动时创建\n\n4.2 堆内存溢出-Xmx 堆内存分配大小命令\nOutOfMemoryError : Java heap space\n垃圾回收：没人用的对象，就作为垃圾被回收\n堆内存溢出：大量的对象被不断创建，同时一直被使用，可能导致堆内存溢出\n4.3 堆内存诊断在idea控制台窗口即可运行\n\njps工具\n查看当前系统中有哪些Java进程\n\n\njmap工具\n查看堆内存占用情况 ，不连续，只能查看某一时刻的情况\njmap -heap 进程id\n\n\njconsole\n图形界面，多功能检测工具，可连续监测\n\n\n\n案例：\n\n垃圾回收后，内存占用率仍然很高\n使用jvisualvm工具，通过堆dump功能查看对象在某一时刻的具体情况，从而做出诊断\n\n5. 方法区5.1 定义Method Area\n方法区是所有Java虚拟机线程共享的区域，它存储了与类结构相关的信息，如成员变量，方法数据，成员方法和构造器的代码部分，运行时常量池。\n方法区在虚拟机启动时就被创建，逻辑上它是堆的组成部分，但具体实现不同的jvm有所不同\n5.2 组成待补充\n5.3 方法区内存溢出-XX:MaxMetaspaceSize 设置元空间大小\nOutOfMemoryError:Metaspace\n\n1.8以前会导致永久代内存溢出\n1.8以后会导致元空间内存溢出\n\n5.4 运行时常量池\n常量池，就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息\n运行时常量池，常量池是 *.class 文件中的，当该类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址\n\n5.5 StringTable特性\n常量池中的字符串仅是符号，第一次用到时才变为对象\n利用串池的机制，来避免重复创建字符串对象\n字符串变量拼接的原理是StringBuilder（jdk1.8）\n字符串常量拼接的原理是编译期优化\n可以使用intern方法，主动将串池中还没有的字符串对象放入串池\n1.8中，将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池，会把串池中的对象返回\n1.6中，将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则会把此对象复制一份，再放入串池，会把串池中的对象返回\n\n\n\n5.6 StringTable位置\n1.8，StringTable在堆（Heap）中\n1.6，StringTable在永久代（PermGen）中\n\n5.7 StringTable垃圾回收5.8 StringTable性能调优\nStringTable本质上是哈希表，因此调优就是调整桶的个数，适当的把桶的个数调大，减少哈希碰撞   -XX:StringTableSize=桶个数\n考虑将字符串对象是否入池\n既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当量池无法再申请到内存时会抛出OutOfMemoryError异常。\n\n6. 直接内存6.1 定义Direct Memory\n\n常见于NIO（一种基于通道（Channel）与缓冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作）操作，用于数据缓存区\n分配回收成本较高，但读写性能高，因为避免了在Java堆和Native堆中来回复制数据\n不受JVM内存回收管理\n\n6.2 分配和回收原理\n使用了Unsafe对象完成直接内存的分配回收，并且回收需要主动调用的freeMemory方法\nByteBuffer的实现类内部，使用了Cleaner（虚引用）来检测ByteBuffer对象，一旦ByteBuffer对象被垃圾回收，那么就会有ReferenceHandler线程通过Cleaner的clean方法调用freeMemory来释放直接内存\n\n","slug":"JVM内存结构","date":"2021-08-12T02:01:18.000Z","categories_index":"技术学习","tags_index":"Java,JVM","author_index":"南望"},{"id":"809380e59300e634907b381d0433de40","title":"Springboot的自动装配原理浅析","content":"最近在学习Springboot，不少文章和视频在完成了第一个快速入门的项目之后就直接进入了Springboot运行的原理部分，因此决定写一篇文章加深理解。\n原理的理解主要使用了查看源码和画流程图的方式。\npom.xml对于一个maven项目，我们一般首要分析其pom文件，查看相关依赖。\n&lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;\n            &lt;scope&gt;test&lt;&#x2F;scope&gt;\n            &lt;exclusions&gt;\n                &lt;exclusion&gt;\n                    &lt;groupId&gt;org.junit.vintage&lt;&#x2F;groupId&gt;\n                    &lt;artifactId&gt;junit-vintage-engine&lt;&#x2F;artifactId&gt;\n                &lt;&#x2F;exclusion&gt;\n            &lt;&#x2F;exclusions&gt;\n        &lt;&#x2F;dependency&gt;\n    &lt;&#x2F;dependencies&gt;\n\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n                &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;\n            &lt;&#x2F;plugin&gt;\n        &lt;&#x2F;plugins&gt;\n    &lt;&#x2F;build&gt;\n可以看到依赖方面都是很简单的内容，加入了测试启动器和web启动器以及springboot的build插件，但我们发现了一个不一般的地方，他们都没有版本号！这是为什么呢？   我们往上查看，可以发现这样的父依赖。\n&lt;parent&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;2.3.4.RELEASE&lt;&#x2F;version&gt;\n        &lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;\n    &lt;&#x2F;parent&gt;\n   我们点进去查看，会发现。。。还有一层父依赖！    &lt;parent&gt;\n  &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;spring-boot-dependencies&lt;&#x2F;artifactId&gt;\n  &lt;version&gt;2.3.4.RELEASE&lt;&#x2F;version&gt;\n&lt;&#x2F;parent&gt;   继续点进去查看。\n&lt;properties&gt;\n    &lt;activemq.version&gt;5.15.13&lt;&#x2F;activemq.version&gt;\n    &lt;antlr2.version&gt;2.7.7&lt;&#x2F;antlr2.version&gt;\n    &lt;appengine-sdk.version&gt;1.9.82&lt;&#x2F;appengine-sdk.version&gt;\n    &lt;artemis.version&gt;2.12.0&lt;&#x2F;artemis.version&gt;\n    &lt;aspectj.version&gt;1.9.6&lt;&#x2F;aspectj.version&gt;\n    &lt;assertj.version&gt;3.16.1&lt;&#x2F;assertj.version&gt;\n    &lt;atomikos.version&gt;4.0.6&lt;&#x2F;atomikos.version&gt;\n    &lt;awaitility.version&gt;4.0.3&lt;&#x2F;awaitility.version&gt;\n    &lt;bitronix.version&gt;2.1.4&lt;&#x2F;bitronix.version&gt;\n    &lt;build-helper-maven-plugin.version&gt;3.1.0&lt;&#x2F;build-helper-maven-plugin.version&gt;\n    &lt;byte-buddy.version&gt;1.10.14&lt;&#x2F;byte-buddy.version&gt;\n    &lt;caffeine.version&gt;2.8.5&lt;&#x2F;caffeine.version&gt;\n    &lt;cassandra-driver.version&gt;4.6.1&lt;&#x2F;cassandra-driver.version&gt;\n    ...........\n这样的信息就是这些依赖尽头的主体了，这个文件有大量的配置信息，标注了每个可能用到的依赖的版本号，因此我们不用指定依赖的版本，springboot会根据你使用的版本自动给你安排合适的版本，再也不用担心依赖版本的冲突导致的崩溃啦！\n\npom.xml文件我们就说到这里，接下来才是重头戏了！\n\n思维导图：\n\t![在这里插入图片描述](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;20200929160256862.png#pic_center)\n\n### 启动类的@SpringBootApplication注解\n启动类包括两个重要的部分，一个是@SpringBootApplication注解，另一个是其中的run方法，我们先从这个注解开始说起。\n\n首先，这个注解的作用，猜也猜得到，是标注这个应用是一个springboot应用，这样springboot就可以帮我们对其进行自动配置，我们想要了解，spring boot是如何通过注解来自动装配的，装配了什么。\n\n老办法，查看源码，我点！\n&#96;&#96;&#96;java\n@Target(&#123;ElementType.TYPE&#125;)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@SpringBootConfiguration\n@EnableAutoConfiguration\n@ComponentScan\n以上是@SpringBootApplication注解之下的几个注解，出去那些基础的之外，我们可以看见三个特别显眼的，@SpringBootConfiguration，@ComponentScan，@EnableAutoConfiguration，我们逐个查看他们的源码。\n@SpringBootConfiguration他的源码：\n@Target(&#123;ElementType.TYPE&#125;)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Configuration\n乏善可陈。。。根据其下的@Configuration可以猜到，它是起到一个标注作用的注解，标志当前应用为一个springboot应用。\n我们回到上一层查看其他注解的源码。\n@ComponentScan这个更没啥好说的了，源码都没必要看了，他的作用是扫描指定包下的组件，将它们加载到Spring的IOC容器之中，很重要，但不是我们探究的重点。\n我们查看最后一个注解的源码。\n@EnableAutoConfiguration看得出来，他的作用是启用自动配置，我们重点关注如何启用，怎么启用，启用了什么。他的源码：\n@AutoConfigurationPackage\n@Import(&#123;AutoConfigurationImportSelector.class&#125;)\n看起来重要的注解就这两个，第一个看翻译是自动配置包，我们点进去查看他的源码：\n@Import(&#123;Registrar.class&#125;)\n噢，这是一个注册器，根据相关源码猜测是将bean注册导入到容器之中（若有错误希望指正）。\n我们回头，看看import导入的东西。\n自动配置导入选择器，我们猜测它是导入了需要的配置文件，查看源码：我这里截图还没有截全。。。我们发现其中有相当多的方法，我们的目的是查看如何加载组件的，因此寻找configuration相关的方法。\n找到了！getCandidateConfigurations，获取候选配置，这个方法中又使用了SpringFactoriesLoader，我们继续深入。public static final String FACTORIES_RESOURCE_LOCATION = &quot;META-INF/spring.factories&quot;;看到了看起来是文件的东西！我们使用全局搜索，发现它在springboot的jar包内，我们再点开来看看\n我们根据源头打开spring.factories ， 看到了很多自动配置的文件；这就是自动配置根源所在！可以随便点开看看，都可以看到这些一个个的都是JavaConfig配置类，而且都注入了一些Bean。\n至此，我们大概明白了Spring boot的自动装配原理了：\n自动配置真正实现是从classpath中搜寻所有的META-INF/spring.factories配置文件 ，并将其中对应的 org.springframework.boot.autoconfigure. 包下的配置项，通过反射实例化为对应标注了 @Configuration的JavaConfig形式的IOC容器配置类 ， 然后将这些都汇总成为一个实例并加载到IOC容器中。\n所以其实刚刚那一大串套娃注解其实都是为了拿到spring.factories。。。我不太懂设计模式，不太懂这样做的意义是什么样的哈哈哈。\n结论\nSpringBoot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值\n\n将这些值作为自动配置类导入容器 ， 自动配置类就生效 ， 帮我们进行自动配置工作；\n\n整个J2EE的整体解决方案和自动配置都在springboot-autoconfigure的jar包中；\n\n它会给容器中导入非常多的自动配置类 （xxxAutoConfiguration）, 就是给容器中导入这个场景需要的所有组件 ， 并配置好这些组件 ；\n\n有了自动配置类 ， 免去了我们手动编写配置注入功能组件等的工作；\n\n\n思维导图：\nrun方法分析该方法主要分两部分，一部分是SpringApplication的实例化，二是run方法的执行；SpringApplication\n这个类主要做了以下四件事情：\n1、推断应用的类型是普通的项目还是Web项目\n2、查找并加载所有可用初始化器 ， 设置到initializers属性中\n3、找出所有的应用程序监听器，设置到listeners属性中\n4、推断并设置main方法的定义类，找到运行的主类\n源码分析无力了。。。给大家一张图吧，说的很清楚了，大家可以跟着这张图自己读读源码。\n\n","slug":"Springboot的自动装配原理浅析","date":"2021-08-04T08:16:55.000Z","categories_index":"技术学习","tags_index":"Java,源码分析,SpringBoot","author_index":"南望"},{"id":"c26847ef99f42b8a854d63bbf2df96ed","title":"HotSpot虚拟机对象探秘","content":"HotSpot虚拟机对象探秘1. 对象的创建1.1 类加载检查虚拟机遇到new之后，首先会去常量池中找这个类的符号引用，并检查这个符号引用代表的类是否已经被加载、解析和初始化过，如果找到了，就可以根据已有的信息划分空间、分配内存、初始化等等；如果没找到，那必须先执行相应的类加载过程，类加载过程以后的笔记在详细说明。\n1.2 内存分配类加载检查通过之后，虚拟机将为新生对象分配内存，所需内存大小在类加载完成后就已经完全确定了，虚拟机要做的只是把一块确定大小的内存从Java堆中划分出来，怎么划分又要分两种情况看了。\n\n假设Java堆中内存时绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，那中间再放一个指针作为分界点指示器，那分配内存只要移动指针就完事了，这种分配方式被称为指针碰撞。\n假设内存并不是规整的，使用的内存和空闲的内存相互交错，这时候虚拟机得维护一个列表，记录那些内存块是空闲的，分配时就从列表里找到一个够大的空间分配给实例，并更新列表，这种分配方式被称为空闲列表。\n\n选择哪种方式由Java堆是否规整来决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。\n除了如何划分可用空间外，还有另外需要考虑的问题线程安全问题，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。解决这个问题有两种方案，一种是对分配内存空间的动作进行同步处理，另一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲（Thread Local Allocation Buffer,TLAB）\n1.3 初始化内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值，如果使用了TLAB，这一工作过程也可以提前至TLAB分配时进行，这一步保证了对象实例字段在Java代码中不初始化就可以直接使用，这也是Java默认初始值的原理。\n1.4 进行必要的设置虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头（Object Header）之中。根据虚拟机当前的运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。\n1.5 方法的执行虚拟机的眼中，新对象已经诞生，但是从Java程序的角度，还差最后一步，执行new指令之后会接着执行＜init＞方法，把对象按照程序员的意愿进行初始化，这样一个真正程序可用的对象才算完全产生出来。\n2. 对象的内存布局","slug":"HotSpot虚拟机对象探秘","date":"2021-08-12T02:55:37.000Z","categories_index":"技术学习","tags_index":"Java,JVM","author_index":"南望"},{"id":"ca5547898d7e053911493b82ed0cb0fa","title":"剑指 Offer 03. 数组中重复的数字的4种解法（Java语言）","content":"题目详情找出数组中重复的数字。\n在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。\n示例 1：\n输入：[2, 3, 1, 0, 2, 5, 3]输出：2 或 3 \n解法一：暴力法，双层循环直接进行两层循环，对每个数字都逐一比较，空间复杂度O(1)，时间复杂度O(n^2)，总的来说是下下策，执行用时吓死人Java代码\npublic int findRepeatNumber_1(int[] nums) &#123;\n    for (int i &#x3D; 0; i &lt; nums.length; i++)\n      for (int j &#x3D; i + 1; j &lt; nums.length; j++)\n        if (nums[i] &#x3D;&#x3D; nums[j])\n          return nums[i];\n    return -1;\n  &#125;\n解法二 排序后相邻的两两比较很容易想到的方法，排序后两两比较，空间复杂度O(1)，时间复杂度O(nlogn)，只能说是中下策，但执行用时已经有了相当的改善Java代码\npublic int findRepeatNumber_2(int[] nums) &#123;\n    Arrays.sort(nums);\n    for (int i &#x3D; 0; i &lt; nums.length - 1; i++) &#123;\n      if (nums[i] &#x3D;&#x3D; nums[i + 1])\n        return nums[i];\n    &#125;\n    return -1;\n  &#125;\n解法三 利用数组实现一个map映射首先，判断重复，常见的办法就是利用HashMap或是HashSet来判断，但我们观察数组发现，给定的值都是0~n-1，那么我们没必要使用集合类来加重负担，直接用数组就可以完成映射，给定的数组元素为键，出现次数为值。空间复杂度为O(n)，时间复杂度为O(n)，在大多数面试中已经算是可以让人接受的答案了。\npublic int findRepeatNumber_3(int[] nums) &#123;\n    int[] map &#x3D; new int[nums.length];\n    for (int i &#x3D; 0; i &lt; nums.length; i++) &#123;\n      if (map[nums[i]] &#x3D;&#x3D; 0)\n        map[nums[i]]++;\n      else\n        return nums[i];\n    &#125;\n    return -1;\n  &#125;\n解法四 利用重排后的元素碰撞解法三已经达到了空间时间复杂度都是O(n)的情况，实际上还能继续优化，达到O(1)的空间复杂度。我们知道，数组中的元素是0~n-1，那么可以想到，如果没有重复的元素，那么排序后，每个元素都应该和它的下标相同，那么如果有重复的元素，那么两个元素就会撞到一起。基于这种思路，我们设计如下算法：对每个元素都进行处理，把它交换到它应该在的位置，如果交换前发现那个位置上的元素和它相等，也就是撞车了，那么很明显这个元素就是重复的数字。每个数字只要进行交换就能找到自己的位置，时间复杂度是O(n)，且没有用到额外的空间，因此空间复杂度只有O(1)\n\npublic int findRepeatNumber_4(int[] nums) &#123;\n    for (int i &#x3D; 0; i &lt; nums.length; i++) &#123;\n      while (nums[i] !&#x3D; i) &#123;\n        &#x2F;&#x2F;两个数撞了\n        if (nums[i] &#x3D;&#x3D; nums[nums[i]]) &#123;\n          return nums[i];\n        &#125;\n        &#x2F;&#x2F;把一个数交换到它应该在的位置\n        int temp &#x3D; nums[nums[i]];\n        nums[nums[i]] &#x3D; nums[i];\n        nums[i] &#x3D; temp;\n      &#125;\n    &#125;\n    return -1;\n  &#125;\n","slug":"剑指 Offer 03. 数组中重复的数字的4种解法（Java语言）","date":"2021-08-04T08:20:41.000Z","categories_index":"技术学习","tags_index":"数据结构与算法,剑指Offer","author_index":"南望"},{"id":"3a69b8fada749b74d26a9663c4985507","title":"Java new ArrayList(int initialCapacity)初始化容量问题","content":"今天看了ArrayList源码，发现了一个不大不小的问题：\npublic ArrayList(int initialCapacity) &#123;\n        if (initialCapacity &gt; 0) &#123;\n            this.elementData &#x3D; new Object[initialCapacity];\n        &#125; else if (initialCapacity &#x3D;&#x3D; 0) &#123;\n            this.elementData &#x3D; EMPTY_ELEMENTDATA;\n        &#125; else &#123;\n            throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+\n                                               initialCapacity);\n        &#125;\n    &#125;\n\n这个构造函数咋一看问题不大，给elementData底层数组分配空间嘛，初始化数组的大小了但是实际使用时：\nArrayList&lt;Integer&gt; a &#x3D; new ArrayList(9);\na.set(1,5);\n抛出了IndexOutOfBoundsException\n结合源码：\npublic E set(int index, E element) &#123;\n        Objects.checkIndex(index, size);\n        E oldValue &#x3D; elementData(index);\n        elementData[index] &#x3D; element;\n        return oldValue;\n    &#125;\n其中第一行首先检测了下标，参数是index和size，而size是元素个数，也就是说，尽管设置了数组的容量，但针对ArrayList中元素的操作，是根据元素的位置，而不是根据容量来操作。也就是说，至少得有个元素才能set它，没有元素就是set个寂寞。\n因此set(1,5)在第一行直接抛出异常了\n综上所述ArrayList(int initialCapacity) 只是让ArrayList有了容纳 initialCapacity个元素的潜力，并不能对其中的“位置”操作。\nPS：这个问题在Java核心技术卷1中就有提到，但我当时直接忘了，果然看了源码才理解的透彻。\n","slug":"Java new ArrayList(int initialCapacity)初始化容量问题","date":"2021-08-04T07:35:13.000Z","categories_index":"技术学习","tags_index":"Java,源码分析","author_index":"南望"}]