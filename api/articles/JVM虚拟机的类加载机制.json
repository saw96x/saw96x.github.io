{"title":"JVM虚拟机的类加载机制","uid":"0ebc4600a20ae0476600d84a88d43c7f","slug":"JVM虚拟机的类加载机制","date":"2021-09-05T00:32:05.000Z","updated":"2021-09-19T01:25:45.321Z","comments":true,"path":"api/articles/JVM虚拟机的类加载机制.json","cover":"https://i.loli.net/2021/08/23/nc3P9ztCBIVS1m7.jpg","content":"<h1 id=\"JVM虚拟机的类加载机制\"><a href=\"#JVM虚拟机的类加载机制\" class=\"headerlink\" title=\"JVM虚拟机的类加载机制\"></a>JVM虚拟机的类加载机制</h1><p>JVM把描述类的数据从class文件中加载进内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。</p>\n<p>与Java类型相关的诸多工作都是在运行期完成的，这让Java的编译增加了额外的困难，也增加了性能开销，但是却为Java应用提供了极高的扩展性和灵活性，Java天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。</p>\n<h2 id=\"1-1-类加载的时机\"><a href=\"#1-1-类加载的时机\" class=\"headerlink\" title=\"1.1 类加载的时机\"></a>1.1 类加载的时机</h2><p>一个类从被加载到内存开始，到卸载处内存为止它的整个生命周期将会经历加载<br>（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）七个阶段，其中验证、准备、解析三个部分统称为连接（Linking）。</p>\n<p>其中，加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定特性（也称为动态绑定或晚期绑定）。</p>\n<p>而何时开始进行类加载，也就是第一阶段“加载”，JVM规范并没有进行强制约束。但是对于初始化阶段，《Java虚拟机规范》则是严格规定了有且只有六种情况必须立即对类进行“初始化”。</p>\n<ol>\n<li>遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。一般会生成这4条指令的场景有：使用new关键字实例化对象的时候，读取或设置一个类型的静态字段，调用一个类型的静态方法的时候。</li>\n<li>使用反射时，如果类型没有进行过初始化，则需要先触发其初始化。</li>\n<li>当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li>\n<li>虚拟机启动时，虚拟机会先初始化带main方法的那个类（主类）</li>\n<li>当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。</li>\n<li>当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li>\n</ol>\n<p>接口的加载过程与类加载过程稍有不同，针对接口需要做一些特殊说明：接口也有初始化过程，这点与类是一致的，接口与类真正有所区别的是前面讲述的六种“有且仅有”需要触发初始化场景中的第三种：当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。</p>\n<h2 id=\"1-2-类加载过程\"><a href=\"#1-2-类加载过程\" class=\"headerlink\" title=\"1.2 类加载过程\"></a>1.2 类加载过程</h2><h3 id=\"1-2-1-加载\"><a href=\"#1-2-1-加载\" class=\"headerlink\" title=\"1.2.1 加载\"></a>1.2.1 加载</h3><p>这个加载指的是“加载”（Loading）这一过程，在加载阶段，JVM需要完成下面这三件事：</p>\n<ol>\n<li>通过一个类的全限定名来获取定义此类的二进制字节流。</li>\n<li>将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。</li>\n<li>在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。</li>\n</ol>\n<p>规范只简单的给了要求，并未要求具体的实现，因此开发人员在上面玩出了各种花样，war包，jar包等等就是其产物。</p>\n<p>相对于类加载过程的其他阶段，非数组类型的加载阶段是开发人员可控性最强的阶段。对于数组类而言，情况就有所不同，数组类本身不通过类加载器创建，它是由Java虚拟机直接在内存中动态构造出来的，但是其元素类型还是要通过类加载器来加载，数组类创建遵循以下规则：</p>\n<ul>\n<li>如果元素是引用类型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组C将被标识在加载该组件类型的类加载器的类名称空间上。</li>\n<li>如果元素是基本类型，Java虚拟机将会把数组C标记为与引导类加载器关联。</li>\n<li>数组类的可访问性与它的组件类型的可访问性一致，如果组件类型不是引用类型，它的数组类的可访问性将默认为public，可被所有的类和接口访问到。</li>\n</ul>\n<p>加载阶段结束后，二进制字节流就按虚拟机设定的格式存储在方法区中，格式由虚拟机自己定义。类型数据妥善安置在方法区之后，会在Java堆内存中实例化一个java.lang.Class类的对象，这个对象将作为程序访问方法区中的类型数据的外部接口。</p>\n<p>加载阶段与连接阶段的部分动作（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的一部分，这两个阶段的开始时间仍然保持着固定的先后顺序。</p>\n<h3 id=\"1-2-2-验证\"><a href=\"#1-2-2-验证\" class=\"headerlink\" title=\"1.2.2 验证\"></a>1.2.2 验证</h3><p>这是连接阶段的第一步，目的是确保文件中的字节流符合约束，保证代码运行后不危害虚拟机自身安全。</p>\n<p>Java是相对安全的语言（相比C/C++），使用代码通常很难做出危害虚拟机的事，但Class文件并不一定只能由Java源码编译而来，它可以使用包括靠键盘0和1直接在二进制编辑器中敲出Class文件在内的任何途径产生。因此验证字节码是JVM保护自己的必要措施之一。</p>\n<p>由于验证阶段非常重要，同时从代码量和耗费的执行性能的角度上讲，验证阶段的工作量在虚拟机的类加载过程中占了相当大的比重，因此其约束和规则相当之多（JDK7之后），但从整体上看，验证阶段大致上会完成下面四个阶段的检验动作：文件格式验证、元数据验证、字节码验证和符号引用验证。</p>\n<ol>\n<li><p>文件格式验证</p>\n<p>这一阶段可能包含以下验证点：</p>\n<ul>\n<li>是否以魔数0xCAFEBABE开头。</li>\n<li>主、次版本号是否在当前Java虚拟机接受范围之内。</li>\n<li>常量池的常量中是否有不被支持的常量类型（检查常量tag标志）。</li>\n<li>······</li>\n</ul>\n<p>实际上第一阶段的验证点远不止此，这只是一小部分内容，该阶段的主要目的是保证输入的字节流能否正确地解析并存储于方法区之内，这阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证之后，这段字节流才被允许进入Java虚拟机内存的方法区中进行存储，所以后面的三个验证阶段全部是基于方法区的存储结构上进行的，不会再直接读取、操作字节流了。</p>\n</li>\n<li><p>元数据验证</p>\n<p>这一阶段是对字节码描述的信息进行语义分析，以保证信息符合规范要求，验证点可能包括：</p>\n<ul>\n<li>这个类是否有父类</li>\n<li>是否继承了不允许被继承的类</li>\n<li>字段和方法是否与父类产生了矛盾</li>\n<li>······</li>\n</ul>\n</li>\n<li><p>字节码验证</p>\n<p>这是最复杂的阶段，主要目的是通过数据流分析和控制流分析，确定<br>程序语义是合法的、符合逻辑的。这阶段对类的方法提（Code属性)进行校验分析，保证方法不出现危险行为，如：</p>\n<ul>\n<li>保证保证任何跳转指令都不会跳转到方法体以外的字节码指令上。</li>\n<li>保证类型转换总是有效的。</li>\n<li>······</li>\n</ul>\n<p>如果一个方法体通过了字节码验证，仍然不能保证它一定就是安全的，因为不能通过程序准确地检查出程序是否能在有限的时间之内结束运行。</p>\n</li>\n<li><p>符号引用验证</p>\n</li>\n</ol>\n","feature":true,"text":"JVM虚拟机的类加载机制JVM把描述类的数据从class文件中加载进内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。 与Java类型相关的诸多工作都是在运行期完成的，这让Java的编译增加了额外的困难，也增加...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"技术笔记","slug":"技术笔记","count":6,"path":"api/categories/技术笔记.json"}],"tags":[{"name":"Java","slug":"Java","count":8,"path":"api/tags/Java.json"},{"name":"JVM","slug":"JVM","count":6,"path":"api/tags/JVM.json"},{"name":"深入理解Java虚拟机","slug":"深入理解Java虚拟机","count":6,"path":"api/tags/深入理解Java虚拟机.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#JVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%9A%84%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">JVM虚拟机的类加载机制</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-1-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E7%9A%84%E6%97%B6%E6%9C%BA\"><span class=\"toc-text\">1.1 类加载的时机</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-2-%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">1.2 类加载过程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-1-%E5%8A%A0%E8%BD%BD\"><span class=\"toc-text\">1.2.1 加载</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-2-%E9%AA%8C%E8%AF%81\"><span class=\"toc-text\">1.2.2 验证</span></a></li></ol></li></ol></li></ol>","author":{"name":"南望","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/db609a2e507d4a36b32e06b4676aad38.PNG","link":"/","description":"路漫漫其修远兮，吾将上下而求索······","socials":{"github":"https://github.com/saw96x","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/saw96x","csdn":"https://blog.csdn.net/saw96x?spm=1001.2101.3001.5343","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"LeetCode中经典的链表题","uid":"367463c88a16078125a84825dd49eab4","slug":"LeetCode中经典的链表题","date":"2021-11-22T02:39:39.000Z","updated":"2021-11-24T08:08:44.137Z","comments":true,"path":"api/articles/LeetCode中经典的链表题.json","cover":"https://i.loli.net/2021/08/23/z1OTKikv4DnZftY.jpg","text":"1. 两数相加（LC第2题）给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。 请你将两个数相加，并以相同形式返回一个表示和的链表。 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例 1： 输入...","link":"","photos":[],"count_time":{"symbolsCount":"6.8k","symbolsTime":"6 mins."},"categories":[{"name":"算法笔记","slug":"算法笔记","count":5,"path":"api/categories/算法笔记.json"}],"tags":[{"name":"LeetCode","slug":"LeetCode","count":3,"path":"api/tags/LeetCode.json"},{"name":"数据结构与算法","slug":"数据结构与算法","count":5,"path":"api/tags/数据结构与算法.json"}],"author":{"name":"南望","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/db609a2e507d4a36b32e06b4676aad38.PNG","link":"/","description":"路漫漫其修远兮，吾将上下而求索······","socials":{"github":"https://github.com/saw96x","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/saw96x","csdn":"https://blog.csdn.net/saw96x?spm=1001.2101.3001.5343","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"LeetCode中经典的栈题","uid":"6fa34a15afbc4ab69f0c778771db54cc","slug":"LeetCode中经典的栈题","date":"2021-11-24T02:29:29.000Z","updated":"2021-11-24T08:04:41.836Z","comments":true,"path":"api/articles/LeetCode中经典的栈题.json","cover":null,"text":"1. 有效的括号（LC第20题）给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;&#123;&#39;，&#39;&#125;&#39;，&#39;[&#39;，&#39;]&#39; 的字符串 s ，判断字符串是否有效。 有效字符串需满足： 左括号必须...","link":"","photos":[],"count_time":{"symbolsCount":"4.9k","symbolsTime":"4 mins."},"categories":[{"name":"算法笔记","slug":"算法笔记","count":5,"path":"api/categories/算法笔记.json"}],"tags":[{"name":"LeetCode","slug":"LeetCode","count":3,"path":"api/tags/LeetCode.json"},{"name":"数据结构与算法","slug":"数据结构与算法","count":5,"path":"api/tags/数据结构与算法.json"}],"author":{"name":"南望","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/db609a2e507d4a36b32e06b4676aad38.PNG","link":"/","description":"路漫漫其修远兮，吾将上下而求索······","socials":{"github":"https://github.com/saw96x","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/saw96x","csdn":"https://blog.csdn.net/saw96x?spm=1001.2101.3001.5343","juejin":"","customs":{}}},"feature":false}}