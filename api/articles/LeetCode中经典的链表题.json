{"title":"LeetCode中经典的链表题","uid":"367463c88a16078125a84825dd49eab4","slug":"LeetCode中经典的链表题","date":"2021-11-22T02:39:39.000Z","updated":"2021-11-22T02:57:45.774Z","comments":true,"path":"api/articles/LeetCode中经典的链表题.json","cover":"https://i.loli.net/2021/08/23/z1OTKikv4DnZftY.jpg","content":"<h2 id=\"1-两数相加（LC第二题）\"><a href=\"#1-两数相加（LC第二题）\" class=\"headerlink\" title=\"1. 两数相加（LC第二题）\"></a><a href=\"https://leetcode-cn.com/problems/add-two-numbers/\">1. 两数相加（LC第二题）</a></h2><p>给你两个 <strong>非空</strong> 的链表，表示两个非负的整数。它们每位数字都是按照 <strong>逆序</strong> 的方式存储的，并且每个节点只能存储 <strong>一位</strong> 数字。</p>\n<p>请你将两个数相加，并以相同形式返回一个表示和的链表。</p>\n<p>你可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg\" alt=\"img\"></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">输入：l1 &#x3D; [2,4,3], l2 &#x3D; [5,6,4]\n输出：[7,0,8]\n解释：342 + 465 &#x3D; 807.<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">输入：l1 &#x3D; [0], l2 &#x3D; [0]\n输出：[0]<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">输入：l1 &#x3D; [9,9,9,9,9,9,9], l2 &#x3D; [9,9,9,9]\n输出：[8,9,9,9,0,0,0,1]<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>每个链表中的节点数在范围 <code>[1, 100]</code> 内</li>\n<li><code>0 &lt;= Node.val &lt;= 9</code></li>\n<li>题目数据保证列表表示的数字不含前导零</li>\n</ul>\n<p>本题思路很正常，主要的难点在于各种细节的处理。直接看代码上的注释。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;\n  &#x2F;&#x2F;设置哑节点\n  ListNode dummy &#x3D; new ListNode(0);\n  &#x2F;&#x2F;curr为当前两个链表节点值相加的结果的新节点\n  ListNode p1 &#x3D; l1, p2 &#x3D; l2, curr &#x3D; dummy;\n  &#x2F;&#x2F;进位\n  int carry &#x3D; 0;\n  while (p1 !&#x3D; null || p2 !&#x3D; null) &#123;\n    int x &#x3D; (p1 !&#x3D; null) ? p1.val : 0;\n    int y &#x3D; (p2 !&#x3D; null) ? p2.val : 0;\n    &#x2F;&#x2F;当前节点值相加的结果还要加上进位\n    int sum &#x3D; carry + x + y;\n    &#x2F;&#x2F;本次相加产生的进位\n    carry &#x3D; sum &#x2F; 10;\n    &#x2F;&#x2F;本级相加的结果对10取余数\n    curr.next &#x3D; new ListNode(sum % 10);\n    &#x2F;&#x2F;移动节点\n    curr &#x3D; curr.next;\n    if (p1 !&#x3D; null)\n      p1 &#x3D; p1.next;\n    if (p2 !&#x3D; null)\n      p2 &#x3D; p2.next;\n  &#125;\n  &#x2F;&#x2F;最高位有进位还要补上\n  if (carry &gt; 0)\n    curr.next &#x3D; new ListNode(carry);\n  return dummy.next;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>本题的几个重点：</p>\n<ol>\n<li>注意对进位的处理，首先，当前节点值相加还要加上上一次相加带来的进位。其次，本次产生的进位直接用sum/10得到，不用if分类讨论，而本次相加的结果则对10取余数即可。</li>\n<li>当全部加完之后，最高位可能也有进位，要记得补上。</li>\n<li>使用哑节点避免出现空指针的情况。</li>\n</ol>\n","feature":true,"text":"1. 两数相加（LC第二题）给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。 请你将两个数相加，并以相同形式返回一个表示和的链表。 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例 1： 输入...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"算法笔记","slug":"算法笔记","count":3,"path":"api/categories/算法笔记.json"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","count":3,"path":"api/tags/数据结构与算法.json"},{"name":"LeetCode","slug":"LeetCode","count":1,"path":"api/tags/LeetCode.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0%EF%BC%88LC%E7%AC%AC%E4%BA%8C%E9%A2%98%EF%BC%89\"><span class=\"toc-text\">1. 两数相加（LC第二题）</span></a></li></ol>","author":{"name":"南望","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/db609a2e507d4a36b32e06b4676aad38.PNG","link":"/","description":"路漫漫其修远兮，吾将上下而求索······","socials":{"github":"https://github.com/saw96x","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/saw96x","csdn":"https://blog.csdn.net/saw96x?spm=1001.2101.3001.5343","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"JVM虚拟机的类加载机制","uid":"0ebc4600a20ae0476600d84a88d43c7f","slug":"JVM虚拟机的类加载机制","date":"2021-09-05T00:32:05.000Z","updated":"2021-09-19T01:25:45.321Z","comments":true,"path":"api/articles/JVM虚拟机的类加载机制.json","cover":"https://i.loli.net/2021/08/23/nc3P9ztCBIVS1m7.jpg","text":"JVM虚拟机的类加载机制JVM把描述类的数据从class文件中加载进内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。 与Java类型相关的诸多工作都是在运行期完成的，这让Java的编译增加了额外的困难，也增加...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"技术笔记","slug":"技术笔记","count":6,"path":"api/categories/技术笔记.json"}],"tags":[{"name":"Java","slug":"Java","count":8,"path":"api/tags/Java.json"},{"name":"JVM","slug":"JVM","count":6,"path":"api/tags/JVM.json"},{"name":"深入理解Java虚拟机","slug":"深入理解Java虚拟机","count":6,"path":"api/tags/深入理解Java虚拟机.json"}],"author":{"name":"南望","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/db609a2e507d4a36b32e06b4676aad38.PNG","link":"/","description":"路漫漫其修远兮，吾将上下而求索······","socials":{"github":"https://github.com/saw96x","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/saw96x","csdn":"https://blog.csdn.net/saw96x?spm=1001.2101.3001.5343","juejin":"","customs":{}}},"feature":true}}