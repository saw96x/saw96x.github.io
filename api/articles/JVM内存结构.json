{"title":"JVM内存结构","uid":"f0feb27731f09def8e6fa03e806c3c89","slug":"JVM内存结构","date":"2021-08-06T06:55:18.000Z","updated":"2021-08-06T13:47:31.169Z","comments":true,"path":"api/articles/JVM内存结构.json","cover":"https://img-blog.csdnimg.cn/894fb565727048428c86ad9706a6948b.jpg","content":"<p>本篇笔记不定期更新</p>\n<h2 id=\"内存结构图\"><a href=\"#内存结构图\" class=\"headerlink\" title=\"内存结构图\"></a>内存结构图</h2><p>先上图<br><img src=\"https://img-blog.csdnimg.cn/bf995bbfbfcc4629ab3ef9f83c78d099.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhdzk2eA==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"><br>这张图差不多就把JVM的内存结构以及和class源文件，JVM执行引擎，以及操作系统自带的本地方法接口之间的关系囊括进去了。</p>\n<p>下面我们就JVM内存结构的几个组成部分来逐一简单介绍一下</p>\n<h2 id=\"1-程序计数器\"><a href=\"#1-程序计数器\" class=\"headerlink\" title=\"1. 程序计数器\"></a>1. 程序计数器</h2><h3 id=\"1-1-定义\"><a href=\"#1-1-定义\" class=\"headerlink\" title=\"1.1 定义\"></a>1.1 定义</h3><p>Program Counter Register 程序计数器（寄存器）</p>\n<h3 id=\"1-2-作用\"><a href=\"#1-2-作用\" class=\"headerlink\" title=\"1.2 作用\"></a>1.2 作用</h3><ol>\n<li>在执行当前指令时，记住下一条JVM指令的执行地址，所以PCR也被称为寄存器，在物理上通过CPU寄存器实现</li>\n<li>在多线程程序中起到一个记录上下文的作用，方便切换线程时可以继续运行</li>\n</ol>\n<h3 id=\"1-3-特点\"><a href=\"#1-3-特点\" class=\"headerlink\" title=\"1.3 特点\"></a>1.3 特点</h3><ul>\n<li>Java支持多线程，而PCR是线程私有的，每个线程都有自己的PCR</li>\n<li>不会存在内存溢出</li>\n</ul>\n<h2 id=\"2-虚拟机栈\"><a href=\"#2-虚拟机栈\" class=\"headerlink\" title=\"2. 虚拟机栈\"></a>2. 虚拟机栈</h2><p>栈–线程运行需要的内存空间，由栈帧组成，栈帧看为栈内的元素</p>\n<p>栈帧–每个方法运行时所需要的内存，参数，局部变量，返回地址等等····</p>\n<p>当调用某个方法时，会给栈帧分配内存，并将这个栈帧压入栈中，运行完毕后，会释放内存，也就是弹出栈帧。</p>\n<p>当方法调用方法时，就会压入多个栈帧</p>\n<h3 id=\"2-1-定义\"><a href=\"#2-1-定义\" class=\"headerlink\" title=\"2.1 定义\"></a>2.1 定义</h3><p>Java Virtual Machine Stacks</p>\n<ul>\n<li>每个线程运行时需要的内存，称为虚拟机栈</li>\n<li>每个栈由多个栈帧（Frame）祖传，对应着每次方法调用时所占用的内存，一般来说是局部变量</li>\n<li>每个线程只能由一个活动栈帧，对应着当前正在执行的那个方法，也就是目前栈顶的那个栈帧</li>\n</ul>\n<p>问题辨析</p>\n<ol>\n<li><p>垃圾回收是否涉及栈内存？不涉及，栈内存只和方法有关，方法运行完毕后栈帧出栈，内存自动回收。</p>\n</li>\n<li><p>栈内存分配越大越好吗？不是，内存分配得越大，线程就越少，因为物理内存是确定的，内存分配的越大，能更多次的进行方法递归。一般来说，默认的分配内存已经够用了。</p>\n</li>\n<li><p>方法内的局部变量是否线程安全？</p>\n<p>是的，因为每个线程只对应一个虚拟机栈，和其他方法的线程是互不干扰的，本质上操作的局部变量完全没有关系，因此是线程安全的。但如果不是局部变量，而是静态变量，或者是方法参数、或者是局部变量作为返回值返回了，那么就线程不安全，因为这时不同线程操纵的变量是同一个变量了。</p>\n<p>简单来说，如果方法内局部变量没有逃离方法的作用范围，那么他就是线程安全的</p>\n</li>\n</ol>\n<h3 id=\"2-2-栈内存溢出\"><a href=\"#2-2-栈内存溢出\" class=\"headerlink\" title=\"2.2 栈内存溢出\"></a>2.2 栈内存溢出</h3><p>   -Xss 栈内存分配大小命令</p>\n<p>   StackOverflowError</p>\n<ul>\n<li>栈帧过多导致栈内存溢出，如递归调用但没设置中止条件，或是出现了循环引用问题</li>\n<li>栈帧过大导致栈内存溢出</li>\n</ul>\n<h3 id=\"2-3-实际演示\"><a href=\"#2-3-实际演示\" class=\"headerlink\" title=\"2.3 实际演示\"></a>2.3 实际演示</h3><p>在idea中，通过断点调试，我们可以观测到栈帧的存在<br>运行如下代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">StackTest</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">return</span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">&#125;</span>\n\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//在这句打断点</span>\n  <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>程序运行到断点处停止，我们看debugger窗口<br><img src=\"https://img-blog.csdnimg.cn/bd5113f93e4b4afead467b0d2084cc8c.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhdzk2eA==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"><br>可以看得到Frames这个子窗口，这表示的就是栈帧的集合，也就是虚拟机栈，我们的程序在main方法中的add暂停，所以目前栈帧中只有一个main方法，我们运行到下一步看看<br><img src=\"https://img-blog.csdnimg.cn/52e00e7f2a634217ba041a3cb4d6d410.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhdzk2eA==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"><br>可以看到main栈帧的上方有了add，这符合栈后进先出的特点，可以预见，如果addd中继续调用方法，那么add栈帧之上又会有新的栈帧。</p>\n<p>现在我们继续运行程序，让add方法运行完毕<br><img src=\"https://img-blog.csdnimg.cn/d94890ad9d104242b18f54d08027e2bd.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhdzk2eA==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"><br>可以看到add的栈帧消失了，也就是add方法的运行内存被释放了。<br>这个小demo可以看出栈帧扮演的角色和运行方式。</p>\n","feature":true,"text":"本篇笔记不定期更新 内存结构图先上图这张图差不多就把JVM的内存结构以及和class源文件，JVM执行引擎，以及操作系统自带的本地方法接口之间的关系囊括进去了。 下面我们就JVM内存结构的几个组成部分来逐一简单介绍一下 1. 程序计数器1.1 定义Program Counter ...","link":"","photos":[],"count_time":{"symbolsCount":"1.5k","symbolsTime":"1 mins."},"categories":[{"name":"技术学习","slug":"技术学习","count":4,"path":"api/categories/技术学习.json"}],"tags":[{"name":"Java","slug":"Java","count":3,"path":"api/tags/Java.json"},{"name":"JVM","slug":"JVM","count":1,"path":"api/tags/JVM.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%9B%BE\"><span class=\"toc-text\">内存结构图</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8\"><span class=\"toc-text\">1. 程序计数器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">1.1 定义</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">1.2 作用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-3-%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">1.3 特点</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88\"><span class=\"toc-text\">2. 虚拟机栈</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">2.1 定义</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-%E6%A0%88%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA\"><span class=\"toc-text\">2.2 栈内存溢出</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3-%E5%AE%9E%E9%99%85%E6%BC%94%E7%A4%BA\"><span class=\"toc-text\">2.3 实际演示</span></a></li></ol></li></ol>","author":{"name":"南望","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/db609a2e507d4a36b32e06b4676aad38.PNG","link":"/","description":"路漫漫其修远兮，吾将上下而求索······","socials":{"github":"https://github.com/saw96x","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/saw96x","csdn":"https://blog.csdn.net/saw96x?spm=1001.2101.3001.5343","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"剑指 Offer 03. 数组中重复的数字的4种解法（Java语言）","uid":"ca5547898d7e053911493b82ed0cb0fa","slug":"剑指 Offer 03. 数组中重复的数字的4种解法（Java语言）","date":"2021-08-04T08:20:41.000Z","updated":"2021-08-06T13:49:19.956Z","comments":true,"path":"api/articles/剑指 Offer 03. 数组中重复的数字的4种解法（Java语言）.json","cover":"https://img-blog.csdnimg.cn/ee9bd76864244e9484ab4ed291062b32.jpg","text":"题目详情找出数组中重复的数字。 在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。 示例 1： 输入：[2, 3, 1, 0, 2, 5, 3]...","link":"","photos":[],"count_time":{"symbolsCount":"1.9k","symbolsTime":"2 mins."},"categories":[{"name":"技术学习","slug":"技术学习","count":4,"path":"api/categories/技术学习.json"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","count":1,"path":"api/tags/数据结构与算法.json"},{"name":"剑指Offer","slug":"剑指Offer","count":1,"path":"api/tags/剑指Offer.json"}],"author":{"name":"南望","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/db609a2e507d4a36b32e06b4676aad38.PNG","link":"/","description":"路漫漫其修远兮，吾将上下而求索······","socials":{"github":"https://github.com/saw96x","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/saw96x","csdn":"https://blog.csdn.net/saw96x?spm=1001.2101.3001.5343","juejin":"","customs":{}}},"feature":true}}