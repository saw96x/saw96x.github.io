{"title":"JVM内存结构","uid":"f0feb27731f09def8e6fa03e806c3c89","slug":"JVM内存结构","date":"2021-08-12T02:01:18.000Z","updated":"2021-08-12T02:01:08.366Z","comments":true,"path":"api/articles/JVM内存结构.json","cover":"https://img-blog.csdnimg.cn/894fb565727048428c86ad9706a6948b.jpg","content":"<p>本篇笔记不定期更新</p>\n<h2 id=\"内存结构图\"><a href=\"#内存结构图\" class=\"headerlink\" title=\"内存结构图\"></a>内存结构图</h2><p>先上图<br><img src=\"https://img-blog.csdnimg.cn/bf995bbfbfcc4629ab3ef9f83c78d099.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhdzk2eA==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"><br>这张图差不多就把JVM的内存结构以及和class源文件，JVM执行引擎，以及操作系统自带的本地方法接口之间的关系囊括进去了。</p>\n<p>下面我们就JVM内存结构的几个组成部分来逐一简单介绍一下</p>\n<h2 id=\"1-程序计数器\"><a href=\"#1-程序计数器\" class=\"headerlink\" title=\"1. 程序计数器\"></a>1. 程序计数器</h2><h3 id=\"1-1-定义\"><a href=\"#1-1-定义\" class=\"headerlink\" title=\"1.1 定义\"></a>1.1 定义</h3><p>Program Counter Register 程序计数器（寄存器）</p>\n<h3 id=\"1-2-作用\"><a href=\"#1-2-作用\" class=\"headerlink\" title=\"1.2 作用\"></a>1.2 作用</h3><ol>\n<li>在执行当前指令时，记住下一条JVM指令的执行地址，所以PCR也被称为寄存器，在物理上通过CPU寄存器实现</li>\n<li>在多线程程序中起到一个记录上下文的作用，方便切换线程时可以继续运行</li>\n<li>字节码解释器通过改变PCR的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要PCR来完成</li>\n<li>如果线程正在执行Java方法，那么PCR记录的市正在执行的虚拟机字节码指令的地址，如果正在执行的是Native方法，这个计数器值则为空（Undefined）</li>\n</ol>\n<h3 id=\"1-3-特点\"><a href=\"#1-3-特点\" class=\"headerlink\" title=\"1.3 特点\"></a>1.3 特点</h3><ul>\n<li>Java支持多线程，而PCR是线程私有的，每个线程都有自己的PCR</li>\n<li>不会存在内存溢出此内存区域，是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域</li>\n<li>生命周期与线程相同</li>\n</ul>\n<h2 id=\"2-虚拟机栈\"><a href=\"#2-虚拟机栈\" class=\"headerlink\" title=\"2. 虚拟机栈\"></a>2. 虚拟机栈</h2><p>栈–线程运行需要的内存空间，由栈帧组成，栈帧看为栈内的元素</p>\n<p>栈帧–每个方法运行时所需要的内存，参数，局部变量，返回地址等等····</p>\n<p>当调用某个方法时，会给栈帧分配内存，并将这个栈帧压入栈中，运行完毕后，会释放内存，也就是弹出栈帧。</p>\n<p>当方法调用方法时，就会压入多个栈帧</p>\n<h3 id=\"2-1-定义\"><a href=\"#2-1-定义\" class=\"headerlink\" title=\"2.1 定义\"></a>2.1 定义</h3><p>Java Virtual Machine Stacks</p>\n<ul>\n<li>每个线程运行时需要的内存，称为虚拟机栈</li>\n<li>每个栈由多个栈帧（Frame）祖传，对应着每次方法调用时所占用的内存，一般来说是局部变量</li>\n<li>每个线程只能由一个活动栈帧，对应着当前正在执行的那个方法，也就是目前栈顶的那个栈帧</li>\n<li>线程私有的，生命周期与线程相同</li>\n<li>栈中有局部变量表，存放了编译期可知的各种基本数据类型、对象引用（reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。</li>\n</ul>\n<p>问题辨析</p>\n<ol>\n<li><p>垃圾回收是否涉及栈内存？不涉及，栈内存只和方法有关，方法运行完毕后栈帧出栈，内存自动回收。</p>\n</li>\n<li><p>栈内存分配越大越好吗？不是，内存分配得越大，线程就越少，因为物理内存是确定的，内存分配的越大，能更多次的进行方法递归。一般来说，默认的分配内存已经够用了。</p>\n</li>\n<li><p>方法内的局部变量是否线程安全？</p>\n<p>是的，因为每个线程只对应一个虚拟机栈，和其他方法的线程是互不干扰的，本质上操作的局部变量完全没有关系，因此是线程安全的。但如果不是局部变量，而是静态变量，或者是方法参数、或者是局部变量作为返回值返回了，那么就线程不安全，因为这时不同线程操纵的变量是同一个变量了。</p>\n<p>简单来说，如果方法内局部变量没有逃离方法的作用范围，那么他就是线程安全的</p>\n</li>\n</ol>\n<h3 id=\"2-2-栈内存溢出\"><a href=\"#2-2-栈内存溢出\" class=\"headerlink\" title=\"2.2 栈内存溢出\"></a>2.2 栈内存溢出</h3><p>   -Xss 栈内存分配大小命令</p>\n<p>   StackOverflowError</p>\n<ul>\n<li>栈帧过多导致栈内存溢出，如递归调用但没设置中止条件，或是出现了循环引用问题</li>\n<li>栈帧过大导致栈内存溢出</li>\n</ul>\n<h3 id=\"2-3-实际演示\"><a href=\"#2-3-实际演示\" class=\"headerlink\" title=\"2.3 实际演示\"></a>2.3 实际演示</h3><p>在idea中，通过断点调试，我们可以观测到栈帧的存在<br>运行如下代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class StackTest &#123;\n  public static int add(int a, int b) &#123;\n    return a + b;\n  &#125;\n\n  public static void main(String[] args) &#123;\n    add(1, 2);  &#x2F;&#x2F;在这句打断点\n  &#125;\n&#125;</code></pre>\n<p>程序运行到断点处停止，我们看debugger窗口<br><img src=\"https://img-blog.csdnimg.cn/bd5113f93e4b4afead467b0d2084cc8c.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhdzk2eA==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"><br>可以看得到Frames这个子窗口，这表示的就是栈帧的集合，也就是虚拟机栈，我们的程序在main方法中的add暂停，所以目前栈帧中只有一个main方法，我们运行到下一步看看<br><img src=\"https://img-blog.csdnimg.cn/52e00e7f2a634217ba041a3cb4d6d410.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhdzk2eA==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"><br>可以看到main栈帧的上方有了add，这符合栈后进先出的特点，可以预见，如果addd中继续调用方法，那么add栈帧之上又会有新的栈帧。</p>\n<p>现在我们继续运行程序，让add方法运行完毕<br><img src=\"https://img-blog.csdnimg.cn/d94890ad9d104242b18f54d08027e2bd.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhdzk2eA==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"><br>可以看到add的栈帧消失了，也就是add方法的运行内存被释放了。<br>这个小demo可以看出栈帧扮演的角色和运行方式。</p>\n<h2 id=\"3-本地方法栈\"><a href=\"#3-本地方法栈\" class=\"headerlink\" title=\"3. 本地方法栈\"></a>3. 本地方法栈</h2><p>Native Method Stacks</p>\n<ul>\n<li><p>发挥的作用和虚拟机栈发挥的作用相似，区别只是本地方法栈执行本地方法，虚拟机栈执行Java方法</p>\n</li>\n<li><p>本地方法：Native Method ，不是Java编写的代码，通常是操作系统自带的方法代码。</p>\n</li>\n<li><p>本地方法栈为本地方法的运行提供内存空间</p>\n</li>\n<li><p>在规范中对本地方法栈的实现方式（语言、数据结构）没有强制规定，具体的虚拟机可以自由的实现它，有的虚拟机（Sun HotSpot）甚至将本地方法栈和虚拟机栈合二为一</p>\n</li>\n</ul>\n<h2 id=\"4-堆\"><a href=\"#4-堆\" class=\"headerlink\" title=\"4. 堆\"></a>4. 堆</h2><h3 id=\"4-1定义\"><a href=\"#4-1定义\" class=\"headerlink\" title=\"4.1定义\"></a>4.1定义</h3><p>Heap 堆</p>\n<ul>\n<li>通过new关键字，创建对象都会使用堆内存</li>\n<li>唯一目的就是存放对象实例，这一点在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配，但随着优化技术的产生，将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了</li>\n<li>可以细分为新生代和老年代，再细一点的有Eden空间、From Survivor空间、To Survivor空间等</li>\n<li>根据规范规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，实现时可以实现成固定大小或可扩展的，目前主流虚拟机都是可扩展的</li>\n</ul>\n<p>特点</p>\n<ul>\n<li>它是线程共享的，堆中对象都需要考虑线程安全的问题</li>\n<li>有垃圾回收机制</li>\n<li>对多数应用而言，堆是Java虚拟机所管理的内存中最大的一块</li>\n<li>在虚拟机启动时创建</li>\n</ul>\n<h3 id=\"4-2-堆内存溢出\"><a href=\"#4-2-堆内存溢出\" class=\"headerlink\" title=\"4.2 堆内存溢出\"></a>4.2 堆内存溢出</h3><p>-Xmx 堆内存分配大小命令</p>\n<p>OutOfMemoryError : Java heap space</p>\n<p>垃圾回收：没人用的对象，就作为垃圾被回收</p>\n<p>堆内存溢出：大量的对象被不断创建，同时一直被使用，可能导致堆内存溢出</p>\n<h3 id=\"4-3-堆内存诊断\"><a href=\"#4-3-堆内存诊断\" class=\"headerlink\" title=\"4.3 堆内存诊断\"></a>4.3 堆内存诊断</h3><p>在idea控制台窗口即可运行</p>\n<ol>\n<li>jps工具<ul>\n<li>查看当前系统中有哪些Java进程</li>\n</ul>\n</li>\n<li>jmap工具<ul>\n<li>查看堆内存占用情况 ，不连续，只能查看某一时刻的情况</li>\n<li>jmap -heap 进程id</li>\n</ul>\n</li>\n<li>jconsole<ul>\n<li>图形界面，多功能检测工具，可连续监测</li>\n</ul>\n</li>\n</ol>\n<p>案例：</p>\n<ul>\n<li>垃圾回收后，内存占用率仍然很高</li>\n<li>使用jvisualvm工具，通过堆dump功能查看对象在某一时刻的具体情况，从而做出诊断</li>\n</ul>\n<h2 id=\"5-方法区\"><a href=\"#5-方法区\" class=\"headerlink\" title=\"5. 方法区\"></a>5. 方法区</h2><h3 id=\"5-1-定义\"><a href=\"#5-1-定义\" class=\"headerlink\" title=\"5.1 定义\"></a>5.1 定义</h3><p>Method Area</p>\n<p>方法区是所有Java虚拟机线程共享的区域，它存储了与类结构相关的信息，如成员变量，方法数据，成员方法和构造器的代码部分，运行时常量池。</p>\n<p>方法区在虚拟机启动时就被创建，逻辑上它是堆的组成部分，但具体实现不同的jvm有所不同</p>\n<h3 id=\"5-2-组成\"><a href=\"#5-2-组成\" class=\"headerlink\" title=\"5.2 组成\"></a>5.2 组成</h3><p>待补充</p>\n<h3 id=\"5-3-方法区内存溢出\"><a href=\"#5-3-方法区内存溢出\" class=\"headerlink\" title=\"5.3 方法区内存溢出\"></a>5.3 方法区内存溢出</h3><p>-XX:MaxMetaspaceSize 设置元空间大小</p>\n<p>OutOfMemoryError:Metaspace</p>\n<ul>\n<li>1.8以前会导致永久代内存溢出</li>\n<li>1.8以后会导致元空间内存溢出</li>\n</ul>\n<h3 id=\"5-4-运行时常量池\"><a href=\"#5-4-运行时常量池\" class=\"headerlink\" title=\"5.4 运行时常量池\"></a>5.4 运行时常量池</h3><ul>\n<li>常量池，就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息</li>\n<li>运行时常量池，常量池是 *.class 文件中的，当该类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址</li>\n</ul>\n<h3 id=\"5-5-StringTable特性\"><a href=\"#5-5-StringTable特性\" class=\"headerlink\" title=\"5.5 StringTable特性\"></a>5.5 StringTable特性</h3><ul>\n<li>常量池中的字符串仅是符号，第一次用到时才变为对象</li>\n<li>利用串池的机制，来避免重复创建字符串对象</li>\n<li>字符串变量拼接的原理是StringBuilder（jdk1.8）</li>\n<li>字符串常量拼接的原理是编译期优化</li>\n<li>可以使用intern方法，主动将串池中还没有的字符串对象放入串池<ul>\n<li>1.8中，将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池，会把串池中的对象返回</li>\n<li>1.6中，将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则会把此对象复制一份，再放入串池，会把串池中的对象返回</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"5-6-StringTable位置\"><a href=\"#5-6-StringTable位置\" class=\"headerlink\" title=\"5.6 StringTable位置\"></a>5.6 StringTable位置</h3><ul>\n<li>1.8，StringTable在堆（Heap）中</li>\n<li>1.6，StringTable在永久代（PermGen）中</li>\n</ul>\n<h3 id=\"5-7-StringTable垃圾回收\"><a href=\"#5-7-StringTable垃圾回收\" class=\"headerlink\" title=\"5.7 StringTable垃圾回收\"></a>5.7 StringTable垃圾回收</h3><h3 id=\"5-8-StringTable性能调优\"><a href=\"#5-8-StringTable性能调优\" class=\"headerlink\" title=\"5.8 StringTable性能调优\"></a>5.8 StringTable性能调优</h3><ul>\n<li>StringTable本质上是哈希表，因此调优就是调整桶的个数，适当的把桶的个数调大，减少哈希碰撞   -XX:StringTableSize=桶个数</li>\n<li>考虑将字符串对象是否入池</li>\n<li>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当量池无法再申请到内存时会抛出OutOfMemoryError异常。</li>\n</ul>\n<h2 id=\"6-直接内存\"><a href=\"#6-直接内存\" class=\"headerlink\" title=\"6. 直接内存\"></a>6. 直接内存</h2><h3 id=\"6-1-定义\"><a href=\"#6-1-定义\" class=\"headerlink\" title=\"6.1 定义\"></a>6.1 定义</h3><p>Direct Memory</p>\n<ul>\n<li>常见于NIO（一种基于通道（Channel）与缓<br>冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作）操作，用于数据缓存区</li>\n<li>分配回收成本较高，但读写性能高，因为避免了在Java堆和Native堆中来回复制数据</li>\n<li>不受JVM内存回收管理</li>\n</ul>\n<h3 id=\"6-2-分配和回收原理\"><a href=\"#6-2-分配和回收原理\" class=\"headerlink\" title=\"6.2 分配和回收原理\"></a>6.2 分配和回收原理</h3><ul>\n<li>使用了Unsafe对象完成直接内存的分配回收，并且回收需要主动调用的freeMemory方法</li>\n<li>ByteBuffer的实现类内部，使用了Cleaner（虚引用）来检测ByteBuffer对象，一旦ByteBuffer对象被垃圾回收，那么就会有ReferenceHandler线程通过Cleaner的clean方法调用freeMemory来释放直接内存</li>\n</ul>\n","feature":true,"text":"本篇笔记不定期更新 内存结构图先上图这张图差不多就把JVM的内存结构以及和class源文件，JVM执行引擎，以及操作系统自带的本地方法接口之间的关系囊括进去了。 下面我们就JVM内存结构的几个组成部分来逐一简单介绍一下 1. 程序计数器1.1 定义Program Counter ...","link":"","photos":[],"count_time":{"symbolsCount":"4.1k","symbolsTime":"4 mins."},"categories":[{"name":"技术学习","slug":"技术学习","count":6,"path":"api/categories/技术学习.json"}],"tags":[{"name":"Java","slug":"Java","count":5,"path":"api/tags/Java.json"},{"name":"JVM","slug":"JVM","count":3,"path":"api/tags/JVM.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%9B%BE\"><span class=\"toc-text\">内存结构图</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8\"><span class=\"toc-text\">1. 程序计数器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">1.1 定义</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">1.2 作用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-3-%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">1.3 特点</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88\"><span class=\"toc-text\">2. 虚拟机栈</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">2.1 定义</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-%E6%A0%88%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA\"><span class=\"toc-text\">2.2 栈内存溢出</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3-%E5%AE%9E%E9%99%85%E6%BC%94%E7%A4%BA\"><span class=\"toc-text\">2.3 实际演示</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88\"><span class=\"toc-text\">3. 本地方法栈</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E5%A0%86\"><span class=\"toc-text\">4. 堆</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-1%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">4.1定义</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-2-%E5%A0%86%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA\"><span class=\"toc-text\">4.2 堆内存溢出</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-3-%E5%A0%86%E5%86%85%E5%AD%98%E8%AF%8A%E6%96%AD\"><span class=\"toc-text\">4.3 堆内存诊断</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E6%96%B9%E6%B3%95%E5%8C%BA\"><span class=\"toc-text\">5. 方法区</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-1-%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">5.1 定义</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-2-%E7%BB%84%E6%88%90\"><span class=\"toc-text\">5.2 组成</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-3-%E6%96%B9%E6%B3%95%E5%8C%BA%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA\"><span class=\"toc-text\">5.3 方法区内存溢出</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-4-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0\"><span class=\"toc-text\">5.4 运行时常量池</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-5-StringTable%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">5.5 StringTable特性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-6-StringTable%E4%BD%8D%E7%BD%AE\"><span class=\"toc-text\">5.6 StringTable位置</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-7-StringTable%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6\"><span class=\"toc-text\">5.7 StringTable垃圾回收</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-8-StringTable%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98\"><span class=\"toc-text\">5.8 StringTable性能调优</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98\"><span class=\"toc-text\">6. 直接内存</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-1-%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">6.1 定义</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-2-%E5%88%86%E9%85%8D%E5%92%8C%E5%9B%9E%E6%94%B6%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">6.2 分配和回收原理</span></a></li></ol></li></ol>","author":{"name":"南望","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/db609a2e507d4a36b32e06b4676aad38.PNG","link":"/","description":"路漫漫其修远兮，吾将上下而求索······","socials":{"github":"https://github.com/saw96x","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/saw96x","csdn":"https://blog.csdn.net/saw96x?spm=1001.2101.3001.5343","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"JVM垃圾回收","uid":"b4694def951abc4bafb5168cc2a7630a","slug":"JVM垃圾回收","date":"2021-08-12T07:11:37.000Z","updated":"2021-08-12T07:11:49.746Z","comments":true,"path":"api/articles/JVM垃圾回收.json","cover":"https://img-blog.csdnimg.cn/992408165d9448b88f720e3fb7e442d8.jpg","text":"JVM垃圾回收1. 如何判断对象可以回收1.1 简要介绍： 引用计数法，如果某个对象被引用了，则他的计数加1，不再被引用了，则减1，计数为0则回收。弊端：循环引用，比如a和b相互引用，即使他们两个永远都不再被使用了，但是由于存在引用计数，所以永远都不会被回收。早期python虚拟...","link":"","photos":[],"count_time":{"symbolsCount":"5k","symbolsTime":"5 mins."},"categories":[{"name":"技术学习","slug":"技术学习","count":6,"path":"api/categories/技术学习.json"}],"tags":[{"name":"Java","slug":"Java","count":5,"path":"api/tags/Java.json"},{"name":"JVM","slug":"JVM","count":3,"path":"api/tags/JVM.json"},{"name":"源码分析","slug":"源码分析","count":3,"path":"api/tags/源码分析.json"}],"author":{"name":"南望","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/db609a2e507d4a36b32e06b4676aad38.PNG","link":"/","description":"路漫漫其修远兮，吾将上下而求索······","socials":{"github":"https://github.com/saw96x","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/saw96x","csdn":"https://blog.csdn.net/saw96x?spm=1001.2101.3001.5343","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"Springboot的自动装配原理浅析","uid":"809380e59300e634907b381d0433de40","slug":"Springboot的自动装配原理浅析","date":"2021-08-04T08:16:55.000Z","updated":"2021-08-06T13:48:29.684Z","comments":true,"path":"api/articles/Springboot的自动装配原理浅析.json","cover":"https://img-blog.csdnimg.cn/63e12237debd402bba140afc62e94660.jpg","text":"最近在学习Springboot，不少文章和视频在完成了第一个快速入门的项目之后就直接进入了Springboot运行的原理部分，因此决定写一篇文章加深理解。 原理的理解主要使用了查看源码和画流程图的方式。 pom.xml对于一个maven项目，我们一般首要分析其pom文件，查看相关...","link":"","photos":[],"count_time":{"symbolsCount":"5.6k","symbolsTime":"5 mins."},"categories":[{"name":"技术学习","slug":"技术学习","count":6,"path":"api/categories/技术学习.json"}],"tags":[{"name":"Java","slug":"Java","count":5,"path":"api/tags/Java.json"},{"name":"源码分析","slug":"源码分析","count":3,"path":"api/tags/源码分析.json"},{"name":"SpringBoot","slug":"SpringBoot","count":1,"path":"api/tags/SpringBoot.json"}],"author":{"name":"南望","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/db609a2e507d4a36b32e06b4676aad38.PNG","link":"/","description":"路漫漫其修远兮，吾将上下而求索······","socials":{"github":"https://github.com/saw96x","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/saw96x","csdn":"https://blog.csdn.net/saw96x?spm=1001.2101.3001.5343","juejin":"","customs":{}}},"feature":true}}