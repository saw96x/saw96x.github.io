{"title":"JVM内存结构","uid":"f0feb27731f09def8e6fa03e806c3c89","slug":"JVM内存结构","date":"2021-08-06T06:55:18.000Z","updated":"2021-08-08T01:22:35.896Z","comments":true,"path":"api/articles/JVM内存结构.json","cover":"https://img-blog.csdnimg.cn/894fb565727048428c86ad9706a6948b.jpg","content":"<p>本篇笔记不定期更新</p>\n<h2 id=\"内存结构图\"><a href=\"#内存结构图\" class=\"headerlink\" title=\"内存结构图\"></a>内存结构图</h2><p>先上图<br><img src=\"https://img-blog.csdnimg.cn/bf995bbfbfcc4629ab3ef9f83c78d099.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhdzk2eA==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"><br>这张图差不多就把JVM的内存结构以及和class源文件，JVM执行引擎，以及操作系统自带的本地方法接口之间的关系囊括进去了。</p>\n<p>下面我们就JVM内存结构的几个组成部分来逐一简单介绍一下</p>\n<h2 id=\"1-程序计数器\"><a href=\"#1-程序计数器\" class=\"headerlink\" title=\"1. 程序计数器\"></a>1. 程序计数器</h2><h3 id=\"1-1-定义\"><a href=\"#1-1-定义\" class=\"headerlink\" title=\"1.1 定义\"></a>1.1 定义</h3><p>Program Counter Register 程序计数器（寄存器）</p>\n<h3 id=\"1-2-作用\"><a href=\"#1-2-作用\" class=\"headerlink\" title=\"1.2 作用\"></a>1.2 作用</h3><ol>\n<li>在执行当前指令时，记住下一条JVM指令的执行地址，所以PCR也被称为寄存器，在物理上通过CPU寄存器实现</li>\n<li>在多线程程序中起到一个记录上下文的作用，方便切换线程时可以继续运行</li>\n</ol>\n<h3 id=\"1-3-特点\"><a href=\"#1-3-特点\" class=\"headerlink\" title=\"1.3 特点\"></a>1.3 特点</h3><ul>\n<li>Java支持多线程，而PCR是线程私有的，每个线程都有自己的PCR</li>\n<li>不会存在内存溢出</li>\n</ul>\n<h2 id=\"2-虚拟机栈\"><a href=\"#2-虚拟机栈\" class=\"headerlink\" title=\"2. 虚拟机栈\"></a>2. 虚拟机栈</h2><p>栈–线程运行需要的内存空间，由栈帧组成，栈帧看为栈内的元素</p>\n<p>栈帧–每个方法运行时所需要的内存，参数，局部变量，返回地址等等····</p>\n<p>当调用某个方法时，会给栈帧分配内存，并将这个栈帧压入栈中，运行完毕后，会释放内存，也就是弹出栈帧。</p>\n<p>当方法调用方法时，就会压入多个栈帧</p>\n<h3 id=\"2-1-定义\"><a href=\"#2-1-定义\" class=\"headerlink\" title=\"2.1 定义\"></a>2.1 定义</h3><p>Java Virtual Machine Stacks</p>\n<ul>\n<li>每个线程运行时需要的内存，称为虚拟机栈</li>\n<li>每个栈由多个栈帧（Frame）祖传，对应着每次方法调用时所占用的内存，一般来说是局部变量</li>\n<li>每个线程只能由一个活动栈帧，对应着当前正在执行的那个方法，也就是目前栈顶的那个栈帧</li>\n</ul>\n<p>问题辨析</p>\n<ol>\n<li><p>垃圾回收是否涉及栈内存？不涉及，栈内存只和方法有关，方法运行完毕后栈帧出栈，内存自动回收。</p>\n</li>\n<li><p>栈内存分配越大越好吗？不是，内存分配得越大，线程就越少，因为物理内存是确定的，内存分配的越大，能更多次的进行方法递归。一般来说，默认的分配内存已经够用了。</p>\n</li>\n<li><p>方法内的局部变量是否线程安全？</p>\n<p>是的，因为每个线程只对应一个虚拟机栈，和其他方法的线程是互不干扰的，本质上操作的局部变量完全没有关系，因此是线程安全的。但如果不是局部变量，而是静态变量，或者是方法参数、或者是局部变量作为返回值返回了，那么就线程不安全，因为这时不同线程操纵的变量是同一个变量了。</p>\n<p>简单来说，如果方法内局部变量没有逃离方法的作用范围，那么他就是线程安全的</p>\n</li>\n</ol>\n<h3 id=\"2-2-栈内存溢出\"><a href=\"#2-2-栈内存溢出\" class=\"headerlink\" title=\"2.2 栈内存溢出\"></a>2.2 栈内存溢出</h3><p>   -Xss 栈内存分配大小命令</p>\n<p>   StackOverflowError</p>\n<ul>\n<li>栈帧过多导致栈内存溢出，如递归调用但没设置中止条件，或是出现了循环引用问题</li>\n<li>栈帧过大导致栈内存溢出</li>\n</ul>\n<h3 id=\"2-3-实际演示\"><a href=\"#2-3-实际演示\" class=\"headerlink\" title=\"2.3 实际演示\"></a>2.3 实际演示</h3><p>在idea中，通过断点调试，我们可以观测到栈帧的存在<br>运行如下代码</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">StackTest</span> <span class=\"token punctuation\">&#123;</span>\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">int</span> <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">int</span> a<span class=\"token punctuation\">,</span> <span class=\"token keyword\">int</span> b<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token keyword\">return</span> a <span class=\"token operator\">+</span> b<span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">&#125;</span>\n\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">static</span> <span class=\"token keyword\">void</span> <span class=\"token function\">main</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span> args<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">&#123;</span>\n    <span class=\"token function\">add</span><span class=\"token punctuation\">(</span><span class=\"token number\">1</span><span class=\"token punctuation\">,</span> <span class=\"token number\">2</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//在这句打断点</span>\n  <span class=\"token punctuation\">&#125;</span>\n<span class=\"token punctuation\">&#125;</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n<p>程序运行到断点处停止，我们看debugger窗口<br><img src=\"https://img-blog.csdnimg.cn/bd5113f93e4b4afead467b0d2084cc8c.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhdzk2eA==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"><br>可以看得到Frames这个子窗口，这表示的就是栈帧的集合，也就是虚拟机栈，我们的程序在main方法中的add暂停，所以目前栈帧中只有一个main方法，我们运行到下一步看看<br><img src=\"https://img-blog.csdnimg.cn/52e00e7f2a634217ba041a3cb4d6d410.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhdzk2eA==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"><br>可以看到main栈帧的上方有了add，这符合栈后进先出的特点，可以预见，如果addd中继续调用方法，那么add栈帧之上又会有新的栈帧。</p>\n<p>现在我们继续运行程序，让add方法运行完毕<br><img src=\"https://img-blog.csdnimg.cn/d94890ad9d104242b18f54d08027e2bd.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhdzk2eA==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"><br>可以看到add的栈帧消失了，也就是add方法的运行内存被释放了。<br>这个小demo可以看出栈帧扮演的角色和运行方式。</p>\n<h2 id=\"3-本地方法栈\"><a href=\"#3-本地方法栈\" class=\"headerlink\" title=\"3. 本地方法栈\"></a>3. 本地方法栈</h2><p>Native Method Stacks</p>\n<p>本地方法：Native Method ，不是Java编写的代码，通常是操作系统自带的方法代码。</p>\n<p>本地方法栈为本地方法的运行提供内存空间</p>\n<h2 id=\"4-堆\"><a href=\"#4-堆\" class=\"headerlink\" title=\"4. 堆\"></a>4. 堆</h2><h3 id=\"4-1定义\"><a href=\"#4-1定义\" class=\"headerlink\" title=\"4.1定义\"></a>4.1定义</h3><p>Heap 堆</p>\n<ul>\n<li>通过new关键字，创建对象都会使用堆内存</li>\n</ul>\n<p>特点</p>\n<ul>\n<li>它是线程共享的，堆中对象都需要考虑线程安全的问题</li>\n<li>有垃圾回收机制</li>\n</ul>\n<h3 id=\"4-2-堆内存溢出\"><a href=\"#4-2-堆内存溢出\" class=\"headerlink\" title=\"4.2 堆内存溢出\"></a>4.2 堆内存溢出</h3><p>-Xmx 堆内存分配大小命令</p>\n<p>OutOfMemoryError : Java heap space</p>\n<p>垃圾回收：没人用的对象，就作为垃圾被回收</p>\n<p>堆内存溢出：大量的对象被不断创建，同时一直被使用，可能导致堆内存溢出</p>\n<h3 id=\"4-3-堆内存诊断\"><a href=\"#4-3-堆内存诊断\" class=\"headerlink\" title=\"4.3 堆内存诊断\"></a>4.3 堆内存诊断</h3><p>在idea控制台窗口即可运行</p>\n<ol>\n<li>jps工具<ul>\n<li>查看当前系统中有哪些Java进程</li>\n</ul>\n</li>\n<li>jmap工具<ul>\n<li>查看堆内存占用情况 ，不连续，只能查看某一时刻的情况</li>\n<li>jmap -heap 进程id</li>\n</ul>\n</li>\n<li>jconsole<ul>\n<li>图形界面，多功能检测工具，可连续监测</li>\n</ul>\n</li>\n</ol>\n<p>案例：</p>\n<ul>\n<li>垃圾回收后，内存占用率仍然很高</li>\n<li>使用jvisualvm工具，通过堆dump功能查看对象在某一时刻的具体情况，从而做出诊断</li>\n</ul>\n<h2 id=\"5-方法区\"><a href=\"#5-方法区\" class=\"headerlink\" title=\"5. 方法区\"></a>5. 方法区</h2><h3 id=\"5-1-定义\"><a href=\"#5-1-定义\" class=\"headerlink\" title=\"5.1 定义\"></a>5.1 定义</h3><p>Method Area</p>\n<p>方法区是所有Java虚拟机线程共享的区域，它存储了与类结构相关的信息，如成员变量，方法数据，成员方法和构造器的代码部分，运行时常量池。</p>\n<p>方法区在虚拟机启动时就被创建，逻辑上它是堆的组成部分，但具体实现不同的jvm有所不同</p>\n<h3 id=\"5-2-组成\"><a href=\"#5-2-组成\" class=\"headerlink\" title=\"5.2 组成\"></a>5.2 组成</h3><p>参照官方笔记</p>\n<h3 id=\"5-3-方法区内存溢出\"><a href=\"#5-3-方法区内存溢出\" class=\"headerlink\" title=\"5.3 方法区内存溢出\"></a>5.3 方法区内存溢出</h3><p>-XX:MaxMetaspaceSize 设置元空间大小</p>\n<p>OutOfMemoryError:Metaspace</p>\n<ul>\n<li>1.8以前会导致永久代内存溢出</li>\n<li>1.8以后会导致元空间内存溢出</li>\n</ul>\n<h3 id=\"5-4-运行时常量池\"><a href=\"#5-4-运行时常量池\" class=\"headerlink\" title=\"5.4 运行时常量池\"></a>5.4 运行时常量池</h3><ul>\n<li>常量池，就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息</li>\n<li>运行时常量池，常量池是 *.class 文件中的，当该类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址</li>\n</ul>\n<h3 id=\"5-5-StringTable特性\"><a href=\"#5-5-StringTable特性\" class=\"headerlink\" title=\"5.5 StringTable特性\"></a>5.5 StringTable特性</h3><ul>\n<li>常量池中的字符串仅是符号，第一次用到时才变为对象</li>\n<li>利用串池的机制，来避免重复创建字符串对象</li>\n<li>字符串变量拼接的原理是StringBuilder（jdk1.8）</li>\n<li>字符串常量拼接的原理是编译期优化</li>\n<li>可以使用intern方法，主动将串池中还没有的字符串对象放入串池<ul>\n<li>1.8中，将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池，会把串池中的对象返回</li>\n<li>1.6中，将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则会把此对象复制一份，再放入串池，会把串池中的对象返回</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"5-6-StringTable位置\"><a href=\"#5-6-StringTable位置\" class=\"headerlink\" title=\"5.6 StringTable位置\"></a>5.6 StringTable位置</h3><ul>\n<li>1.8，StringTable在堆（Heap）中</li>\n<li>1.6，StringTable在永久代（PermGen）中</li>\n</ul>\n<h3 id=\"5-7-StringTable垃圾回收\"><a href=\"#5-7-StringTable垃圾回收\" class=\"headerlink\" title=\"5.7 StringTable垃圾回收\"></a>5.7 StringTable垃圾回收</h3><h3 id=\"5-8-StringTable性能调优\"><a href=\"#5-8-StringTable性能调优\" class=\"headerlink\" title=\"5.8 StringTable性能调优\"></a>5.8 StringTable性能调优</h3><ul>\n<li>StringTable本质上是哈希表，因此调优就是调整桶的个数，适当的把桶的个数调大，减少哈希碰撞   -XX:StringTableSize=桶个数</li>\n<li>考虑将字符串对象是否入池</li>\n</ul>\n<h2 id=\"6-直接内存\"><a href=\"#6-直接内存\" class=\"headerlink\" title=\"6. 直接内存\"></a>6. 直接内存</h2><h3 id=\"6-1-定义\"><a href=\"#6-1-定义\" class=\"headerlink\" title=\"6.1 定义\"></a>6.1 定义</h3><p>Direct Memory</p>\n<ul>\n<li>常见于NIO操作，用于数据缓存区</li>\n<li>分配回收成本较高，但读写性能高</li>\n<li>不受JVM内存回收管理</li>\n</ul>\n<h3 id=\"6-3-分配和回收原理\"><a href=\"#6-3-分配和回收原理\" class=\"headerlink\" title=\"6.3 分配和回收原理\"></a>6.3 分配和回收原理</h3><ul>\n<li>使用了Unsafe对象完成直接内存的分配回收，并且回收需要主动调用的freeMemory方法</li>\n<li>ByteBuffer的实现类内部，使用了Cleaner（虚引用）来检测ByteBuffer对象，一旦ByteBuffer对象被垃圾回收，那么就会有ReferenceHandler线程通过Cleaner的clean方法调用freeMemory来释放直接内存</li>\n</ul>\n","feature":true,"text":"本篇笔记不定期更新 内存结构图先上图这张图差不多就把JVM的内存结构以及和class源文件，JVM执行引擎，以及操作系统自带的本地方法接口之间的关系囊括进去了。 下面我们就JVM内存结构的几个组成部分来逐一简单介绍一下 1. 程序计数器1.1 定义Program Counter ...","link":"","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[{"name":"技术学习","slug":"技术学习","count":5,"path":"api/categories/技术学习.json"}],"tags":[{"name":"Java","slug":"Java","count":4,"path":"api/tags/Java.json"},{"name":"JVM","slug":"JVM","count":2,"path":"api/tags/JVM.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%86%85%E5%AD%98%E7%BB%93%E6%9E%84%E5%9B%BE\"><span class=\"toc-text\">内存结构图</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8\"><span class=\"toc-text\">1. 程序计数器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">1.1 定义</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-%E4%BD%9C%E7%94%A8\"><span class=\"toc-text\">1.2 作用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-3-%E7%89%B9%E7%82%B9\"><span class=\"toc-text\">1.3 特点</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88\"><span class=\"toc-text\">2. 虚拟机栈</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">2.1 定义</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-%E6%A0%88%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA\"><span class=\"toc-text\">2.2 栈内存溢出</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3-%E5%AE%9E%E9%99%85%E6%BC%94%E7%A4%BA\"><span class=\"toc-text\">2.3 实际演示</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E6%9C%AC%E5%9C%B0%E6%96%B9%E6%B3%95%E6%A0%88\"><span class=\"toc-text\">3. 本地方法栈</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E5%A0%86\"><span class=\"toc-text\">4. 堆</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-1%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">4.1定义</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-2-%E5%A0%86%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA\"><span class=\"toc-text\">4.2 堆内存溢出</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-3-%E5%A0%86%E5%86%85%E5%AD%98%E8%AF%8A%E6%96%AD\"><span class=\"toc-text\">4.3 堆内存诊断</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E6%96%B9%E6%B3%95%E5%8C%BA\"><span class=\"toc-text\">5. 方法区</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-1-%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">5.1 定义</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-2-%E7%BB%84%E6%88%90\"><span class=\"toc-text\">5.2 组成</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-3-%E6%96%B9%E6%B3%95%E5%8C%BA%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA\"><span class=\"toc-text\">5.3 方法区内存溢出</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-4-%E8%BF%90%E8%A1%8C%E6%97%B6%E5%B8%B8%E9%87%8F%E6%B1%A0\"><span class=\"toc-text\">5.4 运行时常量池</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-5-StringTable%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">5.5 StringTable特性</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-6-StringTable%E4%BD%8D%E7%BD%AE\"><span class=\"toc-text\">5.6 StringTable位置</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-7-StringTable%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6\"><span class=\"toc-text\">5.7 StringTable垃圾回收</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-8-StringTable%E6%80%A7%E8%83%BD%E8%B0%83%E4%BC%98\"><span class=\"toc-text\">5.8 StringTable性能调优</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#6-%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98\"><span class=\"toc-text\">6. 直接内存</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-1-%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">6.1 定义</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#6-3-%E5%88%86%E9%85%8D%E5%92%8C%E5%9B%9E%E6%94%B6%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">6.3 分配和回收原理</span></a></li></ol></li></ol>","author":{"name":"南望","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/db609a2e507d4a36b32e06b4676aad38.PNG","link":"/","description":"路漫漫其修远兮，吾将上下而求索······","socials":{"github":"https://github.com/saw96x","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/saw96x","csdn":"https://blog.csdn.net/saw96x?spm=1001.2101.3001.5343","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"JVM垃圾回收","uid":"b4694def951abc4bafb5168cc2a7630a","slug":"JVM垃圾回收","date":"2021-08-08T01:39:37.000Z","updated":"2021-08-09T13:17:38.868Z","comments":true,"path":"api/articles/JVM垃圾回收.json","cover":"https://img-blog.csdnimg.cn/992408165d9448b88f720e3fb7e442d8.jpg","text":"JVM垃圾回收持续更新 1. 如何判断对象可以回收1.1 简要介绍： 引用计数法，如果某个对象被引用了，则他的计数加1，不再被引用了，则减1，计数为0则回收。弊端：循环引用，比如a和b相互引用，即使他们两个永远都不再被使用了，但是由于存在引用计数，所以永远都不会被回收。早期pyt...","link":"","photos":[],"count_time":{"symbolsCount":"2.6k","symbolsTime":"2 mins."},"categories":[{"name":"技术学习","slug":"技术学习","count":5,"path":"api/categories/技术学习.json"}],"tags":[{"name":"Java","slug":"Java","count":4,"path":"api/tags/Java.json"},{"name":"JVM","slug":"JVM","count":2,"path":"api/tags/JVM.json"},{"name":"源码分析","slug":"源码分析","count":3,"path":"api/tags/源码分析.json"}],"author":{"name":"南望","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/db609a2e507d4a36b32e06b4676aad38.PNG","link":"/","description":"路漫漫其修远兮，吾将上下而求索······","socials":{"github":"https://github.com/saw96x","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/saw96x","csdn":"https://blog.csdn.net/saw96x?spm=1001.2101.3001.5343","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"Springboot的自动装配原理浅析","uid":"809380e59300e634907b381d0433de40","slug":"Springboot的自动装配原理浅析","date":"2021-08-04T08:16:55.000Z","updated":"2021-08-06T13:48:29.684Z","comments":true,"path":"api/articles/Springboot的自动装配原理浅析.json","cover":"https://img-blog.csdnimg.cn/63e12237debd402bba140afc62e94660.jpg","text":"最近在学习Springboot，不少文章和视频在完成了第一个快速入门的项目之后就直接进入了Springboot运行的原理部分，因此决定写一篇文章加深理解。 原理的理解主要使用了查看源码和画流程图的方式。 pom.xml对于一个maven项目，我们一般首要分析其pom文件，查看相关...","link":"","photos":[],"count_time":{"symbolsCount":"5.1k","symbolsTime":"5 mins."},"categories":[{"name":"技术学习","slug":"技术学习","count":5,"path":"api/categories/技术学习.json"}],"tags":[{"name":"Java","slug":"Java","count":4,"path":"api/tags/Java.json"},{"name":"源码分析","slug":"源码分析","count":3,"path":"api/tags/源码分析.json"},{"name":"SpringBoot","slug":"SpringBoot","count":1,"path":"api/tags/SpringBoot.json"}],"author":{"name":"南望","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/db609a2e507d4a36b32e06b4676aad38.PNG","link":"/","description":"路漫漫其修远兮，吾将上下而求索······","socials":{"github":"https://github.com/saw96x","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/saw96x","csdn":"https://blog.csdn.net/saw96x?spm=1001.2101.3001.5343","juejin":"","customs":{}}},"feature":true}}