{"title":"JVM垃圾回收","uid":"b4694def951abc4bafb5168cc2a7630a","slug":"JVM垃圾回收","date":"2021-08-08T01:39:37.000Z","updated":"2021-08-09T08:47:01.689Z","comments":true,"path":"api/articles/JVM垃圾回收.json","cover":"https://img-blog.csdnimg.cn/992408165d9448b88f720e3fb7e442d8.jpg","content":"<h1 id=\"JVM垃圾回收\"><a href=\"#JVM垃圾回收\" class=\"headerlink\" title=\"JVM垃圾回收\"></a>JVM垃圾回收</h1><h2 id=\"1-如何判断对象可以回收\"><a href=\"#1-如何判断对象可以回收\" class=\"headerlink\" title=\"1. 如何判断对象可以回收\"></a>1. 如何判断对象可以回收</h2><h3 id=\"1-1-简要介绍：\"><a href=\"#1-1-简要介绍：\" class=\"headerlink\" title=\"1.1 简要介绍：\"></a>1.1 简要介绍：</h3><ol>\n<li>引用计数法，如果某个对象被引用了，则他的计数加1，不再被引用了，则减1，计数为0则回收。弊端：循环引用，比如a和b相互引用，即使他们两个永远都不再被使用了，但是由于存在引用计数，所以永远都不会被回收。早期python虚拟机采用这种算法。</li>\n<li>可达性分析算法：首先确定根对象（肯定不能被垃圾回收的对象），进行垃圾回收前对所有对象进行一次扫描，如果被根对象直接或间接应用的对象就不能被回收，如果没有被引用，那么就可以被回收。JVM虚拟机采用这种算法进行</li>\n</ol>\n<h3 id=\"1-2-可达性分析算法：\"><a href=\"#1-2-可达性分析算法：\" class=\"headerlink\" title=\"1.2 可达性分析算法：\"></a>1.2 可达性分析算法：</h3><ul>\n<li><p>Java虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象</p>\n</li>\n<li><p>扫描堆中的对象，看是否能够沿这GC Root对象为起点的引用链找到该对象，找不到，表示可以回收</p>\n<h4 id=\"哪些对象可以作为GC-Root对象\"><a href=\"#哪些对象可以作为GC-Root对象\" class=\"headerlink\" title=\"哪些对象可以作为GC Root对象\"></a>哪些对象可以作为GC Root对象</h4></li>\n</ul>\n<p> SystemClass：由自举/系统类加载器加载的类。例如，rt.jar中所有诸如<a href=\"https://www.baidu.com/s?wd=java.util&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao\">java.util</a>.*的类。<br> JNILocal：原生代码中的本地变量，例如用户定义的JNI（Java本地接口，一般用来使Java代码和其他语言代码进行交互）代码或JVM内部代码。<br> JNIGlobal：原生代码中的全局变量，例如用户定义的JNI代码或JVM内部代码。<br> ThreadBlock：当前活跃的线程块中引用的对象。<br> Thread：启动且未停止的线程。<br> BusyMonitor：其wait()或notify()方法被调用，或被同步synchronized的对象。例如，通过调用synchronized(Object)或者进入其某个synchronized方法。静态方法对应类，非静态方法对应对象。<br> JavaLocal：本地变量。例如，仍在线程的栈中的方法输入参数或本地创建的对象。<br> NativeStack：（例如用户定义的JNI代码或JVM内部代码这样的）原生代码的入或出参数。通常发生在许多方法有原生部分，方法参数处理的对象成为GC根对象。例如，参数用于文件、网络I/O或反射。<br> Finalizer：在队列中等待其finalizer运行的对象。<br> Unfinalized：拥有finalize方法，但是还没有被终结且不在finalizer队列的对象。<br> Unreachable：从其他根对象不可达的对象，但是被内存分析器标记为根对象。<br> Unknown：没有根类型的对象。一些转储(dump)，例如IBM可移植对转储文件，没有根信息。对于这些转储，内存分析器解析程序将没有被其他根<a href=\"https://www.baidu.com/s?wd=%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao\">对象引用</a>的对象标记为此类根对象。</p>\n<h3 id=\"1-3-四种引用\"><a href=\"#1-3-四种引用\" class=\"headerlink\" title=\"1.3 四种引用\"></a>1.3 四种引用</h3><p><img src=\"https://img-blog.csdnimg.cn/12f2c23e724f4dd0b0babbfaa8df9529.PNG\"></p>\n<p>此图中，实线表示强引用，虚线表示其余引用 </p>\n<ol>\n<li><p>强引用</p>\n<p><strong>可以被GC Root对象直接或间接的找到，这种关系是强引用</strong>，一般情况下，我们书写的代码基本上形成的引用关系都是强引用，<strong>只有当所有强引用都断开时，对象才会被垃圾回收</strong>，除此之外是绝不可能将其回收的。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">Object</span> o <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Object</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>   <span class=\"token comment\">//  强引用</span>\no <span class=\"token operator\">=</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">//断开强引用，被回收</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre></li>\n<li><p>软引用</p>\n<p>在Java中，软引用本质上是一种特殊设计的类，因此软引用实际上是被手动创建出来的，使用SoftReference类创建出来</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">String</span> str <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"abc\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>                                     <span class=\"token comment\">// 强引用</span>\n<span class=\"token class-name\">SoftReference</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> softRef <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">SoftReference</span><span class=\"token operator\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>     <span class=\"token comment\">// str变为软引用</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p> <strong>如果一个对象只具有软引用（通过SoftReference建立），则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些软引用对象的内存。</strong>只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p>\n<p>最具代表性的应用，如浏览器的后退按钮，点击后退要返回到上一个页面，如果重新加载，可能耗时较长，如果将其存储到内存中，则会造成浪费，这时可以使用软引用进行缓存，如果缓存资源充足，那么就将页面保存到缓存中，如果紧张，由于软引用的特性，页面缓存会被垃圾回收器回收。</p>\n<p>可以配合<strong>引用队列</strong>使用，如果软引用它引用的对象被回收时，软引用本身（SoftReference实例）会被放到引用队列中，可以对其方便的进行进一步处理，比如释放SoftReference实例占用的内存。</p>\n</li>\n<li><p>弱引用</p>\n<p>和软引用相似，弱引用对象也要手动创建出来，使用WeakReference建立</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"><span class=\"token class-name\">String</span> st r<span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">String</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"abc\"</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>                                     <span class=\"token comment\">//强引用</span>\n<span class=\"token class-name\">WeakReference</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span> abcWeakRef <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">WeakReference</span><span class=\"token generics\"><span class=\"token punctuation\">&lt;</span><span class=\"token class-name\">String</span><span class=\"token punctuation\">></span></span><span class=\"token punctuation\">(</span>str<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>  <span class=\"token comment\">//str变为弱引用</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>和软引用不同的是，<strong>无论空间是否充足，只要垃圾回收器运行了，那么检测到弱引用，就会即刻将其回收</strong>。但是垃圾回收器的线程优先级很低，不太经常运行，所以不会发生马上就会被清理掉的情况。如果这个对象是偶尔的使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么你应该用 WeakReference 来记住此对象。  </p>\n<p>可以配合<strong>引用队列</strong>使用，如果软引用它引用的对象被回收时，软引用本身（WeakReference实例）会被放到引用队列中，可以对其方便的进行进一步处理，比如释放WeakReference实例占用的内存。</p>\n</li>\n<li><p>虚引用</p>\n</li>\n<li><p>终结器引用（额外）</p>\n</li>\n</ol>\n<h2 id=\"2-垃圾回收算法\"><a href=\"#2-垃圾回收算法\" class=\"headerlink\" title=\"2. 垃圾回收算法\"></a>2. 垃圾回收算法</h2><h2 id=\"3-分代垃圾回收\"><a href=\"#3-分代垃圾回收\" class=\"headerlink\" title=\"3. 分代垃圾回收\"></a>3. 分代垃圾回收</h2><h2 id=\"4-垃圾回收器\"><a href=\"#4-垃圾回收器\" class=\"headerlink\" title=\"4. 垃圾回收器\"></a>4. 垃圾回收器</h2><h2 id=\"5-垃圾回收调优\"><a href=\"#5-垃圾回收调优\" class=\"headerlink\" title=\"5. 垃圾回收调优\"></a>5. 垃圾回收调优</h2>","feature":true,"text":"JVM垃圾回收1. 如何判断对象可以回收1.1 简要介绍： 引用计数法，如果某个对象被引用了，则他的计数加1，不再被引用了，则减1，计数为0则回收。弊端：循环引用，比如a和b相互引用，即使他们两个永远都不再被使用了，但是由于存在引用计数，所以永远都不会被回收。早期python虚拟...","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[{"name":"技术学习","slug":"技术学习","count":5,"path":"api/categories/技术学习.json"}],"tags":[{"name":"Java","slug":"Java","count":4,"path":"api/tags/Java.json"},{"name":"JVM","slug":"JVM","count":2,"path":"api/tags/JVM.json"},{"name":"源码分析","slug":"源码分析","count":3,"path":"api/tags/源码分析.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6\"><span class=\"toc-text\">JVM垃圾回收</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E5%9B%9E%E6%94%B6\"><span class=\"toc-text\">1. 如何判断对象可以回收</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D%EF%BC%9A\"><span class=\"toc-text\">1.1 简要介绍：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95%EF%BC%9A\"><span class=\"toc-text\">1.2 可达性分析算法：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%93%AA%E4%BA%9B%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E4%BD%9C%E4%B8%BAGC-Root%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">哪些对象可以作为GC Root对象</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-3-%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8\"><span class=\"toc-text\">1.3 四种引用</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">2. 垃圾回收算法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6\"><span class=\"toc-text\">3. 分代垃圾回收</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8\"><span class=\"toc-text\">4. 垃圾回收器</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%B0%83%E4%BC%98\"><span class=\"toc-text\">5. 垃圾回收调优</span></a></li></ol></li></ol>","author":{"name":"南望","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/db609a2e507d4a36b32e06b4676aad38.PNG","link":"/","description":"路漫漫其修远兮，吾将上下而求索······","socials":{"github":"https://github.com/saw96x","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/saw96x","csdn":"https://blog.csdn.net/saw96x?spm=1001.2101.3001.5343","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"JVM内存结构","uid":"f0feb27731f09def8e6fa03e806c3c89","slug":"JVM内存结构","date":"2021-08-06T06:55:18.000Z","updated":"2021-08-08T01:22:35.896Z","comments":true,"path":"api/articles/JVM内存结构.json","cover":"https://img-blog.csdnimg.cn/894fb565727048428c86ad9706a6948b.jpg","text":"本篇笔记不定期更新 内存结构图先上图这张图差不多就把JVM的内存结构以及和class源文件，JVM执行引擎，以及操作系统自带的本地方法接口之间的关系囊括进去了。 下面我们就JVM内存结构的几个组成部分来逐一简单介绍一下 1. 程序计数器1.1 定义Program Counter ...","link":"","photos":[],"count_time":{"symbolsCount":"3.1k","symbolsTime":"3 mins."},"categories":[{"name":"技术学习","slug":"技术学习","count":5,"path":"api/categories/技术学习.json"}],"tags":[{"name":"Java","slug":"Java","count":4,"path":"api/tags/Java.json"},{"name":"JVM","slug":"JVM","count":2,"path":"api/tags/JVM.json"}],"author":{"name":"南望","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/db609a2e507d4a36b32e06b4676aad38.PNG","link":"/","description":"路漫漫其修远兮，吾将上下而求索······","socials":{"github":"https://github.com/saw96x","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/saw96x","csdn":"https://blog.csdn.net/saw96x?spm=1001.2101.3001.5343","juejin":"","customs":{}}},"feature":true}}