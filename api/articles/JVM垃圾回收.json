{"title":"JVM垃圾回收","uid":"b4694def951abc4bafb5168cc2a7630a","slug":"JVM垃圾回收","date":"2021-08-15T08:16:37.000Z","updated":"2021-08-29T02:40:13.778Z","comments":true,"path":"api/articles/JVM垃圾回收.json","cover":"https://img-blog.csdnimg.cn/992408165d9448b88f720e3fb7e442d8.jpg","content":"<h1 id=\"JVM垃圾回收\"><a href=\"#JVM垃圾回收\" class=\"headerlink\" title=\"JVM垃圾回收\"></a>JVM垃圾回收</h1><h2 id=\"1-如何判断对象可以回收\"><a href=\"#1-如何判断对象可以回收\" class=\"headerlink\" title=\"1. 如何判断对象可以回收\"></a>1. 如何判断对象可以回收</h2><h3 id=\"1-1-简要介绍：\"><a href=\"#1-1-简要介绍：\" class=\"headerlink\" title=\"1.1 简要介绍：\"></a>1.1 简要介绍：</h3><ol>\n<li><p>引用计数法，如果某个对象被引用了，则他的计数加1，不再被引用了，则减1，计数为0则回收。弊端：循环引用，比如a和b相互引用，即使他们两个永远都不再被使用了，但是由于存在引用计数，所以永远都不会被回收。早期python虚拟机采用这种算法。</p>\n</li>\n<li><p>可达性分析算法：首先确定根对象（肯定不能被垃圾回收的对象），进行垃圾回收前对所有对象进行一次扫描，如果被根对象直接或间接应用的对象就不能被回收，如果没有被引用，那么就可以被回收。许多主流的商用程序语言（Java，C#等等）都采用这种算法进行</p>\n<p><img src=\"https://img-blog.csdnimg.cn/a1dedc915d8b4c4a849f483359dcab00.PNG\"></p>\n</li>\n</ol>\n<h3 id=\"1-2-可达性分析算法：\"><a href=\"#1-2-可达性分析算法：\" class=\"headerlink\" title=\"1.2 可达性分析算法：\"></a>1.2 可达性分析算法：</h3><ul>\n<li><p>Java虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象</p>\n</li>\n<li><p>扫描堆中的对象，看是否能够沿这GC Root对象为起点的引用链找到该对象，找不到，表示可以回收</p>\n<h4 id=\"哪些对象可以作为GC-Root对象\"><a href=\"#哪些对象可以作为GC-Root对象\" class=\"headerlink\" title=\"哪些对象可以作为GC Root对象\"></a>哪些对象可以作为GC Root对象</h4></li>\n</ul>\n<p> SystemClass：由自举/系统类加载器加载的类。例如，rt.jar中所有诸如<a href=\"https://www.baidu.com/s?wd=java.util&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao\">java.util</a>.*的类。<br> JNILocal：原生代码中的本地变量，例如用户定义的JNI（Java本地接口，一般用来使Java代码和其他语言代码进行交互）代码或JVM内部代码。<br> JNIGlobal：原生代码中的全局变量，例如用户定义的JNI代码或JVM内部代码。<br> ThreadBlock：当前活跃的线程块中引用的对象。<br> Thread：启动且未停止的线程。<br> BusyMonitor：其wait()或notify()方法被调用，或被同步synchronized的对象。例如，通过调用synchronized(Object)或者进入其某个synchronized方法。静态方法对应类，非静态方法对应对象。<br> JavaLocal：本地变量。例如，仍在线程的栈中的方法输入参数或本地创建的对象。<br> NativeStack：（例如用户定义的JNI代码或JVM内部代码这样的）原生代码的入或出参数。通常发生在许多方法有原生部分，方法参数处理的对象成为GC根对象。例如，参数用于文件、网络I/O或反射。<br> Finalizer：在队列中等待其finalizer运行的对象。<br> Unfinalized：拥有finalize方法，但是还没有被终结且不在finalizer队列的对象。<br> Unreachable：从其他根对象不可达的对象，但是被内存分析器标记为根对象。<br> Unknown：没有根类型的对象。一些转储(dump)，例如IBM可移植对转储文件，没有根信息。对于这些转储，内存分析器解析程序将没有被其他根<a href=\"https://www.baidu.com/s?wd=%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao\">对象引用</a>的对象标记为此类根对象。</p>\n<p>如果觉得上面的太复杂，那么简单来说，在Java语言中，可作为GC Roots的对象包括下面4种：</p>\n<ul>\n<li>虚拟机栈（栈帧中的本地变量表）中引用的对象。*</li>\n<li>方法区中类静态属性引用的对象。*</li>\n<li>方法区中常量引用的对象。* </li>\n<li>本地方法栈中JNI（即一般说的Native方法）引用的对象。</li>\n</ul>\n<h3 id=\"1-3-四种引用\"><a href=\"#1-3-四种引用\" class=\"headerlink\" title=\"1.3 四种引用\"></a>1.3 四种引用</h3><p><img src=\"https://img-blog.csdnimg.cn/12f2c23e724f4dd0b0babbfaa8df9529.PNG\"></p>\n<p>此图中，实线表示强引用，虚线表示其余引用 </p>\n<ol>\n<li><p>强引用</p>\n<p><strong>可以被GC Root对象直接或间接的找到，这种关系是强引用</strong>，一般情况下，我们书写的代码基本上形成的引用关系都是强引用，<strong>只有当所有强引用都断开时，对象才会被垃圾回收</strong>，除此之外是绝不可能将其回收的。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Object o &#x3D; new Object();   &#x2F;&#x2F;  强引用\no &#x3D; null; &#x2F;&#x2F;断开强引用，被回收</code></pre></li>\n<li><p>软引用</p>\n<p>在Java中，软引用本质上是一种特殊设计的类，因此软引用实际上是被手动创建出来的，使用SoftReference类创建出来</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">String str &#x3D; new String(&quot;abc&quot;);                                     &#x2F;&#x2F; 强引用\nSoftReference&lt;String&gt; softRef &#x3D; new SoftReference&lt;String&gt;(str);     &#x2F;&#x2F; str被软引用</code></pre>\n\n<p> <strong>如果一个对象只具有软引用（通过SoftReference建立），则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些软引用对象的内存。</strong>只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p>\n<p>最具代表性的应用，如浏览器的后退按钮，点击后退要返回到上一个页面，如果重新加载，可能耗时较长，如果将其存储到内存中，则会造成浪费，这时可以使用软引用进行缓存，如果缓存资源充足，那么就将页面保存到缓存中，如果紧张，由于软引用的特性，页面缓存会被垃圾回收器回收。</p>\n<p>可以配合<strong>引用队列</strong>使用，如果软引用它引用的对象被回收时，软引用本身（SoftReference实例）会被放到引用队列中，可以对其方便的进行进一步处理，比如释放SoftReference实例占用的内存。</p>\n</li>\n<li><p>弱引用</p>\n<p>和软引用相似，弱引用对象也要手动创建出来，使用WeakReference建立</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">String str &#x3D; new String(&quot;abc&quot;);                                     &#x2F;&#x2F;强引用\nWeakReference&lt;String&gt; abcWeakRef &#x3D; new WeakReference&lt;String&gt;(str);  &#x2F;&#x2F;str被弱引用</code></pre>\n\n<p>和软引用不同的是，<strong>无论空间是否充足，只要垃圾回收器运行了，那么检测到弱引用，就会即刻将其回收</strong>。但是垃圾回收器的线程优先级很低，不太经常运行，所以不会发生马上就会被清理掉的情况。如果这个对象是偶尔的使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么你应该用 WeakReference 来记住此对象。  </p>\n<p>可以配合<strong>引用队列</strong>使用，如果软引用它引用的对象被回收时，软引用本身（WeakReference实例）会被放到引用队列中，可以对其方便的进行进一步处理，比如释放WeakReference实例占用的内存。</p>\n</li>\n<li><p>虚引用</p>\n<p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，<strong>虚引用并不会决定对象的生命周期</strong>。<strong>如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">String str &#x3D; new String(&quot;abc&quot;);                                     &#x2F;&#x2F;强引用\nPhantomReference&lt;String&gt; ref &#x3D; new PhantomReference&lt;String&gt;(str);  &#x2F;&#x2F;str被虚引用</code></pre>\n\n<p> 虚引用主要用来跟踪对象被垃圾回收器回收的活动，同时，和软引用以及弱引用不同的是，<strong>虚引用必须要和引用队列一起使用</strong>，下面用一个例子来说明其作用和特征。</p>\n<p>用Java中使用ByteBuffer分配直接内存的例子来说明一下，一个名叫Cleaner的虚引用关联了ByteBuffer实例对象，而我们借助ByteBuffer实例对象分配一些直接内存，当对ByteBuffer实例对象的强引用被断开后，ByteBuffer被回收了，但是其获取的直接内存不能被JVM垃圾回收器释放（因为它是底层的内存），这时候就要通过Cleaner这个虚引用，它进入引用队列，进行后续处理，通过这个虚引用获取到那块直接内存，然后将其释放。</p>\n</li>\n</ol>\n<h3 id=\"1-4-回收前的筛选判断\"><a href=\"#1-4-回收前的筛选判断\" class=\"headerlink\" title=\"1.4 回收前的筛选判断\"></a>1.4 回收前的筛选判断</h3><p>即使在可达性分析算法中不可达的对象，也<strong>并非一定会被垃圾回收</strong>，要真正回收一个对象，至少要经历两次标记过程：</p>\n<ol>\n<li>如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，<strong>筛选的条件是此对象是否有必要执行finalize（）方法</strong>。当对象没有覆盖finalize（）方法，或者finalize（）方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。</li>\n<li>如果这个对象被判定为有必要执行finalize（）方法，那么这个对象将会放置在一个叫做<strong>F-Queue</strong>的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。但<strong>此线程不保证一定会等待finalize()方法运行结束</strong>，这是为了防止发生死循环时其他队列中的对象无法执行finalize()。finalize（）方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，<strong>如果对象要在finalize（）中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可</strong>，如果对象没能在finalize()中建立关联，那么它就会真的被回收了。</li>\n</ol>\n<h2 id=\"2-垃圾回收算法\"><a href=\"#2-垃圾回收算法\" class=\"headerlink\" title=\"2. 垃圾回收算法\"></a>2. 垃圾回收算法</h2><h3 id=\"2-1-标记-清除算法\"><a href=\"#2-1-标记-清除算法\" class=\"headerlink\" title=\"2.1 标记-清除算法\"></a>2.1 标记-清除算法</h3><p>这种算法是最基础的手机算法，言简意赅，算法分为“标记”和“清除”（Mark-Sweep）两个阶段：<strong>首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象</strong>。</p>\n<p>在JVM中，标记过程就是上文说的回收前的筛选判断（两次标记）。这种算法相当简单，但是仍然不经常使用它，它的主要不足有两个：<strong>一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作</strong>。</p>\n<h3 id=\"2-2-复制算法\"><a href=\"#2-2-复制算法\" class=\"headerlink\" title=\"2.2 复制算法\"></a>2.2 复制算法</h3><p>为了解决效率问题，一种称为“复制”（Copying）的收集算法出现了，<strong>它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</strong></p>\n<p>这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将<strong>内存缩小为了原来的一半</strong>，未免太高了一点。</p>\n<h3 id=\"2-3-标记-整理算法\"><a href=\"#2-3-标记-整理算法\" class=\"headerlink\" title=\"2.3 标记-整理算法\"></a>2.3 标记-整理算法</h3><p>还有一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>\n<p>在JVM中，主要使用的<strong>复制算法</strong>和<strong>标记-整理算法</strong>，他们分别针对不同生命周期的对象。</p>\n<h2 id=\"3-分代垃圾回收\"><a href=\"#3-分代垃圾回收\" class=\"headerlink\" title=\"3. 分代垃圾回收\"></a>3. 分代垃圾回收</h2><p>当前商业虚拟机的垃圾回收都采用<strong>分代收集</strong>的思想，它建立在两个分代假说之上：</p>\n<ol>\n<li>弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。</li>\n<li>强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。</li>\n</ol>\n<p>基于这两种假说，分代收集策略把Java堆划分出不同的区域，根据年龄（熬过垃圾回收的次数）将其分为<strong>新生代和老年代</strong>。</p>\n<p>新生代的区域存储刚被创建出来的对象，一般有研究表明，新生代中的对象98%是“朝生夕死”的，而在经历了n次垃圾回收后仍然存活的对象，则会被放到老年代，一般老年代中的对象生命周期都较长。</p>\n<p>虚拟机对不同的区域采用不同的垃圾回收算法，由于新生代大多数对象生命周期极短，因此采用改良后的复制算法来回收。</p>\n<p>不是按照1:1的比例来划分内存空间，而是<strong>将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。</strong></p>\n<p>HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，因此每次只会浪费10%的空间。但是我们不能断定，某次新生代的垃圾回收之后，10%的内存一定装得下存活的实例对象，因此当Survivor对象不够用时，需要依赖其他内存进行分配担保。</p>\n<p><strong>如果另外一块Survivor空间没有足够空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代。</strong></p>\n<p>对于老年代，虚拟机采用的垃圾回收算法是<strong>标记-整理</strong>算法，一方面老年代对象不多，使用这种算法效率略低可以接受，另一方面也可以清理出整块的内存，方便后续的内存分配。</p>\n<p>但是，分代收集并非只是简单划分内存区域那么容易，它至少存在一个明显的困难：<strong>对象之间会存在跨代引用</strong>。</p>\n<p>假如要现在进行一次只局限于新生代区域内的收集（Minor GC），但新生代中的对象是完全有可能被老年代所引用的，为了找出该区域中的存活对象，不得不在固定的GC Roots之外，再额外遍历整个老年代中所有对象来确保可达性分析结果的正确性，反过来也是一样。</p>\n<p>这种方案虽然理论上可行，但是会带来很大的性能负担，为了解决这个问题，第三条假说诞生了：跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数。</p>\n<p>依据这条假说，只需在新生代上建立一个全局的数据结构（该结构被称为“记忆集”，Remembered Set），这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。此后当发生Minor GC时，<strong>只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描</strong>。虽然这种方法需要在对象改变引用关系（如将自己或者某个属性赋值）时维护记录数据的正确性，会增加一些运行时的开销，但比起收集时扫描整个老年代来说仍然是划算的。</p>\n<h2 id=\"4-垃圾收集器\"><a href=\"#4-垃圾收集器\" class=\"headerlink\" title=\"4. 垃圾收集器\"></a>4. 垃圾收集器</h2><p><img src=\"https://img-blog.csdnimg.cn/81b0bee23de84984be80643c396c9131.PNG\"></p>\n<p>如图，这是HotSpot虚拟机包含的所有收集器，如果两个收集器存在连线，就说明它们可以搭配使用，虚拟机所处的区域，则表示它是属于新生代收集器还是老年代收集器。</p>\n<h3 id=\"4-1-Serial收集器\"><a href=\"#4-1-Serial收集器\" class=\"headerlink\" title=\"4.1 Serial收集器\"></a>4.1 Serial收集器</h3><p>它是最基本，发展历史最悠久的收集器，它是单线程收集器，在进行垃圾收集时丙戌暂停其他所有线程，直到它收集结束。</p>\n<p>看起来它效率很低，但实际上，<strong>它依然是虚拟机运行在Client（客户端）模式下的默认新生代收集器</strong>。</p>\n<p>它有着自己的优点：简单高效、没有线程交互开销，对于内存没有非常大的新生代已经足够使用了。</p>\n<h3 id=\"4-2-ParNew收集器\"><a href=\"#4-2-ParNew收集器\" class=\"headerlink\" title=\"4.2 ParNew收集器\"></a>4.2 ParNew收集器</h3><p>它是Serial收集器的多线程版本，除此之外它就没什么创新之处了，但<strong>它却是不少运行在Server模式下的虚拟机中的新生代收集器（主要是JDK7之前，它甚至是Server模式下新生代的首选）</strong>，其中有一个与性能无关但很重要的原因是，除了Serial收集器外，<strong>目前只有它能与CMS收集器（划时代意义的垃圾收集器）配合工作</strong>。</p>\n<p>但随着垃圾收集器技术的不断改进，更先进的G1收集器带着CMS继承者和替代者的光环登场。G1是一个面向全堆的收集器，不需要其他新生代收集器的配合工作，所以自JDK 9开始，ParNew加CMS收集器的组合就不再是官方推荐的服务端模式下的收集器解决方案了。官方希望它能完全被G1所取代。读者也可以理解为从此以后，<strong>ParNew合并入CMS，成为它专门处理新生代的组成部分</strong>。<strong>ParNew可以说是HotSpot虚拟机中第一款退出历史舞台的垃圾收集器</strong>。</p>\n<h3 id=\"4-3-Parallel-Scavenge收集器\"><a href=\"#4-3-Parallel-Scavenge收集器\" class=\"headerlink\" title=\"4.3 Parallel Scavenge收集器\"></a>4.3 Parallel Scavenge收集器</h3><p>Parallel Scavenge收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器，它的特点是，<strong>此收集器的目标是达到一个可控制的吞吐量（CPU用于运行用户代码的时间与CPU总消耗时间的比值）</strong>，因此它也常被称为“吞吐量优先”收集器。高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。</p>\n<p>Parallel Scavenge收集器还有一个特点，它有一个参数-XX：+UseAdaptiveSizePolicy值得关注。这是一个开关参数，<strong>当这个参数打开之后，就不需要指定一些列细节参数，虚拟机会根据当前系统的运行情况收集性能监控信</strong><br><strong>息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种调节方式称为GC自适应的调节策略</strong>。</p>\n<h3 id=\"4-4-Serial-Old收集器\"><a href=\"#4-4-Serial-Old收集器\" class=\"headerlink\" title=\"4.4 Serial Old收集器\"></a>4.4 Serial Old收集器</h3><p>它是Serial收集器的老年代版本，同样是单线程收集器，使用“标记-整理”算法，这个收集器的主要意义也是在于给Client模式下的虚拟机使用，如果在Server模式<br>下，那么它主要还有两大用途：一种用途是在JDK 1.5以及之前的版本中与Parallel Scavenge收集器搭配使用，另一种用途就是作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure（后文介绍）时使用。</p>\n<h3 id=\"4-5-Paraller-Old收集器\"><a href=\"#4-5-Paraller-Old收集器\" class=\"headerlink\" title=\"4.5 Paraller Old收集器\"></a>4.5 Paraller Old收集器</h3><p>它是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。</p>\n<p>在它出现之前，Parallel Scavenge收集器一直处于比较尴尬的地位。Parallel Scavenge收集器只能和Serial Old收集器配合使用，但是由于Serial Old收集器在服务端应用性能上的拖累，使用了Parallel Scavenge收集器也未必能在整体应用上获得吞吐量最大化的效果，在老年代很大而且硬件比较高级的环境中，这种组合的吞吐量甚至还不一定又ParNew+CMS的组合给力。</p>\n<p>直到Parallel Old收集器出现后，“吞吐量优先”收集器终于有了比较名副其实的应用组合，<strong>在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器</strong>。</p>\n<h3 id=\"4-6-CMS收集器\"><a href=\"#4-6-CMS收集器\" class=\"headerlink\" title=\"4.6 CMS收集器\"></a>4.6 CMS收集器</h3><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。相当一部分Java应用集中在互联网应用的服务端上，这类应用尤其注重服务的响应速度，CMS收集器就很符合这类应用的需求。</p>\n<p>从名字（包含“Mark Sweep”）上就可以看出，CMS收集器是基于“标记—清除”算法实现的，它的运作过程相对于前面几种收集器来说更复杂一些，整个过程分为4个步骤，包括：</p>\n<ol>\n<li>初始标记（CMS initial mark）</li>\n<li>并发标记（CMS concurrent mark）</li>\n<li>重新标记（CMS remark）</li>\n<li>并发清除（CMS concurrent sweep）</li>\n</ol>\n<p>其中，第一步和第三步仍然需要停止所有线程（Stop The World）。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC RootsTracing的过程，而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。</p>\n<p>而耗时最长的并发标记和并非清楚过程收集器线程都可以与用户线程一起工作，所有，从总体来说，CMS收集器的执行是与用户线程一起并发执行的，可以达到低停顿时间。</p>\n<p>虽然它相当优秀，但是它还远远达不到完美的程度，它又以下3个明显的缺点：</p>\n<ol>\n<li><strong>CMS收集器对CPU资源非常敏感。</strong>当CPU不足4个时，CMS对用户程序的影响可能变得很大，甚至可能导致执行速度降低了50%。为了应付这种情况，虚拟机提供了一种称为“增量式并发收集器”（Incremental Concurrent Mark Sweep/i-CMS）的CMS收集器变种。就是在并发标记、清理的时候让GC线程、用户线程交替运行，尽量减少GC线程的独占资源的时间，这样整个垃圾收集的过程会更长，但对用户程序的影响就会显得少一些，也就是速度下降没有那么明显。实际上，他的效果很一般，当前版本不再提倡用户使用。</li>\n<li><strong>CMS收集器无法处理浮动垃圾（Floating Garbage），可能现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。</strong>由于在并发清理解答，用户线程仍在运行，就会产生新垃圾，这些垃圾必须得下一次GC再清理，这种垃圾就被称为“浮动垃圾”。CMS收集器需要预留一部分空间提供并发时其他线程使用，要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败，这时虚拟机将启动后备预案：临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。</li>\n<li><strong>由于采用了“标记-清除“算法，收集结束时会有大量空间碎片产生。</strong>，CMS收集器提供了一个-XX：+UseCMSCompactAtFullCollection开关参数（默认就是开启的），用于在CMS收集器顶不住要进行FullGC时开启内存碎片的合并整理过程，内存整理的过程是无法并发的，空间碎片问题没有了，但停顿时间不得不变长。</li>\n</ol>\n<h3 id=\"4-7-G1收集器\"><a href=\"#4-7-G1收集器\" class=\"headerlink\" title=\"4.7 G1收集器\"></a>4.7 G1收集器</h3><p>G1（Garbage-First）收集器是当今收集器技术发展的最前沿成果之一，G1是一款面向服务端应用的垃圾收集器。HotSpot开发团队赋予它的使命是（在比较长期的）未来可以替换掉JDK 1.5中发布的CMS收集器。和其他收集器相比，它具备如下特点：</p>\n<ol>\n<li>并行与并发</li>\n<li>分代收集</li>\n<li>空间整合，整体上来看是基于<strong>标记-整理</strong>算法实现，局部看是基于<strong>复制</strong>算法实现</li>\n<li>可预测的停顿</li>\n</ol>\n<p>使用G1收集器时，Java堆的内存布局就与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。</p>\n<p>G1收集器的实现较为复杂，有空专门写一篇笔记来介绍G1收集器。</p>\n<p>除了这7种收集器之外，还有其他更先进，更复杂的收集器，如ZGC，Shenandoah收集器等，本文并未描述（因为真的很复杂）。</p>\n<h3 id=\"4-8-如何选择垃圾收集器\"><a href=\"#4-8-如何选择垃圾收集器\" class=\"headerlink\" title=\"4.8 如何选择垃圾收集器\"></a>4.8 如何选择垃圾收集器</h3><p>这个问题的答案主要受三个方向影响：</p>\n<ol>\n<li>应用程序的主要关注点是什么？</li>\n<li>运行应用的基础设施如何？</li>\n<li>使用JDK的发行商是什么？</li>\n</ol>\n<h2 id=\"5-内存分配与回收策略\"><a href=\"#5-内存分配与回收策略\" class=\"headerlink\" title=\"5. 内存分配与回收策略\"></a>5. 内存分配与回收策略</h2><h3 id=\"5-1-两种回收\"><a href=\"#5-1-两种回收\" class=\"headerlink\" title=\"5.1 两种回收\"></a>5.1 两种回收</h3><p><strong>新生代GC</strong>（Minor GC）：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。</p>\n<p><strong>老年代GC</strong>（Major GC/Full GC）：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。Major GC的速度一般会比Minor GC慢10倍以上。</p>\n<h3 id=\"5-2-对象优先在Eden区分配\"><a href=\"#5-2-对象优先在Eden区分配\" class=\"headerlink\" title=\"5.2 对象优先在Eden区分配\"></a>5.2 对象优先在Eden区分配</h3><p>大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。</p>\n<p>虚拟机提供了-XX：+PrintGCDetails这个收集器日志参数，告诉虚拟机在发生垃圾收集行为时打印内存回收日志，并且在进程退出的时候输出当前的内存各区域分配情况。</p>\n<h3 id=\"5-3-大对象直接进入老年代\"><a href=\"#5-3-大对象直接进入老年代\" class=\"headerlink\" title=\"5.3 大对象直接进入老年代\"></a>5.3 大对象直接进入老年代</h3><p>所谓的大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组。</p>\n<p>大对象对虚拟机的内存分配来说就是一个坏消息（替Java虚拟机抱怨一句，比遇到一个大对象更加坏的消息就是遇到一群“朝生夕灭”的“短命大对象”，写程序的时候应当避免）</p>\n<p>经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。</p>\n<p>虚拟机提供了一个**-XX：PretenureSizeThreshold**参数，令大于这个设置值的对象直接在老年代分配。目的是为了防止Eden和两个survivor区之间发生大量内存复制。</p>\n<h3 id=\"5-4-长期存活的对象将进入老年代\"><a href=\"#5-4-长期存活的对象将进入老年代\" class=\"headerlink\" title=\"5.4 长期存活的对象将进入老年代\"></a>5.4 长期存活的对象将进入老年代</h3><p>虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。</p>\n<p>对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就将会被晋升到老年代中。</p>\n<p>对象晋升老年代的年龄阈值，可以通过参数**-XX：MaxTenuringThreshold**设置</p>\n<h3 id=\"5-5-动态对象年龄判定\"><a href=\"#5-5-动态对象年龄判定\" class=\"headerlink\" title=\"5.5 动态对象年龄判定\"></a>5.5 动态对象年龄判定</h3><p>为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代。</p>\n<p>如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。</p>\n<h3 id=\"5-6-空间分配担保\"><a href=\"#5-6-空间分配担保\" class=\"headerlink\" title=\"5.6 空间分配担保\"></a>5.6 空间分配担保</h3><p>前面提到过，新生代使用复制收集算法，但为了内存利用率，只使用其中一个Survivor空间来作为轮换备份，因此当出现大量对在MinorGC后仍然存活的情况（最极端的情况就是内存回收后新生代中所有对象都存活），就需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代。</p>\n<p>在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。</p>\n<p>如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。</p>\n","feature":true,"text":"JVM垃圾回收1. 如何判断对象可以回收1.1 简要介绍： 引用计数法，如果某个对象被引用了，则他的计数加1，不再被引用了，则减1，计数为0则回收。弊端：循环引用，比如a和b相互引用，即使他们两个永远都不再被使用了，但是由于存在引用计数，所以永远都不会被回收。早期python虚拟...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"技术笔记","slug":"技术笔记","count":5,"path":"api/categories/技术笔记.json"}],"tags":[{"name":"Java","slug":"Java","count":7,"path":"api/tags/Java.json"},{"name":"JVM","slug":"JVM","count":5,"path":"api/tags/JVM.json"},{"name":"深入理解Java虚拟机","slug":"深入理解Java虚拟机","count":5,"path":"api/tags/深入理解Java虚拟机.json"},{"name":"源码分析","slug":"源码分析","count":3,"path":"api/tags/源码分析.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6\"><span class=\"toc-text\">JVM垃圾回收</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E5%9B%9E%E6%94%B6\"><span class=\"toc-text\">1. 如何判断对象可以回收</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D%EF%BC%9A\"><span class=\"toc-text\">1.1 简要介绍：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95%EF%BC%9A\"><span class=\"toc-text\">1.2 可达性分析算法：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%93%AA%E4%BA%9B%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E4%BD%9C%E4%B8%BAGC-Root%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">哪些对象可以作为GC Root对象</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-3-%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8\"><span class=\"toc-text\">1.3 四种引用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-4-%E5%9B%9E%E6%94%B6%E5%89%8D%E7%9A%84%E7%AD%9B%E9%80%89%E5%88%A4%E6%96%AD\"><span class=\"toc-text\">1.4 回收前的筛选判断</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">2. 垃圾回收算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">2.1 标记-清除算法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">2.2 复制算法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3-%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">2.3 标记-整理算法</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6\"><span class=\"toc-text\">3. 分代垃圾回收</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8\"><span class=\"toc-text\">4. 垃圾收集器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-1-Serial%E6%94%B6%E9%9B%86%E5%99%A8\"><span class=\"toc-text\">4.1 Serial收集器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-2-ParNew%E6%94%B6%E9%9B%86%E5%99%A8\"><span class=\"toc-text\">4.2 ParNew收集器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-3-Parallel-Scavenge%E6%94%B6%E9%9B%86%E5%99%A8\"><span class=\"toc-text\">4.3 Parallel Scavenge收集器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-4-Serial-Old%E6%94%B6%E9%9B%86%E5%99%A8\"><span class=\"toc-text\">4.4 Serial Old收集器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-5-Paraller-Old%E6%94%B6%E9%9B%86%E5%99%A8\"><span class=\"toc-text\">4.5 Paraller Old收集器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-6-CMS%E6%94%B6%E9%9B%86%E5%99%A8\"><span class=\"toc-text\">4.6 CMS收集器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-7-G1%E6%94%B6%E9%9B%86%E5%99%A8\"><span class=\"toc-text\">4.7 G1收集器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-8-%E5%A6%82%E4%BD%95%E9%80%89%E6%8B%A9%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8\"><span class=\"toc-text\">4.8 如何选择垃圾收集器</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E4%B8%8E%E5%9B%9E%E6%94%B6%E7%AD%96%E7%95%A5\"><span class=\"toc-text\">5. 内存分配与回收策略</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-1-%E4%B8%A4%E7%A7%8D%E5%9B%9E%E6%94%B6\"><span class=\"toc-text\">5.1 两种回收</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-2-%E5%AF%B9%E8%B1%A1%E4%BC%98%E5%85%88%E5%9C%A8Eden%E5%8C%BA%E5%88%86%E9%85%8D\"><span class=\"toc-text\">5.2 对象优先在Eden区分配</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-3-%E5%A4%A7%E5%AF%B9%E8%B1%A1%E7%9B%B4%E6%8E%A5%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3\"><span class=\"toc-text\">5.3 大对象直接进入老年代</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-4-%E9%95%BF%E6%9C%9F%E5%AD%98%E6%B4%BB%E7%9A%84%E5%AF%B9%E8%B1%A1%E5%B0%86%E8%BF%9B%E5%85%A5%E8%80%81%E5%B9%B4%E4%BB%A3\"><span class=\"toc-text\">5.4 长期存活的对象将进入老年代</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-5-%E5%8A%A8%E6%80%81%E5%AF%B9%E8%B1%A1%E5%B9%B4%E9%BE%84%E5%88%A4%E5%AE%9A\"><span class=\"toc-text\">5.5 动态对象年龄判定</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#5-6-%E7%A9%BA%E9%97%B4%E5%88%86%E9%85%8D%E6%8B%85%E4%BF%9D\"><span class=\"toc-text\">5.6 空间分配担保</span></a></li></ol></li></ol></li></ol>","author":{"name":"南望","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/db609a2e507d4a36b32e06b4676aad38.PNG","link":"/","description":"路漫漫其修远兮，吾将上下而求索······","socials":{"github":"https://github.com/saw96x","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/saw96x","csdn":"https://blog.csdn.net/saw96x?spm=1001.2101.3001.5343","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"JVM中的类文件结构","uid":"581c1d5b4dc9ad92f487897aa0f3fdd0","slug":"JVM中的类文件结构","date":"2021-08-21T01:40:04.000Z","updated":"2021-08-29T02:40:32.244Z","comments":true,"path":"api/articles/JVM中的类文件结构.json","cover":"https://i.loli.net/2021/08/14/kbjcFenifLQaN5x.jpg","text":"JVM中的类文件结构Class文件是一组以8个字节为基础单位的二进制流，各个数据项目中严格按照顺序紧凑排列在一起，中间没有任何分隔符，当遇到了占位8个自己以上空间的数据项时，则会按照高位在前的方式分割成8个字节进行存储。 1. Class文件格式Class文件格式采用一种类似于C...","link":"","photos":[],"count_time":{"symbolsCount":"4k","symbolsTime":"4 mins."},"categories":[{"name":"技术笔记","slug":"技术笔记","count":5,"path":"api/categories/技术笔记.json"}],"tags":[{"name":"Java","slug":"Java","count":7,"path":"api/tags/Java.json"},{"name":"JVM","slug":"JVM","count":5,"path":"api/tags/JVM.json"},{"name":"深入理解Java虚拟机","slug":"深入理解Java虚拟机","count":5,"path":"api/tags/深入理解Java虚拟机.json"}],"author":{"name":"南望","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/db609a2e507d4a36b32e06b4676aad38.PNG","link":"/","description":"路漫漫其修远兮，吾将上下而求索······","socials":{"github":"https://github.com/saw96x","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/saw96x","csdn":"https://blog.csdn.net/saw96x?spm=1001.2101.3001.5343","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"剑指 Offer 04. 二维数组中的查找","uid":"fbb40c3574c6d879e5f206056adff580","slug":"剑指 Offer 04. 二维数组中的查找","date":"2021-08-28T12:24:08.000Z","updated":"2021-08-29T02:41:09.522Z","comments":true,"path":"api/articles/剑指 Offer 04. 二维数组中的查找.json","cover":"https://i.loli.net/2021/08/23/nTgK3iZQVLxvqy5.jpg","text":"题目详情在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 示例: 现有矩阵 matrix 如下： [ [1, 4, 7, 11, 15], ...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[{"name":"算法笔记","slug":"算法笔记","count":2,"path":"api/categories/算法笔记.json"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","count":2,"path":"api/tags/数据结构与算法.json"},{"name":"剑指Offer","slug":"剑指Offer","count":2,"path":"api/tags/剑指Offer.json"}],"author":{"name":"南望","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/db609a2e507d4a36b32e06b4676aad38.PNG","link":"/","description":"路漫漫其修远兮，吾将上下而求索······","socials":{"github":"https://github.com/saw96x","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/saw96x","csdn":"https://blog.csdn.net/saw96x?spm=1001.2101.3001.5343","juejin":"","customs":{}}},"feature":false}}