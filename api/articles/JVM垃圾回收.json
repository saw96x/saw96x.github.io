{"title":"JVM垃圾回收","uid":"b4694def951abc4bafb5168cc2a7630a","slug":"JVM垃圾回收","date":"2021-08-12T07:11:37.000Z","updated":"2021-08-12T08:34:49.132Z","comments":true,"path":"api/articles/JVM垃圾回收.json","cover":"https://img-blog.csdnimg.cn/992408165d9448b88f720e3fb7e442d8.jpg","content":"<h1 id=\"JVM垃圾回收\"><a href=\"#JVM垃圾回收\" class=\"headerlink\" title=\"JVM垃圾回收\"></a>JVM垃圾回收</h1><h2 id=\"1-如何判断对象可以回收\"><a href=\"#1-如何判断对象可以回收\" class=\"headerlink\" title=\"1. 如何判断对象可以回收\"></a>1. 如何判断对象可以回收</h2><h3 id=\"1-1-简要介绍：\"><a href=\"#1-1-简要介绍：\" class=\"headerlink\" title=\"1.1 简要介绍：\"></a>1.1 简要介绍：</h3><ol>\n<li><p>引用计数法，如果某个对象被引用了，则他的计数加1，不再被引用了，则减1，计数为0则回收。弊端：循环引用，比如a和b相互引用，即使他们两个永远都不再被使用了，但是由于存在引用计数，所以永远都不会被回收。早期python虚拟机采用这种算法。</p>\n</li>\n<li><p>可达性分析算法：首先确定根对象（肯定不能被垃圾回收的对象），进行垃圾回收前对所有对象进行一次扫描，如果被根对象直接或间接应用的对象就不能被回收，如果没有被引用，那么就可以被回收。许多主流的商用程序语言（Java，C#等等）都采用这种算法进行</p>\n<p><img src=\"https://img-blog.csdnimg.cn/a1dedc915d8b4c4a849f483359dcab00.PNG\"></p>\n</li>\n</ol>\n<h3 id=\"1-2-可达性分析算法：\"><a href=\"#1-2-可达性分析算法：\" class=\"headerlink\" title=\"1.2 可达性分析算法：\"></a>1.2 可达性分析算法：</h3><ul>\n<li><p>Java虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象</p>\n</li>\n<li><p>扫描堆中的对象，看是否能够沿这GC Root对象为起点的引用链找到该对象，找不到，表示可以回收</p>\n<h4 id=\"哪些对象可以作为GC-Root对象\"><a href=\"#哪些对象可以作为GC-Root对象\" class=\"headerlink\" title=\"哪些对象可以作为GC Root对象\"></a>哪些对象可以作为GC Root对象</h4></li>\n</ul>\n<p> SystemClass：由自举/系统类加载器加载的类。例如，rt.jar中所有诸如<a href=\"https://www.baidu.com/s?wd=java.util&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao\">java.util</a>.*的类。<br> JNILocal：原生代码中的本地变量，例如用户定义的JNI（Java本地接口，一般用来使Java代码和其他语言代码进行交互）代码或JVM内部代码。<br> JNIGlobal：原生代码中的全局变量，例如用户定义的JNI代码或JVM内部代码。<br> ThreadBlock：当前活跃的线程块中引用的对象。<br> Thread：启动且未停止的线程。<br> BusyMonitor：其wait()或notify()方法被调用，或被同步synchronized的对象。例如，通过调用synchronized(Object)或者进入其某个synchronized方法。静态方法对应类，非静态方法对应对象。<br> JavaLocal：本地变量。例如，仍在线程的栈中的方法输入参数或本地创建的对象。<br> NativeStack：（例如用户定义的JNI代码或JVM内部代码这样的）原生代码的入或出参数。通常发生在许多方法有原生部分，方法参数处理的对象成为GC根对象。例如，参数用于文件、网络I/O或反射。<br> Finalizer：在队列中等待其finalizer运行的对象。<br> Unfinalized：拥有finalize方法，但是还没有被终结且不在finalizer队列的对象。<br> Unreachable：从其他根对象不可达的对象，但是被内存分析器标记为根对象。<br> Unknown：没有根类型的对象。一些转储(dump)，例如IBM可移植对转储文件，没有根信息。对于这些转储，内存分析器解析程序将没有被其他根<a href=\"https://www.baidu.com/s?wd=%E5%AF%B9%E8%B1%A1%E5%BC%95%E7%94%A8&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao\">对象引用</a>的对象标记为此类根对象。</p>\n<p>如果觉得上面的太复杂，那么简单来说，在Java语言中，可作为GC Roots的对象包括下面4种：</p>\n<ul>\n<li>虚拟机栈（栈帧中的本地变量表）中引用的对象。*</li>\n<li>方法区中类静态属性引用的对象。*</li>\n<li>方法区中常量引用的对象。* </li>\n<li>本地方法栈中JNI（即一般说的Native方法）引用的对象。</li>\n</ul>\n<h3 id=\"1-3-四种引用\"><a href=\"#1-3-四种引用\" class=\"headerlink\" title=\"1.3 四种引用\"></a>1.3 四种引用</h3><p><img src=\"https://img-blog.csdnimg.cn/12f2c23e724f4dd0b0babbfaa8df9529.PNG\"></p>\n<p>此图中，实线表示强引用，虚线表示其余引用 </p>\n<ol>\n<li><p>强引用</p>\n<p><strong>可以被GC Root对象直接或间接的找到，这种关系是强引用</strong>，一般情况下，我们书写的代码基本上形成的引用关系都是强引用，<strong>只有当所有强引用都断开时，对象才会被垃圾回收</strong>，除此之外是绝不可能将其回收的。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Object o &#x3D; new Object();   &#x2F;&#x2F;  强引用\no &#x3D; null; &#x2F;&#x2F;断开强引用，被回收</code></pre></li>\n<li><p>软引用</p>\n<p>在Java中，软引用本质上是一种特殊设计的类，因此软引用实际上是被手动创建出来的，使用SoftReference类创建出来</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">String str &#x3D; new String(&quot;abc&quot;);                                     &#x2F;&#x2F; 强引用\nSoftReference&lt;String&gt; softRef &#x3D; new SoftReference&lt;String&gt;(str);     &#x2F;&#x2F; str被软引用</code></pre>\n\n<p> <strong>如果一个对象只具有软引用（通过SoftReference建立），则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些软引用对象的内存。</strong>只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。</p>\n<p>最具代表性的应用，如浏览器的后退按钮，点击后退要返回到上一个页面，如果重新加载，可能耗时较长，如果将其存储到内存中，则会造成浪费，这时可以使用软引用进行缓存，如果缓存资源充足，那么就将页面保存到缓存中，如果紧张，由于软引用的特性，页面缓存会被垃圾回收器回收。</p>\n<p>可以配合<strong>引用队列</strong>使用，如果软引用它引用的对象被回收时，软引用本身（SoftReference实例）会被放到引用队列中，可以对其方便的进行进一步处理，比如释放SoftReference实例占用的内存。</p>\n</li>\n<li><p>弱引用</p>\n<p>和软引用相似，弱引用对象也要手动创建出来，使用WeakReference建立</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">String str &#x3D; new String(&quot;abc&quot;);                                     &#x2F;&#x2F;强引用\nWeakReference&lt;String&gt; abcWeakRef &#x3D; new WeakReference&lt;String&gt;(str);  &#x2F;&#x2F;str被弱引用</code></pre>\n\n<p>和软引用不同的是，<strong>无论空间是否充足，只要垃圾回收器运行了，那么检测到弱引用，就会即刻将其回收</strong>。但是垃圾回收器的线程优先级很低，不太经常运行，所以不会发生马上就会被清理掉的情况。如果这个对象是偶尔的使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么你应该用 WeakReference 来记住此对象。  </p>\n<p>可以配合<strong>引用队列</strong>使用，如果软引用它引用的对象被回收时，软引用本身（WeakReference实例）会被放到引用队列中，可以对其方便的进行进一步处理，比如释放WeakReference实例占用的内存。</p>\n</li>\n<li><p>虚引用</p>\n<p>“虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，<strong>虚引用并不会决定对象的生命周期</strong>。<strong>如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。</strong></p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">String str &#x3D; new String(&quot;abc&quot;);                                     &#x2F;&#x2F;强引用\nPhantomReference&lt;String&gt; ref &#x3D; new PhantomReference&lt;String&gt;(str);  &#x2F;&#x2F;str被虚引用</code></pre>\n\n<p> 虚引用主要用来跟踪对象被垃圾回收器回收的活动，同时，和软引用以及弱引用不同的是，<strong>虚引用必须要和引用队列一起使用</strong>，下面用一个例子来说明其作用和特征。</p>\n<p>用Java中使用ByteBuffer分配直接内存的例子来说明一下，一个名叫Cleaner的虚引用关联了ByteBuffer实例对象，而我们借助ByteBuffer实例对象分配一些直接内存，当对ByteBuffer实例对象的强引用被断开后，ByteBuffer被回收了，但是其获取的直接内存不能被JVM垃圾回收器释放（因为它是底层的内存），这时候就要通过Cleaner这个虚引用，它进入引用队列，进行后续处理，通过这个虚引用获取到那块直接内存，然后将其释放。</p>\n</li>\n</ol>\n<h3 id=\"1-4-回收前的筛选判断\"><a href=\"#1-4-回收前的筛选判断\" class=\"headerlink\" title=\"1.4 回收前的筛选判断\"></a>1.4 回收前的筛选判断</h3><p>即使在可达性分析算法中不可达的对象，也<strong>并非一定会被垃圾回收</strong>，要真正回收一个对象，至少要经历两次标记过程：</p>\n<ol>\n<li>如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，<strong>筛选的条件是此对象是否有必要执行finalize（）方法</strong>。当对象没有覆盖finalize（）方法，或者finalize（）方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。</li>\n<li>如果这个对象被判定为有必要执行finalize（）方法，那么这个对象将会放置在一个叫做<strong>F-Queue</strong>的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。但<strong>此线程不保证一定会等待finalize()方法运行结束</strong>，这是为了防止发生死循环时其他队列中的对象无法执行finalize()。finalize（）方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，<strong>如果对象要在finalize（）中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可</strong>，如果对象没能在finalize()中建立关联，那么它就会真的被回收了。</li>\n</ol>\n<h2 id=\"2-垃圾回收算法\"><a href=\"#2-垃圾回收算法\" class=\"headerlink\" title=\"2. 垃圾回收算法\"></a>2. 垃圾回收算法</h2><h3 id=\"2-1-标记-清除算法\"><a href=\"#2-1-标记-清除算法\" class=\"headerlink\" title=\"2.1 标记-清除算法\"></a>2.1 标记-清除算法</h3><p>这种算法是最基础的手机算法，言简意赅，算法分为“标记”和“清除”（Mark-Sweep）两个阶段：<strong>首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象</strong>。</p>\n<p>在JVM中，标记过程就是上文说的回收前的筛选判断（两次标记）。这种算法相当简单，但是仍然不经常使用它，它的主要不足有两个：<strong>一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作</strong>。</p>\n<h3 id=\"2-2-复制算法\"><a href=\"#2-2-复制算法\" class=\"headerlink\" title=\"2.2 复制算法\"></a>2.2 复制算法</h3><p>为了解决效率问题，一种称为“复制”（Copying）的收集算法出现了，<strong>它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</strong></p>\n<p>这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将<strong>内存缩小为了原来的一半</strong>，未免太高了一点。</p>\n<h3 id=\"2-3-标记-整理算法\"><a href=\"#2-3-标记-整理算法\" class=\"headerlink\" title=\"2.3 标记-整理算法\"></a>2.3 标记-整理算法</h3><p>还有一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。</p>\n<p>在JVM中，主要使用的<strong>复制算法</strong>和<strong>标记-整理算法</strong>，他们分别针对不同生命周期的对象。</p>\n<h2 id=\"3-分代垃圾回收\"><a href=\"#3-分代垃圾回收\" class=\"headerlink\" title=\"3. 分代垃圾回收\"></a>3. 分代垃圾回收</h2><p>当前商业虚拟机的垃圾回收都采用<strong>分代收集</strong>的思想，就是根据对象的生命周期将内存划分为几块，一般是把Java堆中分为<strong>新生代和老年代</strong>。</p>\n<p>新生代的区域存储刚被创建出来的对象，一般有研究表明，新生代中的对象98%是“朝生夕死”的，而在经历了n次垃圾回收后仍然存活的对象，则会被放到老年代，一般老年代中的对象生命周期都较长。</p>\n<p>虚拟机对不同的区域采用不同的垃圾回收算法，由于新生代大多数对象生命周期极短，因此采用改良后的复制算法来回收。</p>\n<p>不是按照1:1的比例来划分内存空间，而是<strong>将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。</strong></p>\n<p>HotSpot虚拟机默认Eden和Survivor的大小比例是8:1，因此每次只会浪费10%的空间。但是我们不能断定，某次新生代的垃圾回收之后，10%的内存一定装得下存活的实例对象，因此当Survivor对象不够用时，需要依赖其他内存进行分配担保。</p>\n<p><strong>如果另外一块Survivor空间没有足够空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代。</strong></p>\n<p>对于老年代，虚拟机采用的垃圾回收算法是<strong>标记-整理</strong>算法，一方面老年代对象不多，使用这种算法效率略低可以接受，另一方面也可以清理出整块的内存，方便后续的内存分配。</p>\n<h2 id=\"4-垃圾收集器\"><a href=\"#4-垃圾收集器\" class=\"headerlink\" title=\"4. 垃圾收集器\"></a>4. 垃圾收集器</h2><p><img src=\"https://img-blog.csdnimg.cn/81b0bee23de84984be80643c396c9131.PNG\"></p>\n<p>如图，这是HotSpot虚拟机包含的所有收集器，如果两个收集器存在连线，就说明它们可以搭配使用，虚拟机所处的区域，则表示它是属于新生代收集器还是老年代收集器。</p>\n<h3 id=\"4-1-Serial收集器\"><a href=\"#4-1-Serial收集器\" class=\"headerlink\" title=\"4.1 Serial收集器\"></a>4.1 Serial收集器</h3><p>它是最基本，发展历史最悠久的收集器，它是单线程收集器，在进行垃圾收集时丙戌暂停其他所有线程，直到它收集结束。</p>\n<p>看起来它效率很低，但实际上，它依然是虚拟机运行在Client（客户端）模式下的默认新生代收集器。</p>\n<p>它有着自己的优点：简单高效、没有线程交互开销，对于内存没有非常大的新生代已经足够使用了。</p>\n<h3 id=\"4-2-ParNew收集器\"><a href=\"#4-2-ParNew收集器\" class=\"headerlink\" title=\"4.2 ParNew收集器\"></a>4.2 ParNew收集器</h3><p>它是Serial收集器的多线程版本，除此之外它就没什么创新之处了，它第一次实现了让垃圾收集线程与用户线程同时工作</p>\n<h2 id=\"5-垃圾回收调优\"><a href=\"#5-垃圾回收调优\" class=\"headerlink\" title=\"5. 垃圾回收调优\"></a>5. 垃圾回收调优</h2>","feature":true,"text":"JVM垃圾回收1. 如何判断对象可以回收1.1 简要介绍： 引用计数法，如果某个对象被引用了，则他的计数加1，不再被引用了，则减1，计数为0则回收。弊端：循环引用，比如a和b相互引用，即使他们两个永远都不再被使用了，但是由于存在引用计数，所以永远都不会被回收。早期python虚拟...","link":"","photos":[],"count_time":{"symbolsCount":"5.3k","symbolsTime":"5 mins."},"categories":[{"name":"技术学习","slug":"技术学习","count":6,"path":"api/categories/技术学习.json"}],"tags":[{"name":"Java","slug":"Java","count":5,"path":"api/tags/Java.json"},{"name":"JVM","slug":"JVM","count":3,"path":"api/tags/JVM.json"},{"name":"源码分析","slug":"源码分析","count":3,"path":"api/tags/源码分析.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#JVM%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6\"><span class=\"toc-text\">JVM垃圾回收</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E5%9B%9E%E6%94%B6\"><span class=\"toc-text\">1. 如何判断对象可以回收</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-%E7%AE%80%E8%A6%81%E4%BB%8B%E7%BB%8D%EF%BC%9A\"><span class=\"toc-text\">1.1 简要介绍：</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-%E5%8F%AF%E8%BE%BE%E6%80%A7%E5%88%86%E6%9E%90%E7%AE%97%E6%B3%95%EF%BC%9A\"><span class=\"toc-text\">1.2 可达性分析算法：</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#%E5%93%AA%E4%BA%9B%E5%AF%B9%E8%B1%A1%E5%8F%AF%E4%BB%A5%E4%BD%9C%E4%B8%BAGC-Root%E5%AF%B9%E8%B1%A1\"><span class=\"toc-text\">哪些对象可以作为GC Root对象</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-3-%E5%9B%9B%E7%A7%8D%E5%BC%95%E7%94%A8\"><span class=\"toc-text\">1.3 四种引用</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-4-%E5%9B%9E%E6%94%B6%E5%89%8D%E7%9A%84%E7%AD%9B%E9%80%89%E5%88%A4%E6%96%AD\"><span class=\"toc-text\">1.4 回收前的筛选判断</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">2. 垃圾回收算法</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-%E6%A0%87%E8%AE%B0-%E6%B8%85%E9%99%A4%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">2.1 标记-清除算法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-%E5%A4%8D%E5%88%B6%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">2.2 复制算法</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3-%E6%A0%87%E8%AE%B0-%E6%95%B4%E7%90%86%E7%AE%97%E6%B3%95\"><span class=\"toc-text\">2.3 标记-整理算法</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#3-%E5%88%86%E4%BB%A3%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6\"><span class=\"toc-text\">3. 分代垃圾回收</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#4-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8\"><span class=\"toc-text\">4. 垃圾收集器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-1-Serial%E6%94%B6%E9%9B%86%E5%99%A8\"><span class=\"toc-text\">4.1 Serial收集器</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#4-2-ParNew%E6%94%B6%E9%9B%86%E5%99%A8\"><span class=\"toc-text\">4.2 ParNew收集器</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#5-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E8%B0%83%E4%BC%98\"><span class=\"toc-text\">5. 垃圾回收调优</span></a></li></ol></li></ol>","author":{"name":"南望","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/db609a2e507d4a36b32e06b4676aad38.PNG","link":"/","description":"路漫漫其修远兮，吾将上下而求索······","socials":{"github":"https://github.com/saw96x","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/saw96x","csdn":"https://blog.csdn.net/saw96x?spm=1001.2101.3001.5343","juejin":"","customs":{}}},"mapped":true,"prev_post":{},"next_post":{"title":"JVM内存结构","uid":"f0feb27731f09def8e6fa03e806c3c89","slug":"JVM内存结构","date":"2021-08-12T02:01:18.000Z","updated":"2021-08-12T02:01:08.366Z","comments":true,"path":"api/articles/JVM内存结构.json","cover":"https://img-blog.csdnimg.cn/894fb565727048428c86ad9706a6948b.jpg","text":"本篇笔记不定期更新 内存结构图先上图这张图差不多就把JVM的内存结构以及和class源文件，JVM执行引擎，以及操作系统自带的本地方法接口之间的关系囊括进去了。 下面我们就JVM内存结构的几个组成部分来逐一简单介绍一下 1. 程序计数器1.1 定义Program Counter ...","link":"","photos":[],"count_time":{"symbolsCount":"4.1k","symbolsTime":"4 mins."},"categories":[{"name":"技术学习","slug":"技术学习","count":6,"path":"api/categories/技术学习.json"}],"tags":[{"name":"Java","slug":"Java","count":5,"path":"api/tags/Java.json"},{"name":"JVM","slug":"JVM","count":3,"path":"api/tags/JVM.json"}],"author":{"name":"南望","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/db609a2e507d4a36b32e06b4676aad38.PNG","link":"/","description":"路漫漫其修远兮，吾将上下而求索······","socials":{"github":"https://github.com/saw96x","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/saw96x","csdn":"https://blog.csdn.net/saw96x?spm=1001.2101.3001.5343","juejin":"","customs":{}}},"feature":true}}