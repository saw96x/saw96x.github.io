{"title":"带图形界面的贪吃蛇","uid":"199a087d49b9cdfd27d9b5eda9606895","slug":"带图形界面的贪吃蛇","date":"2021-08-13T03:40:46.000Z","updated":"2021-08-13T03:46:43.432Z","comments":true,"path":"api/articles/带图形界面的贪吃蛇.json","cover":"https://img-blog.csdnimg.cn/3f7704d76adf4372a345bc06fe28692d.jpg","content":"<p>比较早的代码了，属于典型的为了面向对象而面向对象的代码。。。<br>运行环境VS2019，图形由easyx库实现：<a href=\"https://easyx.cn/%E3%80%82\">https://easyx.cn/。</a></p>\n<p>已经在注释中写出了出现的eaysx库函数的基本作用，注释前带“*”的是easyx的库函数，详情请查阅文档<a href=\"https://docs.easyx.cn/zh-cn/intro\">https://docs.easyx.cn/zh-cn/intro</a></p>\n<p>完整的源码见最下方</p>\n<hr>\n<h1 id=\"成品\"><a href=\"#成品\" class=\"headerlink\" title=\"成品\"></a>成品</h1><p><img src=\"https://img-blog.csdnimg.cn/20200601212808270.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhdzk2eA==,size_16,color_FFFFFF,t_70\" alt=\"在这里插入图片描述\"></p>\n<h1 id=\"基本游戏框架搭建\"><a href=\"#基本游戏框架搭建\" class=\"headerlink\" title=\"基本游戏框架搭建\"></a>基本游戏框架搭建</h1><p>main函数：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include &quot;Snake.h&quot;\nusing namespace std;\nint main()\n&#123;\n\tSnake my_snake;\n\tmy_snake.startup();\n\twhile (1)\n\t&#123;\n\t\tmy_snake.clean();\n\t\tmy_snake.UpdateWithoutInput();\n\t\tmy_snake.UpdateWithInput();\n\t\tmy_snake.show();\n\t&#125;\n\tmy_snake.gameover();\n\treturn 0;\n&#125;</code></pre>\n<p>第一行通过无参的构造函数初始化数据，包括界面宽度等等<br>startup开始生成画面<br>进入循环，包括：</p>\n<ul>\n<li>清除旧画面</li>\n<li>更新无需用户输入的数据</li>\n<li>更新需要用户输入的数据</li>\n<li>根据更新后的数据生成新画面，从而达到动画效果</li>\n</ul>\n<p>（退出游戏的部分在UpdateWithoutInput中。）</p>\n<h1 id=\"Snake类\"><a href=\"#Snake类\" class=\"headerlink\" title=\"Snake类\"></a>Snake类</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#pragma once\n#include&lt;graphics.h&gt;\n#include&lt;Windows.h&gt;\n#include&lt;conio.h&gt;\n#include&lt;ctime&gt;\n#include&lt;vector&gt;\n#include&lt;cstdlib&gt;\nusing namespace std;\nclass Snake\n&#123;\npublic:\n\tSnake();\n\tbool check();&#x2F;&#x2F;检测生成的食物是否和蛇重合了\n\tvoid SnakeMove();\n\tvoid startup();\n\tvoid clean();\n\tvoid show();\n\tvoid UpdateWithoutInput();\n\tvoid UpdateWithInput();\n\tvoid gameover();\nprivate:\n\tint High;\n\tint Width;\n\tint Background;\n\tint dir;&#x2F;&#x2F;方向\n\tint score;\n\tint speed;&#x2F;&#x2F;画面更新速度，动态难度\n\tint food_x, food_y;\n\tvector&lt;int&gt; snake_x, snake_y; &#x2F;&#x2F;蛇的每一节的坐标\n&#125;;</code></pre>\n\n<p>食物只出现一次，所以直接用int类型作为坐标<br>蛇的长度理论上来说是可以无限增长的，因此使用vector来保存蛇的每一节的坐标。</p>\n<h1 id=\"初始化\"><a href=\"#初始化\" class=\"headerlink\" title=\"初始化\"></a>初始化</h1><p>初始化的函数包括Snake的无参构造函数和startup函数：</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">Snake::Snake() \n&#123;\n\tHigh &#x3D; 720;\n\tWidth &#x3D; 1280;\n\tBackground &#x3D; LIGHTGRAY;&#x2F;&#x2F;*easyx的颜色宏\n\tdir &#x3D; 5;&#x2F;&#x2F;方向参考1235键位，类似wasd\n\tscore &#x3D; 0;\n\tspeed &#x3D; 300;\n\tfood_x &#x3D; rand() % (Width-40) + 21; &#x2F;&#x2F;限定食物出现在屏幕范围内\n\tfood_y &#x3D; rand() % (High-40) + 21;\n\tsnake_x.resize(4), snake_y.resize(4);&#x2F;&#x2F;蛇的初始长度为4\n&#125;\nvoid Snake::startup() \n&#123;\n\tsrand((unsigned int)(time)(NULL));\n\tinitgraph(Width, High);&#x2F;&#x2F;*easyx初始化函数，以参数生成相应分辨率的窗口\n\tsetbkcolor(Background);&#x2F;&#x2F;*设置背景色\n\tcleardevice();&#x2F;&#x2F;*清空原有背景\n\t\n\tfor (int i &#x3D; 0; i &lt; 4; i++)&#x2F;&#x2F;初始化蛇的坐标数据\n\t&#123;\n\t\tsnake_x[i] &#x3D; Width &#x2F; 2 - 40 * i;\n\t\tsnake_y[i] &#x3D; High &#x2F; 2;\n\t&#125;\n\t\n\tBeginBatchDraw();&#x2F;&#x2F;*\n\t&#x2F;&#x2F;这个函数用于开始批量绘图。\n\t&#x2F;&#x2F;执行后，任何绘图操作都将暂时不输出到绘图窗口上，\n\t&#x2F;&#x2F;直到执行 FlushBatchDraw 或 EndBatchDraw 才将之前的绘图输出。\n\t&#x2F;&#x2F;主要的用处是保证刷新画面不发生屏幕闪烁\n&#125;</code></pre>\n\n<h1 id=\"动画效果\"><a href=\"#动画效果\" class=\"headerlink\" title=\"动画效果\"></a>动画效果</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">void Snake::clean() \n&#123;\n\tsetlinecolor(Background);&#x2F;&#x2F;*设置线的颜色\n\tsetfillcolor(Background);&#x2F;&#x2F;*设置填充色\n\tfor (unsigned i &#x3D; 0; i &lt; snake_x.size(); i++)\n\t&#123;\n\t\tfillcircle(snake_x[i], snake_y[i], 20);&#x2F;&#x2F;*画圆\n\t&#125;\n&#125;\n\nvoid Snake::show() \n&#123;\n\tfor (unsigned i &#x3D; 0; i &lt; snake_x.size(); i++) \n\t&#123;\n\t\tif (i &#x3D;&#x3D; 0) \n\t\t&#123;\n\t\t\tsetfillcolor(LIGHTMAGENTA);\n\t\t\tfillcircle(snake_x[i], snake_y[i], 20);\n\t\t&#125;\n\t\telse \n\t\t&#123;\n\t\t\tsetfillcolor(LIGHTRED);\n\t\t\tfillcircle(snake_x[i], snake_y[i], 20);\n\t\t&#125;\n\t&#125;\n\t\n\tFlushBatchDraw();&#x2F;&#x2F;*与BeginBatchDraw配合使用\n\tsetfillcolor(YELLOW);\n\t&#x2F;&#x2F;*以下均为字体设置与字体显示，用于显示分数\n\tTCHAR s[5];\n\tfillcircle(food_x, food_y, 20);\n\tsettextstyle(60, 0, _T(&quot;宋体&quot;));\n\tsettextcolor(RGB(25, 32, 94));\n\t_stprintf_s(s, 5, _T(&quot;%d&quot;), score);\n\touttextxy(430, 620, _T(&quot;Score:&quot;));\n\touttextxy(640, 620, s);\n\n\tSleep(speed);&#x2F;&#x2F;用sleep控制速度，speed越小蛇动的越快\n&#125;</code></pre>\n\n<p>动画效果通过clean和show配合。</p>\n<p>clean绘制背景色的圆，达到擦除的效果，然后show再绘制新的圆，达成动画效果。</p>\n<h1 id=\"蛇的移动\"><a href=\"#蛇的移动\" class=\"headerlink\" title=\"蛇的移动\"></a>蛇的移动</h1><p>这个地方算是核心了</p>\n<pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">void Snake::SnakeMove() \n&#123;\n\tsrand((unsigned int)(time)(NULL));\n\t&#x2F;&#x2F;如果蛇头的坐标和食物的坐标有一定程度的重合，那么在蛇尾增加新的坐标\n\tif (food_x &gt;&#x3D; snake_x[0] - 20 &amp;&amp;\n\t\tfood_x &lt;&#x3D; snake_x[0] + 20 &amp;&amp;\n\t\tfood_y &gt;&#x3D; snake_y[0] - 20 &amp;&amp;\n\t\tfood_y &lt;&#x3D; snake_y[0] + 20) \n\t&#123;\n\t\tif (dir &#x3D;&#x3D; 1) \n\t\t&#123;\n\t\t\tsnake_x.push_back(snake_x[snake_x.size() - 1] + 40);\n\t\t\tsnake_y.push_back(snake_y[snake_y.size() - 1]);\n\t\t&#125;\n\t\telse if (dir &#x3D;&#x3D; 2)\n\t\t&#123;\n\t\t\tsnake_x.push_back(snake_x[snake_x.size() - 1]);\n\t\t\tsnake_y.push_back(snake_y[snake_y.size() - 1] - 40);\n\t\t&#125;\n\t\telse if (dir &#x3D;&#x3D; 3) \n\t\t&#123;\n\t\t\tsnake_x.push_back(snake_x[snake_x.size() - 1] - 40);\n\t\t\tsnake_y.push_back(snake_y[snake_y.size() - 1]);\n\t\t&#125;\n\t\telse if (dir &#x3D;&#x3D; 5) \n\t\t&#123;\n\t\t\tsnake_x.push_back(snake_x[snake_x.size() - 1]);\n\t\t\tsnake_y.push_back(snake_y[snake_y.size() - 1] + 40);\n\t\t&#125;\n\t\t\n\t\tscore++;&#x2F;&#x2F;加分\n\t\tif (speed &gt;&#x3D; 150) &#x2F;&#x2F;调整速度\n\t\t&#123;\n\t\t\tspeed -&#x3D; 5 * score;\n\t\t&#125;\n\t\t&#x2F;&#x2F;擦除旧食物，更新食物的坐标\n\t\tsetlinecolor(Background)；\n\t\tsetfillcolor(Background);\n\t\tfillcircle(food_x, food_y, 20);\n\t\tfood_x &#x3D; rand() % (Width - 40) + 21;\n\t\tfood_y &#x3D; rand() % (High - 40) + 21;\n\t\t&#x2F;&#x2F;如果生成的食物坐标和蛇重合了，再更新食物的坐标,check是检测是否重合的函数。\n\t\twhile (!check()) \n\t\t&#123;\n\t\t\tfood_x &#x3D; rand() % (Width - 40) + 21;\n\t\t\tfood_y &#x3D; rand() % (High - 40) + 21;\n\t\t&#125;\n\t&#125;\n\t&#x2F;&#x2F;蛇移动，通过从后往前迭代更新坐标，形成移动\n\tfor (int i &#x3D; snake_x.size() - 1; i &gt; 0; i--)\n\t&#123;\n\t\tsnake_x[i] &#x3D; snake_x[i - 1];\n\t\tsnake_y[i] &#x3D; snake_y[i - 1];\n\t&#125;\n\t&#x2F;&#x2F;头节点根据方向特殊处理\n\tif (dir &#x3D;&#x3D; 1) \n\t&#123;\n\t\tsnake_x[0] &#x3D; snake_x[1] - 40;\n\t\tsnake_y[0] &#x3D; snake_y[1];\n\t&#125;\n\telse if (dir &#x3D;&#x3D; 2) \n\t&#123;\n\t\tsnake_x[0] &#x3D; snake_x[1];\n\t\tsnake_y[0] &#x3D; snake_y[1] + 40;\n\t&#125;\n\telse if (dir &#x3D;&#x3D; 3) \n\t&#123;\n\t\tsnake_x[0] &#x3D; snake_x[1] + 40;\n\t\tsnake_y[0] &#x3D; snake_y[1];\n\t&#125;\n\telse if (dir &#x3D;&#x3D; 5) \n\t&#123;\n\t\tsnake_x[0] &#x3D; snake_x[1];\n\t\tsnake_y[0] &#x3D; snake_y[1] - 40;\n\t&#125;\n\t&#x2F;&#x2F;检测是否撞墙或者咬到自己了\n\tfor (unsigned i &#x3D; 1; i &lt; snake_x.size(); i++)\n\t&#123;\n\t\tif ((snake_x[0] &gt;&#x3D; snake_x[i] - 20 &amp;&amp;\n\t\t\tsnake_x[0] &lt;&#x3D; snake_x[i] + 20 &amp;&amp;\n\t\t\tsnake_y[0] &gt;&#x3D; snake_y[i] - 20 &amp;&amp;\n\t\t\tsnake_y[0] &lt;&#x3D; snake_y[i] + 20) ||\n\t\t\t((snake_x[0] - 20 &lt;&#x3D; 0) ||\n\t\t\t(snake_x[0] + 20 &gt;&#x3D; 1280) ||\n\t\t\t\t(snake_y[0] - 20 &lt;&#x3D; 0) ||\n\t\t\t\t(snake_y[0] + 20 &gt;&#x3D; 720))) \n\t\t&#123;&#x2F;&#x2F;停留三秒退出游戏\n\t\t\tSleep(3000);\n\t\t\texit(0);\n\t\t&#125;\n\t&#125;\n&#125;\n\nbool Snake::check() \n&#123;\n\tfor (int i &#x3D; 0; i &lt; snake_x.size(); i++) \n\t&#123;\n\t\tif ((food_x &gt;&#x3D; snake_x[i] - 40 &amp;&amp; food_x &lt;&#x3D; snake_x[i] + 40) &amp;&amp;\n\t\t\t(food_y &gt;&#x3D; snake_y[i] - 40 &amp;&amp; food_y &lt;&#x3D; snake_y[i] + 40))\n\t\t\treturn false;\n\t&#125;\n\treturn true;\n&#125;</code></pre>\n<h1 id=\"数据更新\"><a href=\"#数据更新\" class=\"headerlink\" title=\"数据更新\"></a>数据更新</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">void Snake::UpdateWithoutInput() \n&#123;\n\tSnakeMove();\n&#125;\nvoid Snake::UpdateWithInput()\n&#123;\n\tchar input;\n\tif (_kbhit()) &#x2F;&#x2F;kbhit检测是否敲击键盘\n\t&#123;&#x2F;&#x2F;用getch获取用户输入，然后作条件判断来确定蛇如何移动\n\t\tinput &#x3D; _getch();\n\t\tif ((input &#x3D;&#x3D; &#39;a&#39; || input &#x3D;&#x3D; &#39;1&#39;) &amp;&amp; dir !&#x3D; 3) &#x2F;&#x2F;无法向当前方向的方向移动，下同\n\t\t&#123;\n\t\t\tdir &#x3D; 1;\n\t\t\tSnakeMove();\n\t\t&#125;\n\t\telse if ((input &#x3D;&#x3D; &#39;s&#39; || input &#x3D;&#x3D; &#39;2&#39;) &amp;&amp; dir !&#x3D; 5)\n\t\t&#123;\n\t\t\tdir &#x3D; 2;\n\t\t\tSnakeMove();\n\t\t&#125;\n\t\telse if ((input &#x3D;&#x3D; &#39;w&#39; || input &#x3D;&#x3D; &#39;5&#39;) &amp;&amp; dir !&#x3D; 2) \n\t\t&#123;\n\t\t\tdir &#x3D; 5;\n\t\t\tSnakeMove();\n\t\t&#125;\n\t\telse if ((input &#x3D;&#x3D; &#39;d&#39; || input &#x3D;&#x3D; &#39;3&#39;) &amp;&amp; dir !&#x3D; 1)\n\t\t&#123;\n\t\t\tdir &#x3D; 3;\n\t\t\tSnakeMove();\n\t\t&#125;\n\t\tif (input &#x3D;&#x3D; 27) &#x2F;&#x2F;如果按esc就暂停游戏，esc的ASCII码是27\n\t\t&#123;\n\t\t\tinput &#x3D; &#39;n&#39;;\n\t\t\twhile (1) \n\t\t\t&#123;\n\t\t\t\tinput &#x3D; _getch();\n\t\t\t\tif (input &#x3D;&#x3D; 27)\n\t\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;</code></pre>\n\n<h1 id=\"结束游戏\"><a href=\"#结束游戏\" class=\"headerlink\" title=\"结束游戏\"></a>结束游戏</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">void Snake::gameover() \n&#123;\n\tEndBatchDraw();&#x2F;&#x2F;*配合另外两个BatchDraw\n\tclosegraph();&#x2F;&#x2F;*关闭窗口\n&#125;</code></pre>\n\n<h1 id=\"源码\"><a href=\"#源码\" class=\"headerlink\" title=\"源码\"></a>源码</h1><pre class=\"line-numbers language-cpp\" data-language=\"cpp\"><code class=\"language-cpp\">#include&lt;graphics.h&gt;\n#include&lt;Windows.h&gt;\n#include&lt;conio.h&gt;\n#include&lt;ctime&gt;\n#include&lt;vector&gt;\n#include&lt;cstdlib&gt;\nusing namespace std;\nclass Snake\n&#123;\npublic:\n\tSnake();\n\tbool check();&#x2F;&#x2F;检测生成的食物是否和蛇重合了\n\tvoid SnakeMove();\n\tvoid startup();\n\tvoid clean();\n\tvoid show();\n\tvoid UpdateWithoutInput();\n\tvoid UpdateWithInput();\n\tvoid gameover();\nprivate:\n\tint High;\n\tint Width;\n\tint Background;\n\tint dir;&#x2F;&#x2F;方向\n\tint score;\n\tint speed;&#x2F;&#x2F;画面更新速度，动态难度\n\tint food_x, food_y;\n\tvector&lt;int&gt; snake_x, snake_y; &#x2F;&#x2F;蛇的每一节的坐标\n&#125;;\nSnake::Snake()\n&#123;\n\tHigh &#x3D; 720;\n\tWidth &#x3D; 1280;\n\tBackground &#x3D; LIGHTGRAY;&#x2F;&#x2F;easyx的颜色宏\n\tdir &#x3D; 5;&#x2F;&#x2F;方向参考1235键位，类似wasd\n\tscore &#x3D; 0;\n\tspeed &#x3D; 300;\n\tfood_x &#x3D; rand() % (Width - 40) + 21; &#x2F;&#x2F;限定食物出现在屏幕范围内\n\tfood_y &#x3D; rand() % (High - 40) + 21;\n\tsnake_x.resize(4), snake_y.resize(4);&#x2F;&#x2F;蛇的初始长度为4\n&#125;\nbool Snake::check()\n&#123;\n\tfor (int i &#x3D; 0; i &lt; snake_x.size(); i++)\n\t&#123;\n\t\tif ((food_x &gt;&#x3D; snake_x[i] - 40 &amp;&amp; food_x &lt;&#x3D; snake_x[i] + 40) &amp;&amp;\n\t\t\t(food_y &gt;&#x3D; snake_y[i] - 40 &amp;&amp; food_y &lt;&#x3D; snake_y[i] + 40))\n\t\t\treturn false;\n\t&#125;\n\treturn true;\n&#125;\nvoid Snake::SnakeMove()\n&#123;\n\tsrand((unsigned int)(time)(NULL));\n\t&#x2F;&#x2F;如果蛇头的坐标和食物的坐标有一定程度的重合，那么在蛇尾增加新的坐标\n\tif (food_x &gt;&#x3D; snake_x[0] - 20 &amp;&amp;\n\t\tfood_x &lt;&#x3D; snake_x[0] + 20 &amp;&amp;\n\t\tfood_y &gt;&#x3D; snake_y[0] - 20 &amp;&amp;\n\t\tfood_y &lt;&#x3D; snake_y[0] + 20)\n\t&#123;\n\t\tif (dir &#x3D;&#x3D; 1)\n\t\t&#123;\n\t\t\tsnake_x.push_back(snake_x[snake_x.size() - 1] + 40);\n\t\t\tsnake_y.push_back(snake_y[snake_y.size() - 1]);\n\t\t&#125;\n\t\telse if (dir &#x3D;&#x3D; 2)\n\t\t&#123;\n\t\t\tsnake_x.push_back(snake_x[snake_x.size() - 1]);\n\t\t\tsnake_y.push_back(snake_y[snake_y.size() - 1] - 40);\n\t\t&#125;\n\t\telse if (dir &#x3D;&#x3D; 3)\n\t\t&#123;\n\t\t\tsnake_x.push_back(snake_x[snake_x.size() - 1] - 40);\n\t\t\tsnake_y.push_back(snake_y[snake_y.size() - 1]);\n\t\t&#125;\n\t\telse if (dir &#x3D;&#x3D; 5)\n\t\t&#123;\n\t\t\tsnake_x.push_back(snake_x[snake_x.size() - 1]);\n\t\t\tsnake_y.push_back(snake_y[snake_y.size() - 1] + 40);\n\t\t&#125;\n\n\t\tscore++;&#x2F;&#x2F;加分\n\t\tif (speed &gt;&#x3D; 150) &#x2F;&#x2F;调整速度\n\t\t&#123;\n\t\t\tspeed -&#x3D; 5 * score;\n\t\t&#125;\n\t\t&#x2F;&#x2F;擦除旧食物，更新食物的坐标\n\t\tsetlinecolor(Background);\n\t\t\tsetfillcolor(Background);\n\t\tfillcircle(food_x, food_y, 20);\n\t\tfood_x &#x3D; rand() % (Width - 40) + 21;\n\t\tfood_y &#x3D; rand() % (High - 40) + 21;\n\t\t&#x2F;&#x2F;如果生成的食物坐标和蛇重合了，再更新食物的坐标,check是检测是否重合的函数。\n\t\twhile (!check())\n\t\t&#123;\n\t\t\tfood_x &#x3D; rand() % (Width - 40) + 21;\n\t\t\tfood_y &#x3D; rand() % (High - 40) + 21;\n\t\t&#125;\n\t&#125;\n\t&#x2F;&#x2F;蛇移动，通过从后往前迭代更新坐标，形成移动\n\tfor (int i &#x3D; snake_x.size() - 1; i &gt; 0; i--)\n\t&#123;\n\t\tsnake_x[i] &#x3D; snake_x[i - 1];\n\t\tsnake_y[i] &#x3D; snake_y[i - 1];\n\t&#125;\n\t&#x2F;&#x2F;头节点根据方向特殊处理\n\tif (dir &#x3D;&#x3D; 1)\n\t&#123;\n\t\tsnake_x[0] &#x3D; snake_x[1] - 40;\n\t\tsnake_y[0] &#x3D; snake_y[1];\n\t&#125;\n\telse if (dir &#x3D;&#x3D; 2)\n\t&#123;\n\t\tsnake_x[0] &#x3D; snake_x[1];\n\t\tsnake_y[0] &#x3D; snake_y[1] + 40;\n\t&#125;\n\telse if (dir &#x3D;&#x3D; 3)\n\t&#123;\n\t\tsnake_x[0] &#x3D; snake_x[1] + 40;\n\t\tsnake_y[0] &#x3D; snake_y[1];\n\t&#125;\n\telse if (dir &#x3D;&#x3D; 5)\n\t&#123;\n\t\tsnake_x[0] &#x3D; snake_x[1];\n\t\tsnake_y[0] &#x3D; snake_y[1] - 40;\n\t&#125;\n\t&#x2F;&#x2F;检测是否撞墙或者咬到自己了\n\tfor (unsigned i &#x3D; 1; i &lt; snake_x.size(); i++)\n\t&#123;\n\t\tif ((snake_x[0] &gt;&#x3D; snake_x[i] - 20 &amp;&amp;\n\t\t\tsnake_x[0] &lt;&#x3D; snake_x[i] + 20 &amp;&amp;\n\t\t\tsnake_y[0] &gt;&#x3D; snake_y[i] - 20 &amp;&amp;\n\t\t\tsnake_y[0] &lt;&#x3D; snake_y[i] + 20) ||\n\t\t\t((snake_x[0] - 20 &lt;&#x3D; 0) ||\n\t\t\t\t(snake_x[0] + 20 &gt;&#x3D; 1280) ||\n\t\t\t\t(snake_y[0] - 20 &lt;&#x3D; 0) ||\n\t\t\t\t(snake_y[0] + 20 &gt;&#x3D; 720)))\n\t\t&#123;&#x2F;&#x2F;停留三秒退出游戏\n\t\t\tSleep(3000);\n\t\t\texit(0);\n\t\t&#125;\n\t&#125;\n&#125;\nvoid Snake::startup()\n&#123;\n\tsrand((unsigned int)(time)(NULL));\n\tinitgraph(Width, High);\n\tsetbkcolor(Background);\n\tcleardevice();\n\tfor (int i &#x3D; 0; i &lt; 4; i++)\n\t&#123;\n\t\tsnake_x[i] &#x3D; Width &#x2F; 2 - 40 * i;\n\t\tsnake_y[i] &#x3D; High &#x2F; 2;\n\t&#125;\n\tBeginBatchDraw();\n&#125;\nvoid Snake::clean()\n&#123;\n\tsetlinecolor(Background);&#x2F;&#x2F;设置线的颜色\n\tsetfillcolor(Background);&#x2F;&#x2F;设置填充色\n\tfor (unsigned i &#x3D; 0; i &lt; snake_x.size(); i++)\n\t&#123;\n\t\tfillcircle(snake_x[i], snake_y[i], 20);&#x2F;&#x2F;画圆\n\t&#125;\n&#125;\nvoid Snake::show()\n&#123;\n\tfor (unsigned i &#x3D; 0; i &lt; snake_x.size(); i++)\n\t&#123;\n\t\tif (i &#x3D;&#x3D; 0)\n\t\t&#123;\n\t\t\tsetfillcolor(LIGHTMAGENTA);\n\t\t\tfillcircle(snake_x[i], snake_y[i], 20);\n\t\t&#125;\n\t\telse\n\t\t&#123;\n\t\t\tsetfillcolor(LIGHTRED);\n\t\t\tfillcircle(snake_x[i], snake_y[i], 20);\n\t\t&#125;\n\t&#125;\n\n\tFlushBatchDraw();&#x2F;&#x2F;与BeginBatchDraw配合使用\n\tsetfillcolor(YELLOW);\n\t&#x2F;&#x2F;以下均为字体设置与字体显示，用于显示分数\n\tTCHAR s[5];\n\tfillcircle(food_x, food_y, 20);\n\tsettextstyle(60, 0, _T(&quot;宋体&quot;));\n\tsettextcolor(RGB(25, 32, 94));\n\t_stprintf_s(s, 5, _T(&quot;%d&quot;), score);\n\touttextxy(430, 620, _T(&quot;Score:&quot;));\n\touttextxy(640, 620, s);\n\n\tSleep(speed);&#x2F;&#x2F;用sleep控制速度，speed越小蛇动的越快\n&#125;\nvoid Snake::UpdateWithoutInput()\n&#123;\n\tSnakeMove();\n&#125;\nvoid Snake::UpdateWithInput()\n&#123;\n\tchar input;\n\tif (_kbhit())\n\t&#123;\n\t\tinput &#x3D; _getch();\n\t\tif ((input &#x3D;&#x3D; &#39;a&#39; || input &#x3D;&#x3D; &#39;1&#39;) &amp;&amp; dir !&#x3D; 3)\n\t\t&#123;\n\t\t\tdir &#x3D; 1;\n\t\t\tSnakeMove();\n\t\t&#125;\n\t\telse if ((input &#x3D;&#x3D; &#39;s&#39; || input &#x3D;&#x3D; &#39;2&#39;) &amp;&amp; dir !&#x3D; 5)\n\t\t&#123;\n\t\t\tdir &#x3D; 2;\n\t\t\tSnakeMove();\n\t\t&#125;\n\t\telse if ((input &#x3D;&#x3D; &#39;w&#39; || input &#x3D;&#x3D; &#39;5&#39;) &amp;&amp; dir !&#x3D; 2)\n\t\t&#123;\n\t\t\tdir &#x3D; 5;\n\t\t\tSnakeMove();\n\t\t&#125;\n\t\telse if ((input &#x3D;&#x3D; &#39;d&#39; || input &#x3D;&#x3D; &#39;3&#39;) &amp;&amp; dir !&#x3D; 1)\n\t\t&#123;\n\t\t\tdir &#x3D; 3;\n\t\t\tSnakeMove();\n\t\t&#125;\n\t\tif (input &#x3D;&#x3D; 27)\n\t\t&#123;\n\t\t\tinput &#x3D; &#39;n&#39;;\n\t\t\twhile (1)\n\t\t\t&#123;\n\t\t\t\tinput &#x3D; _getch();\n\t\t\t\tif (input &#x3D;&#x3D; 27)\n\t\t\t\t\tbreak;\n\t\t\t&#125;\n\t\t&#125;\n\t&#125;\n&#125;\nvoid Snake::gameover()\n&#123;\n\tEndBatchDraw();\n\tclosegraph();\n&#125;\n\nint main()\n&#123;\n\tSnake my_snake;\n\tmy_snake.startup();\n\twhile (1)\n\t&#123;\n\t\tmy_snake.clean();\n\t\tmy_snake.UpdateWithoutInput();\n\t\tmy_snake.UpdateWithInput();\n\t\tmy_snake.show();\n\t&#125;\n\tmy_snake.gameover();\n\treturn 0;\n&#125;</code></pre>\n","feature":false,"text":"比较早的代码了，属于典型的为了面向对象而面向对象的代码。。。运行环境VS2019，图形由easyx库实现：https://easyx.cn/。 已经在注释中写出了出现的eaysx库函数的基本作用，注释前带“*”的是easyx的库函数，详情请查阅文档https://docs.eas...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[{"name":"技术分享","slug":"技术分享","count":2,"path":"api/categories/技术分享.json"}],"tags":[{"name":"小游戏","slug":"小游戏","count":1,"path":"api/tags/小游戏.json"},{"name":"C++","slug":"C","count":1,"path":"api/tags/C.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%88%90%E5%93%81\"><span class=\"toc-text\">成品</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E6%B8%B8%E6%88%8F%E6%A1%86%E6%9E%B6%E6%90%AD%E5%BB%BA\"><span class=\"toc-text\">基本游戏框架搭建</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Snake%E7%B1%BB\"><span class=\"toc-text\">Snake类</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%88%9D%E5%A7%8B%E5%8C%96\"><span class=\"toc-text\">初始化</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%8A%A8%E7%94%BB%E6%95%88%E6%9E%9C\"><span class=\"toc-text\">动画效果</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%9B%87%E7%9A%84%E7%A7%BB%E5%8A%A8\"><span class=\"toc-text\">蛇的移动</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%95%B0%E6%8D%AE%E6%9B%B4%E6%96%B0\"><span class=\"toc-text\">数据更新</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9D%9F%E6%B8%B8%E6%88%8F\"><span class=\"toc-text\">结束游戏</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%BA%90%E7%A0%81\"><span class=\"toc-text\">源码</span></a></li></ol>","author":{"name":"南望","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/db609a2e507d4a36b32e06b4676aad38.PNG","link":"/","description":"路漫漫其修远兮，吾将上下而求索······","socials":{"github":"https://github.com/saw96x","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/saw96x","csdn":"https://blog.csdn.net/saw96x?spm=1001.2101.3001.5343","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"HotSpot虚拟机对象探秘","uid":"c26847ef99f42b8a854d63bbf2df96ed","slug":"HotSpot虚拟机对象探秘","date":"2021-08-14T01:49:37.000Z","updated":"2021-08-14T01:53:26.407Z","comments":true,"path":"api/articles/HotSpot虚拟机对象探秘.json","cover":"https://img-blog.csdnimg.cn/d5af07a1654547758e69d8f48efeea51.jpg","text":"HotSpot虚拟机对象探秘1. 对象的创建1.1 类加载检查虚拟机遇到new之后，首先会去常量池中找这个类的符号引用，并检查这个符号引用代表的类是否已经被加载、解析和初始化过，如果找到了，就可以根据已有的信息划分空间、分配内存、初始化等等；如果没找到，那必须先执行相应的类加载过...","link":"","photos":[],"count_time":{"symbolsCount":"2.7k","symbolsTime":"2 mins."},"categories":[{"name":"学习笔记","slug":"学习笔记","count":7,"path":"api/categories/学习笔记.json"}],"tags":[{"name":"Java","slug":"Java","count":7,"path":"api/tags/Java.json"},{"name":"JVM","slug":"JVM","count":5,"path":"api/tags/JVM.json"},{"name":"深入理解Java虚拟机","slug":"深入理解Java虚拟机","count":5,"path":"api/tags/深入理解Java虚拟机.json"}],"author":{"name":"南望","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/db609a2e507d4a36b32e06b4676aad38.PNG","link":"/","description":"路漫漫其修远兮，吾将上下而求索······","socials":{"github":"https://github.com/saw96x","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/saw96x","csdn":"https://blog.csdn.net/saw96x?spm=1001.2101.3001.5343","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"JVM内存结构","uid":"f0feb27731f09def8e6fa03e806c3c89","slug":"JVM内存结构","date":"2021-08-12T02:01:18.000Z","updated":"2021-08-13T03:30:01.165Z","comments":true,"path":"api/articles/JVM内存结构.json","cover":"https://img-blog.csdnimg.cn/894fb565727048428c86ad9706a6948b.jpg","text":"本篇笔记不定期更新 内存结构图先上图这张图差不多就把JVM的内存结构以及和class源文件，JVM执行引擎，以及操作系统自带的本地方法接口之间的关系囊括进去了。 下面我们就JVM内存结构的几个组成部分来逐一简单介绍一下 1. 程序计数器1.1 定义Program Counter ...","link":"","photos":[],"count_time":{"symbolsCount":"4.1k","symbolsTime":"4 mins."},"categories":[{"name":"学习笔记","slug":"学习笔记","count":7,"path":"api/categories/学习笔记.json"}],"tags":[{"name":"Java","slug":"Java","count":7,"path":"api/tags/Java.json"},{"name":"JVM","slug":"JVM","count":5,"path":"api/tags/JVM.json"},{"name":"深入理解Java虚拟机","slug":"深入理解Java虚拟机","count":5,"path":"api/tags/深入理解Java虚拟机.json"}],"author":{"name":"南望","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/db609a2e507d4a36b32e06b4676aad38.PNG","link":"/","description":"路漫漫其修远兮，吾将上下而求索······","socials":{"github":"https://github.com/saw96x","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/saw96x","csdn":"https://blog.csdn.net/saw96x?spm=1001.2101.3001.5343","juejin":"","customs":{}}},"feature":true}}