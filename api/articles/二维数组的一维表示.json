{"title":"二维数组的一维表示","uid":"35e5216ef5ed6078510a06d5cbe00f49","slug":"二维数组的一维表示","date":"2021-12-03T12:03:47.000Z","updated":"2021-12-11T03:53:28.302Z","comments":true,"path":"api/articles/二维数组的一维表示.json","cover":[],"content":"<h4 id=\"566-重塑矩阵\"><a href=\"#566-重塑矩阵\" class=\"headerlink\" title=\"566. 重塑矩阵\"></a><a href=\"https://leetcode-cn.com/problems/reshape-the-matrix/\">566. 重塑矩阵</a></h4><p>在 MATLAB 中，有一个非常有用的函数 <code>reshape</code> ，它可以将一个 <code>m x n</code> 矩阵重塑为另一个大小不同（<code>r x c</code>）的新矩阵，但保留其原始数据。</p>\n<p>给你一个由二维数组 <code>mat</code> 表示的 <code>m x n</code> 矩阵，以及两个正整数 <code>r</code> 和 <code>c</code> ，分别表示想要的重构的矩阵的行数和列数。</p>\n<p>重构后的矩阵需要将原始矩阵的所有元素以相同的 <strong>行遍历顺序</strong> 填充。</p>\n<p>如果具有给定参数的 <code>reshape</code> 操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/04/24/reshape1-grid.jpg\" alt=\"img\"></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">输入：mat &#x3D; [[1,2],[3,4]], r &#x3D; 1, c &#x3D; 4\n输出：[[1,2,3,4]]<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/04/24/reshape2-grid.jpg\" alt=\"img\"></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">输入：mat &#x3D; [[1,2],[3,4]], r &#x3D; 2, c &#x3D; 4\n输出：[[1,2],[3,4]]<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li><code>m == mat.length</code></li>\n<li><code>n == mat[i].length</code></li>\n<li><code>1 &lt;= m, n &lt;= 100</code></li>\n<li><code>-1000 &lt;= mat[i][j] &lt;= 1000</code></li>\n<li><code>1 &lt;= r, c &lt;= 300</code></li>\n</ul>\n<p>这题我第一次做采用的思路是把原数组转为一维数组，然后再转为新数组，看题解发现，二维数组可以直接做一维数组表示，这无疑大大减轻了时间和空间复杂度。</p>\n","feature":false,"text":"566. 重塑矩阵在 MATLAB 中，有一个非常有用的函数 reshape ，它可以将一个 m x n 矩阵重塑为另一个大小不同（r x c）的新矩阵，但保留其原始数据。 给你一个由二维数组 mat 表示的 m x n 矩阵，以及两个正整数 r 和 c ，分别表示想要的重构的矩...","link":"","photos":[],"count_time":{"symbolsCount":576,"symbolsTime":"1 mins."},"categories":[{"name":"算法笔记","slug":"算法笔记","count":9,"path":"api/categories/算法笔记.json"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","count":9,"path":"api/tags/数据结构与算法.json"},{"name":"LeetCode","slug":"LeetCode","count":5,"path":"api/tags/LeetCode.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#566-%E9%87%8D%E5%A1%91%E7%9F%A9%E9%98%B5\"><span class=\"toc-text\">566. 重塑矩阵</span></a></li></ol>","author":{"name":"南望","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/db609a2e507d4a36b32e06b4676aad38.PNG","link":"/","description":"路漫漫其修远兮，吾将上下而求索······","socials":{"github":"https://github.com/saw96x","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/saw96x","csdn":"https://blog.csdn.net/saw96x?spm=1001.2101.3001.5343","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"LeetCode中经典的链表题","uid":"367463c88a16078125a84825dd49eab4","slug":"LeetCode中经典的链表题","date":"2021-11-22T02:39:39.000Z","updated":"2021-11-24T08:08:44.137Z","comments":true,"path":"api/articles/LeetCode中经典的链表题.json","cover":"https://i.loli.net/2021/08/23/z1OTKikv4DnZftY.jpg","text":"1. 两数相加（LC第2题）给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。 请你将两个数相加，并以相同形式返回一个表示和的链表。 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例 1： 输入...","link":"","photos":[],"count_time":{"symbolsCount":"6.8k","symbolsTime":"6 mins."},"categories":[{"name":"算法笔记","slug":"算法笔记","count":9,"path":"api/categories/算法笔记.json"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","count":9,"path":"api/tags/数据结构与算法.json"},{"name":"LeetCode","slug":"LeetCode","count":5,"path":"api/tags/LeetCode.json"}],"author":{"name":"南望","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/db609a2e507d4a36b32e06b4676aad38.PNG","link":"/","description":"路漫漫其修远兮，吾将上下而求索······","socials":{"github":"https://github.com/saw96x","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/saw96x","csdn":"https://blog.csdn.net/saw96x?spm=1001.2101.3001.5343","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"new_article","uid":"77f9387d0e428e786ca4e7013ad4231a","slug":"DFS入门题","date":"2021-11-27T11:18:14.000Z","updated":"2021-11-27T11:38:10.298Z","comments":true,"path":"api/articles/DFS入门题.json","cover":[],"text":"113. 路径总和 II给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。 叶子节点 是指没有子节点的节点。 示例 1： 输入：root &#x3D; [5,4,8,11,null,13,4,7,2,...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"算法笔记","slug":"算法笔记","count":9,"path":"api/categories/算法笔记.json"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","count":9,"path":"api/tags/数据结构与算法.json"},{"name":"LeetCode","slug":"LeetCode","count":5,"path":"api/tags/LeetCode.json"}],"author":{"name":"南望","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/db609a2e507d4a36b32e06b4676aad38.PNG","link":"/","description":"路漫漫其修远兮，吾将上下而求索······","socials":{"github":"https://github.com/saw96x","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/saw96x","csdn":"https://blog.csdn.net/saw96x?spm=1001.2101.3001.5343","juejin":"","customs":{}}},"feature":false}}