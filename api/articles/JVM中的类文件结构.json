{"title":"JVM中的类文件结构","uid":"581c1d5b4dc9ad92f487897aa0f3fdd0","slug":"JVM中的类文件结构","date":"2021-08-21T01:40:04.000Z","updated":"2021-08-21T01:40:51.425Z","comments":true,"path":"api/articles/JVM中的类文件结构.json","cover":"https://i.loli.net/2021/08/14/kbjcFenifLQaN5x.jpg","content":"<h1 id=\"JVM中的类文件结构\"><a href=\"#JVM中的类文件结构\" class=\"headerlink\" title=\"JVM中的类文件结构\"></a>JVM中的类文件结构</h1><p><strong>Class文件是一组以8个字节为基础单位的二进制流</strong>，各个数据项目中严格按照顺序紧凑排列在一起，中间没有任何分隔符，当遇到了占位8个自己以上空间的数据项时，则会按照高位在前的方式分割成8个字节进行存储。</p>\n<h2 id=\"1-Class文件格式\"><a href=\"#1-Class文件格式\" class=\"headerlink\" title=\"1. Class文件格式\"></a>1. Class文件格式</h2><p>Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：<strong>“无符号数”和“表”</strong>。后面的解析都要以这种数据类型为基础。</p>\n<ul>\n<li>无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，<strong>无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值</strong>。</li>\n<li>表是由多个无符号数或者其他表作为数据项构成的复合数据类型，为了便于区分，所有表的命名都习惯性地以“_info”结尾。<strong>表用于描述有层次关系的复合结构的数据，整个Class文件本质上也可以视作是一张表</strong>。</li>\n</ul>\n<h2 id=\"2-Class文件结构\"><a href=\"#2-Class文件结构\" class=\"headerlink\" title=\"2. Class文件结构\"></a>2. Class文件结构</h2><h3 id=\"2-1-魔数与Class文件的版本\"><a href=\"#2-1-魔数与Class文件的版本\" class=\"headerlink\" title=\"2.1 魔数与Class文件的版本\"></a>2.1 魔数与Class文件的版本</h3><p>每个Class文件的头4个字节被称为<strong>魔数</strong>（Magic Number），<strong>它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件</strong>。很多文件格式都采用这种方式进行格式验证。</p>\n<p>使用魔数当然是基于安全考量，扩展名可以随意改动嘛。Class文件的魔数取得很有“浪漫气息”，值为0xCAFEBABE（咖啡宝贝？）</p>\n<p><strong>紧接着魔数的4个字节存储的是Class文件的版本号</strong>：第5和第6个字节是次版本号（Minor Version），第7和第8个字节是主版本号（Major Version），版本号主要用来判断当前的虚拟机能否运行此class文件，高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件（即使文件格式并未发生变化），这是规范中明确定义的。</p>\n<h3 id=\"2-2-常量池\"><a href=\"#2-2-常量池\" class=\"headerlink\" title=\"2.2 常量池\"></a>2.2 常量池</h3><p>在版本号之后的是常量池入口，常量池可以比喻为Class文件里的资源仓库，<strong>它是Class文件结构中与其他项目关联最多的数据</strong>，通常也是占用Class文件空间最大的数据项目之一，另外，它还是在Class文件中第一个出现的表类型数据项目。</p>\n<p>常量池的入口有一项u2类型的数据，表示常量池容量计数值（constant_pool_count），和编程语言习惯不同的是，<strong>这个计数是从1开始的而非0</strong>，这样做的目的在于，如果后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义，可以把索引值设置为0来表示。只有常量池是例外，其他的结构的容量计数都从0开始。</p>\n<p>常量池中主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）。前者比较接近Java语言层面的常量概念，如文本字符串，被声明为final的常量值。而后者则属于编译原理方面的概念，主要包括以下几类：</p>\n<ul>\n<li>被模块导出或者开放的包（Package）</li>\n<li>被模块导出或者开放的包（Package）</li>\n<li>被模块导出或者开放的包（Package）</li>\n<li>方法的名称和描述符</li>\n<li>方法句柄和方法类型（Method Handle、Method Type、Invoke Dynamic）</li>\n<li>动态调用点和动态常量（Dynamically-Computed Call Site、Dynamically-Computed Constant）</li>\n</ul>\n<p>Java代码在编译时，在class文件中不会保存各方法，字段在内存中的布局信息，只有在虚拟机在做类加载时，才会从常量池中获取对应的符号引用，然后再在类创建时或运行时解析、翻译到具体的内存地址之中。</p>\n<p>常量池中的每一项常量都是一个表，截止至jdk13，常量表中一共有17种不同类型的常量，他们都有一个共同的特点，<strong>表结构起始的第一位是个u1类型的标志位</strong>，代表着当前常量属于哪种常量类型。他们所代表的具体含义如表所示。</p>\n<p><img src=\"https://i.loli.net/2021/08/19/cJI9BKfsXVubHwk.png\" alt=\"捕获.PNG\"></p>\n<p><strong>每种常量的结构中，都有一项类型为u1的tag作为标志位来区分常量类型</strong>，此外，还有各种各样的结构，详情继续看表</p>\n<p><img src=\"https://i.loli.net/2021/08/19/QG2TdunpEbRiIgs.png\" alt=\"1.PNG\"></p>\n<p><img src=\"https://i.loli.net/2021/08/19/6X3QqZEsaUI74BL.png\" alt=\"2.PNG\"></p>\n<p><img src=\"https://i.loli.net/2021/08/19/PQhXIiKm7vuLUEF.png\" alt=\"3.PNG\"></p>\n<p><img src=\"https://i.loli.net/2021/08/19/3mwXEut4piByClL.png\" alt=\"4.PNG\"></p>\n<h3 id=\"2-3-访问标志\"><a href=\"#2-3-访问标志\" class=\"headerlink\" title=\"2.3 访问标志\"></a>2.3 访问标志</h3><p>在常量池结束之后，<strong>紧接着的2个字节代表访问标志（access_flags），这个标志用来识别类或接口的访问信息</strong>，包括：这个class文件是类还是接口；是public还是private；是否定义为abstract；是否被声明为final等等。</p>\n<p>具体含义如表所示</p>\n<p><img src=\"https://i.loli.net/2021/08/21/oYy7mUNLAVnw2HJ.png\" alt=\"捕获.PNG\"></p>\n<p>访问标志中一共有2个字节，也就是16个标记位可以使用，截止到JDK9发布后，定义了9个，没用到的要求一律为0。</p>\n<h3 id=\"2-4-类索引、父类索引与接口索引集合\"><a href=\"#2-4-类索引、父类索引与接口索引集合\" class=\"headerlink\" title=\"2.4 类索引、父类索引与接口索引集合\"></a>2.4 类索引、父类索引与接口索引集合</h3><p>类索引（this_class）和父类索引（super_class）都是一个u2类型的数据，而接口索引集合（interfaces）是一组u2类型的数据的集合，<strong>Class文件中由这三项数据来确定该类型的继承关系</strong>。</p>\n<p><strong>类索引引用确定这个类的全限定明，父类索引引用用去确定它的父类的全限定名</strong>。除了Object外，所有Java类都有父类，所有Java类的父类索引都不为0.</p>\n<p><strong>接口索引集合则用来描述这个类实现了哪些接口</strong>，它们在文件中的排列顺序和implements关键字后的接口顺序一样。</p>\n<p>接口索引集合的第一项u2类型的数据为接口计数器，表示索引表的容量。如果该类没实现任何及接口，则该计数器的值0。</p>\n<p>类索引、父类索引和接口索引集合都按顺序排列在访问标志之后，类索引和父类索引用两个u2类型的索引值表示，它们各自指向一个类型为CONSTANT_Class_info的类描述符常量，通过CONSTANT_Class_info类型的常量中的索引值可以找到定义在CONSTANT_Utf8_info类型的常量中的全限定名字符串。</p>\n<h3 id=\"2-5-字段表集合\"><a href=\"#2-5-字段表集合\" class=\"headerlink\" title=\"2.5 字段表集合\"></a>2.5 字段表集合</h3><p><strong>字段表（field_info）用于描述接口或者类中声明的变量</strong>。Java语言中的字段包括实例变量和类变量（静态变量，用static修饰），不包括方法中的局部变量。</p>\n<p>字段可以包括的修饰符有字段的作用域（public、private、protected修饰符）、是实例变量还是类变量（static修饰符）、可变性（final）、并发可见性（volatile修饰符，是否强制从主内存读写）、可否被序列化（transient修饰符）、字段数据类型（基本类型、对象、数组）、字段名称。</p>\n<p>上述信息中，要么有某个修饰符，要么没有，因此很适合用标志位来表示，而更具体的信息，比如字段名等，这些只能引用常量池中的常量来描述。</p>\n<p>字段表结构如表所示</p>\n<p><img src=\"https://i.loli.net/2021/08/21/Mo9LJ12kpjUdwAi.png\" alt=\"捕获.PNG\"></p>\n<p>字段修饰符放在access_flags中，用来表示是否有某个修饰符，它和类中的access_flags非常像。</p>\n<p><img src=\"https://i.loli.net/2021/08/21/1DNJLkCp2oiOfZm.png\"></p>\n<p>跟随access_flags标志的是两项索引值，name_index和descriptor_index，它们都是对常量池项的引用，分别表示字段的简单名称，字段和方法的描述符。简单名称不说，描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。根据描述符规则，基本数据类型（byte、char、double、float、int、long、short、boolean）以及代表无返回值的void类型都用一个大写字符来表示，而对象类型则用字符L加对象的全限定名来表示。</p>\n<p><img src=\"https://i.loli.net/2021/08/21/J6pXOj8x5D4ua1y.png\" alt=\"捕获.PNG\"></p>\n<p>对于数组类型，每有一个维度就将使用一个前置的”[“字符来描述如一个定义为“java.lang.String[][]”类型的二维数组将被记录成“[[Ljava/lang/String；”。</p>\n<p>用描述符来描述方法时，按照先参数列表、后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号“()”之内。如方法java.lang.String toString()的描述符<br>为“()Ljava/lang/String；”，方法int indexOf(char[]source，int sourceOffset，int sourceCount，char[]target，int targetOffset，int targetCount，int fromIndex)的描述符为“([CII[CIII)I”。</p>\n<p>字段表集合中不会列出从父类或者父接口中继承而来的字段，但有可能出现原本Java代码之中不存在的字段，譬如在内部类中为了保持对外部类的访问性，编译器就会自动添加指向外部类实例的字段。</p>\n<p>还有一个有趣的现象，在Java语言中，字段是无法重载的，但在class文件中，只要两个字段的描述符不是完全相同，那么字段重名是合法的。</p>\n<h3 id=\"2-6-方法表集合\"><a href=\"#2-6-方法表集合\" class=\"headerlink\" title=\"2.6 方法表集合\"></a>2.6 方法表集合</h3><p>class文件存储格式中对方法的描述和对字段的描述采用了几乎完全一致的方式，起含义也非常相似，仅在访问标志和属性表集合的可选项中有所区别。</p>\n<p><img src=\"https://i.loli.net/2021/08/21/zahmFgG4QxWMVPX.png\" alt=\"捕获.PNG\"></p>\n<p>方法的定义通过访问标志，名称索引，描述符索引来表达清楚，而方法中的代码，经过Javac编译器编译成字节码指令之后，存放在方法属性表集合中一个名为“Code”的属性里面。</p>\n<h3 id=\"2-7-属性表集合\"><a href=\"#2-7-属性表集合\" class=\"headerlink\" title=\"2.7 属性表集合\"></a>2.7 属性表集合</h3><p>属性表（attribute_info）在前面的讲解之中已经出现过数次，Class文件、字段表、方法表都可以携带自己的属性表集合，以描述某些场景专有的信息。</p>\n<p>属性表和class文件中其他部分的严格要求不同，属性表集合的限制稍微宽松一<br>些，不再要求各个属性表具有严格顺序，并且《Java虚拟机规范》允许只要不与已有属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，Java虚拟机运行时会忽略掉它不认识的属性。为了能正确解析Class文件，《Java虚拟机规范》最初只预定义了9项所有Java虚拟机实现都应当能识别的属性，而在最新的《Java虚拟机规范》的Java SE 12版本中，预定义属性已经增加到29项。</p>\n<p>属性表的详情我开个新笔记来讲，它内容实在太多了。。</p>\n","feature":false,"text":"JVM中的类文件结构Class文件是一组以8个字节为基础单位的二进制流，各个数据项目中严格按照顺序紧凑排列在一起，中间没有任何分隔符，当遇到了占位8个自己以上空间的数据项时，则会按照高位在前的方式分割成8个字节进行存储。 1. Class文件格式Class文件格式采用一种类似于C...","link":"","photos":[],"count_time":{"symbolsCount":"4k","symbolsTime":"4 mins."},"categories":[{"name":"学习笔记","slug":"学习笔记","count":5,"path":"api/categories/学习笔记.json"}],"tags":[{"name":"Java","slug":"Java","count":6,"path":"api/tags/Java.json"},{"name":"JVM","slug":"JVM","count":4,"path":"api/tags/JVM.json"},{"name":"深入理解Java虚拟机","slug":"深入理解Java虚拟机","count":4,"path":"api/tags/深入理解Java虚拟机.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#JVM%E4%B8%AD%E7%9A%84%E7%B1%BB%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">JVM中的类文件结构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-Class%E6%96%87%E4%BB%B6%E6%A0%BC%E5%BC%8F\"><span class=\"toc-text\">1. Class文件格式</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#2-Class%E6%96%87%E4%BB%B6%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">2. Class文件结构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-1-%E9%AD%94%E6%95%B0%E4%B8%8EClass%E6%96%87%E4%BB%B6%E7%9A%84%E7%89%88%E6%9C%AC\"><span class=\"toc-text\">2.1 魔数与Class文件的版本</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-2-%E5%B8%B8%E9%87%8F%E6%B1%A0\"><span class=\"toc-text\">2.2 常量池</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-3-%E8%AE%BF%E9%97%AE%E6%A0%87%E5%BF%97\"><span class=\"toc-text\">2.3 访问标志</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-4-%E7%B1%BB%E7%B4%A2%E5%BC%95%E3%80%81%E7%88%B6%E7%B1%BB%E7%B4%A2%E5%BC%95%E4%B8%8E%E6%8E%A5%E5%8F%A3%E7%B4%A2%E5%BC%95%E9%9B%86%E5%90%88\"><span class=\"toc-text\">2.4 类索引、父类索引与接口索引集合</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-5-%E5%AD%97%E6%AE%B5%E8%A1%A8%E9%9B%86%E5%90%88\"><span class=\"toc-text\">2.5 字段表集合</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-6-%E6%96%B9%E6%B3%95%E8%A1%A8%E9%9B%86%E5%90%88\"><span class=\"toc-text\">2.6 方法表集合</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#2-7-%E5%B1%9E%E6%80%A7%E8%A1%A8%E9%9B%86%E5%90%88\"><span class=\"toc-text\">2.7 属性表集合</span></a></li></ol></li></ol></li></ol>","author":{"name":"南望","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/db609a2e507d4a36b32e06b4676aad38.PNG","link":"/","description":"路漫漫其修远兮，吾将上下而求索······","socials":{"github":"https://github.com/saw96x","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/saw96x","csdn":"https://blog.csdn.net/saw96x?spm=1001.2101.3001.5343","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"JVM内存结构","uid":"f0feb27731f09def8e6fa03e806c3c89","slug":"JVM内存结构","date":"2021-08-12T02:01:18.000Z","updated":"2021-08-13T03:30:01.165Z","comments":true,"path":"api/articles/JVM内存结构.json","cover":"https://img-blog.csdnimg.cn/894fb565727048428c86ad9706a6948b.jpg","text":"本篇笔记不定期更新 内存结构图先上图这张图差不多就把JVM的内存结构以及和class源文件，JVM执行引擎，以及操作系统自带的本地方法接口之间的关系囊括进去了。 下面我们就JVM内存结构的几个组成部分来逐一简单介绍一下 1. 程序计数器1.1 定义Program Counter ...","link":"","photos":[],"count_time":{"symbolsCount":"4.1k","symbolsTime":"4 mins."},"categories":[{"name":"学习笔记","slug":"学习笔记","count":5,"path":"api/categories/学习笔记.json"}],"tags":[{"name":"Java","slug":"Java","count":6,"path":"api/tags/Java.json"},{"name":"JVM","slug":"JVM","count":4,"path":"api/tags/JVM.json"},{"name":"深入理解Java虚拟机","slug":"深入理解Java虚拟机","count":4,"path":"api/tags/深入理解Java虚拟机.json"}],"author":{"name":"南望","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/db609a2e507d4a36b32e06b4676aad38.PNG","link":"/","description":"路漫漫其修远兮，吾将上下而求索······","socials":{"github":"https://github.com/saw96x","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/saw96x","csdn":"https://blog.csdn.net/saw96x?spm=1001.2101.3001.5343","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"带图形界面的贪吃蛇","uid":"199a087d49b9cdfd27d9b5eda9606895","slug":"带图形界面的贪吃蛇","date":"2021-08-13T03:40:46.000Z","updated":"2021-08-13T03:46:43.432Z","comments":true,"path":"api/articles/带图形界面的贪吃蛇.json","cover":"https://img-blog.csdnimg.cn/3f7704d76adf4372a345bc06fe28692d.jpg","text":"比较早的代码了，属于典型的为了面向对象而面向对象的代码。。。运行环境VS2019，图形由easyx库实现：https://easyx.cn/。 已经在注释中写出了出现的eaysx库函数的基本作用，注释前带“*”的是easyx的库函数，详情请查阅文档https://docs.eas...","link":"","photos":[],"count_time":{"symbolsCount":"14k","symbolsTime":"13 mins."},"categories":[{"name":"技术分享","slug":"技术分享","count":2,"path":"api/categories/技术分享.json"}],"tags":[{"name":"小游戏","slug":"小游戏","count":1,"path":"api/tags/小游戏.json"},{"name":"C++","slug":"C","count":1,"path":"api/tags/C.json"}],"author":{"name":"南望","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/db609a2e507d4a36b32e06b4676aad38.PNG","link":"/","description":"路漫漫其修远兮，吾将上下而求索······","socials":{"github":"https://github.com/saw96x","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/saw96x","csdn":"https://blog.csdn.net/saw96x?spm=1001.2101.3001.5343","juejin":"","customs":{}}},"feature":false}}