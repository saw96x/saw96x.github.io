{"title":"Springboot的自动装配原理浅析","uid":"809380e59300e634907b381d0433de40","slug":"Springboot的自动装配原理浅析","date":"2021-08-04T08:16:55.000Z","updated":"2021-08-13T03:31:04.451Z","comments":true,"path":"api/articles/Springboot的自动装配原理浅析.json","cover":"https://img-blog.csdnimg.cn/63e12237debd402bba140afc62e94660.jpg","content":"<p>最近在学习Springboot，不少文章和视频在完成了第一个快速入门的项目之后就直接进入了Springboot运行的原理部分，因此决定写一篇文章加深理解。</p>\n<p>原理的理解主要使用了查看源码和画流程图的方式。</p>\n<h3 id=\"pom-xml\"><a href=\"#pom-xml\" class=\"headerlink\" title=\"pom.xml\"></a>pom.xml</h3><p>对于一个maven项目，我们一般首要分析其pom文件，查看相关依赖。</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;&#x2F;artifactId&gt;\n        &lt;&#x2F;dependency&gt;\n\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-test&lt;&#x2F;artifactId&gt;\n            &lt;scope&gt;test&lt;&#x2F;scope&gt;\n            &lt;exclusions&gt;\n                &lt;exclusion&gt;\n                    &lt;groupId&gt;org.junit.vintage&lt;&#x2F;groupId&gt;\n                    &lt;artifactId&gt;junit-vintage-engine&lt;&#x2F;artifactId&gt;\n                &lt;&#x2F;exclusion&gt;\n            &lt;&#x2F;exclusions&gt;\n        &lt;&#x2F;dependency&gt;\n    &lt;&#x2F;dependencies&gt;\n\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n                &lt;artifactId&gt;spring-boot-maven-plugin&lt;&#x2F;artifactId&gt;\n            &lt;&#x2F;plugin&gt;\n        &lt;&#x2F;plugins&gt;\n    &lt;&#x2F;build&gt;</code></pre>\n<p>可以看到依赖方面都是很简单的内容，加入了测试启动器和web启动器以及springboot的build插件，但我们发现了一个不一般的地方，他们都没有版本号！这是为什么呢？<br>   我们往上查看，可以发现这样的父依赖。</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;parent&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;2.3.4.RELEASE&lt;&#x2F;version&gt;\n        &lt;relativePath&#x2F;&gt; &lt;!-- lookup parent from repository --&gt;\n    &lt;&#x2F;parent&gt;</code></pre>\n<p>   我们点进去查看，会发现。。。还有一层父依赖！<br>   <pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\"> &lt;parent&gt;\n  &lt;groupId&gt;org.springframework.boot&lt;&#x2F;groupId&gt;\n  &lt;artifactId&gt;spring-boot-dependencies&lt;&#x2F;artifactId&gt;\n  &lt;version&gt;2.3.4.RELEASE&lt;&#x2F;version&gt;\n&lt;&#x2F;parent&gt;</code></pre><br>   继续点进去查看。</p>\n<pre class=\"line-numbers language-xml\" data-language=\"xml\"><code class=\"language-xml\">&lt;properties&gt;\n    &lt;activemq.version&gt;5.15.13&lt;&#x2F;activemq.version&gt;\n    &lt;antlr2.version&gt;2.7.7&lt;&#x2F;antlr2.version&gt;\n    &lt;appengine-sdk.version&gt;1.9.82&lt;&#x2F;appengine-sdk.version&gt;\n    &lt;artemis.version&gt;2.12.0&lt;&#x2F;artemis.version&gt;\n    &lt;aspectj.version&gt;1.9.6&lt;&#x2F;aspectj.version&gt;\n    &lt;assertj.version&gt;3.16.1&lt;&#x2F;assertj.version&gt;\n    &lt;atomikos.version&gt;4.0.6&lt;&#x2F;atomikos.version&gt;\n    &lt;awaitility.version&gt;4.0.3&lt;&#x2F;awaitility.version&gt;\n    &lt;bitronix.version&gt;2.1.4&lt;&#x2F;bitronix.version&gt;\n    &lt;build-helper-maven-plugin.version&gt;3.1.0&lt;&#x2F;build-helper-maven-plugin.version&gt;\n    &lt;byte-buddy.version&gt;1.10.14&lt;&#x2F;byte-buddy.version&gt;\n    &lt;caffeine.version&gt;2.8.5&lt;&#x2F;caffeine.version&gt;\n    &lt;cassandra-driver.version&gt;4.6.1&lt;&#x2F;cassandra-driver.version&gt;\n    ...........</code></pre>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">这样的信息就是这些依赖尽头的主体了，这个文件有大量的配置信息，标注了每个可能用到的依赖的版本号，因此我们不用指定依赖的版本，springboot会根据你使用的版本自动给你安排合适的版本，再也不用担心依赖版本的冲突导致的崩溃啦！\n\npom.xml文件我们就说到这里，接下来才是重头戏了！\n\n思维导图：\n\t![在这里插入图片描述](https:&#x2F;&#x2F;img-blog.csdnimg.cn&#x2F;20200929160256862.png#pic_center)\n\n### 启动类的@SpringBootApplication注解\n启动类包括两个重要的部分，一个是@SpringBootApplication注解，另一个是其中的run方法，我们先从这个注解开始说起。\n\n首先，这个注解的作用，猜也猜得到，是标注这个应用是一个springboot应用，这样springboot就可以帮我们对其进行自动配置，我们想要了解，spring boot是如何通过注解来自动装配的，装配了什么。\n\n老办法，查看源码，我点！\n&#96;&#96;&#96;java\n@Target(&#123;ElementType.TYPE&#125;)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@SpringBootConfiguration\n@EnableAutoConfiguration\n@ComponentScan</code></pre>\n<p>以上是@SpringBootApplication注解之下的几个注解，出去那些基础的之外，我们可以看见三个特别显眼的，@SpringBootConfiguration，@ComponentScan，@EnableAutoConfiguration，我们逐个查看他们的源码。</p>\n<h4 id=\"SpringBootConfiguration\"><a href=\"#SpringBootConfiguration\" class=\"headerlink\" title=\"@SpringBootConfiguration\"></a>@SpringBootConfiguration</h4><p>他的源码：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Target(&#123;ElementType.TYPE&#125;)\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Configuration</code></pre>\n<p>乏善可陈。。。根据其下的@Configuration可以猜到，它是起到一个标注作用的注解，标志当前应用为一个springboot应用。</p>\n<p>我们回到上一层查看其他注解的源码。</p>\n<h4 id=\"ComponentScan\"><a href=\"#ComponentScan\" class=\"headerlink\" title=\"@ComponentScan\"></a>@ComponentScan</h4><p>这个更没啥好说的了，源码都没必要看了，他的作用是扫描指定包下的组件，将它们加载到Spring的IOC容器之中，很重要，但不是我们探究的重点。</p>\n<p>我们查看最后一个注解的源码。</p>\n<h4 id=\"EnableAutoConfiguration\"><a href=\"#EnableAutoConfiguration\" class=\"headerlink\" title=\"@EnableAutoConfiguration\"></a>@EnableAutoConfiguration</h4><p>看得出来，他的作用是启用自动配置，我们重点关注如何启用，怎么启用，启用了什么。<br>他的源码：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@AutoConfigurationPackage\n@Import(&#123;AutoConfigurationImportSelector.class&#125;)</code></pre>\n<p>看起来重要的注解就这两个，第一个看翻译是自动配置包，我们点进去查看他的源码：</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">@Import(&#123;Registrar.class&#125;)</code></pre>\n<p>噢，这是一个注册器，根据相关源码猜测是将bean注册导入到容器之中（若有错误希望指正）。</p>\n<p>我们回头，看看import导入的东西。</p>\n<p>自动配置导入选择器，我们猜测它是导入了需要的配置文件，查看源码：<br><img src=\"https://img-blog.csdnimg.cn/20200929162249237.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhdzk2eA==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"><br>我这里截图还没有截全。。。我们发现其中有相当多的方法，我们的目的是查看如何加载组件的，因此寻找configuration相关的方法。</p>\n<p>找到了！getCandidateConfigurations，获取候选配置，这个方法中又使用了SpringFactoriesLoader，我们继续深入。<br><code>public static final String FACTORIES_RESOURCE_LOCATION = &quot;META-INF/spring.factories&quot;;</code><br>看到了看起来是文件的东西！我们使用全局搜索，发现它在springboot的jar包内，我们再点开来看看</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20200929162722643.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhdzk2eA==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\">我们根据源头打开spring.factories ， 看到了很多自动配置的文件；这就是自动配置根源所在！可以随便点开看看，都可以看到这些一个个的都是JavaConfig配置类，而且都注入了一些Bean。</p>\n<p>至此，我们大概明白了Spring boot的自动装配原理了：</p>\n<p>自动配置真正实现是从classpath中搜寻所有的META-INF/spring.factories配置文件 ，并将其中对应的 org.springframework.boot.autoconfigure. 包下的配置项，通过反射实例化为对应标注了 @Configuration的JavaConfig形式的IOC容器配置类 ， 然后将这些都汇总成为一个实例并加载到IOC容器中。</p>\n<p>所以其实刚刚那一大串套娃注解其实都是为了拿到spring.factories。。。我不太懂设计模式，不太懂这样做的意义是什么样的哈哈哈。</p>\n<h2 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h2><ol>\n<li><p>SpringBoot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值</p>\n</li>\n<li><p>将这些值作为自动配置类导入容器 ， 自动配置类就生效 ， 帮我们进行自动配置工作；</p>\n</li>\n<li><p>整个J2EE的整体解决方案和自动配置都在springboot-autoconfigure的jar包中；</p>\n</li>\n<li><p>它会给容器中导入非常多的自动配置类 （xxxAutoConfiguration）, 就是给容器中导入这个场景需要的所有组件 ， 并配置好这些组件 ；</p>\n</li>\n<li><p>有了自动配置类 ， 免去了我们手动编写配置注入功能组件等的工作；</p>\n</li>\n</ol>\n<p>思维导图：<br><img src=\"https://img-blog.csdnimg.cn/20200929164052679.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhdzk2eA==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n<h3 id=\"run方法\"><a href=\"#run方法\" class=\"headerlink\" title=\"run方法\"></a>run方法</h3><p>分析该方法主要分两部分，一部分是SpringApplication的实例化，二是run方法的执行；<br>SpringApplication</p>\n<p>这个类主要做了以下四件事情：</p>\n<p>1、推断应用的类型是普通的项目还是Web项目</p>\n<p>2、查找并加载所有可用初始化器 ， 设置到initializers属性中</p>\n<p>3、找出所有的应用程序监听器，设置到listeners属性中</p>\n<p>4、推断并设置main方法的定义类，找到运行的主类</p>\n<p>源码分析无力了。。。给大家一张图吧，说的很清楚了，大家可以跟着这张图自己读读源码。</p>\n<p><img src=\"https://img-blog.csdnimg.cn/20200929163826667.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhdzk2eA==,size_16,color_FFFFFF,t_70#pic_center\" alt=\"在这里插入图片描述\"></p>\n","feature":true,"text":"最近在学习Springboot，不少文章和视频在完成了第一个快速入门的项目之后就直接进入了Springboot运行的原理部分，因此决定写一篇文章加深理解。 原理的理解主要使用了查看源码和画流程图的方式。 pom.xml对于一个maven项目，我们一般首要分析其pom文件，查看相关...","link":"","photos":[],"count_time":{"symbolsCount":"5.6k","symbolsTime":"5 mins."},"categories":[{"name":"技术感悟","slug":"技术感悟","count":1,"path":"api/categories/技术感悟.json"}],"tags":[{"name":"Java","slug":"Java","count":5,"path":"api/tags/Java.json"},{"name":"源码分析","slug":"源码分析","count":3,"path":"api/tags/源码分析.json"},{"name":"SpringBoot","slug":"SpringBoot","count":1,"path":"api/tags/SpringBoot.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#pom-xml\"><span class=\"toc-text\">pom.xml</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#SpringBootConfiguration\"><span class=\"toc-text\">@SpringBootConfiguration</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#ComponentScan\"><span class=\"toc-text\">@ComponentScan</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#EnableAutoConfiguration\"><span class=\"toc-text\">@EnableAutoConfiguration</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%93%E8%AE%BA\"><span class=\"toc-text\">结论</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#run%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">run方法</span></a></li></ol>","author":{"name":"南望","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/db609a2e507d4a36b32e06b4676aad38.PNG","link":"/","description":"路漫漫其修远兮，吾将上下而求索······","socials":{"github":"https://github.com/saw96x","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/saw96x","csdn":"https://blog.csdn.net/saw96x?spm=1001.2101.3001.5343","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"JVM内存结构","uid":"f0feb27731f09def8e6fa03e806c3c89","slug":"JVM内存结构","date":"2021-08-12T02:01:18.000Z","updated":"2021-08-13T03:30:01.165Z","comments":true,"path":"api/articles/JVM内存结构.json","cover":"https://img-blog.csdnimg.cn/894fb565727048428c86ad9706a6948b.jpg","text":"本篇笔记不定期更新 内存结构图先上图这张图差不多就把JVM的内存结构以及和class源文件，JVM执行引擎，以及操作系统自带的本地方法接口之间的关系囊括进去了。 下面我们就JVM内存结构的几个组成部分来逐一简单介绍一下 1. 程序计数器1.1 定义Program Counter ...","link":"","photos":[],"count_time":{"symbolsCount":"4.1k","symbolsTime":"4 mins."},"categories":[{"name":"学习笔记","slug":"学习笔记","count":4,"path":"api/categories/学习笔记.json"}],"tags":[{"name":"Java","slug":"Java","count":5,"path":"api/tags/Java.json"},{"name":"JVM","slug":"JVM","count":3,"path":"api/tags/JVM.json"},{"name":"深入理解Java虚拟机","slug":"深入理解Java虚拟机","count":3,"path":"api/tags/深入理解Java虚拟机.json"}],"author":{"name":"南望","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/db609a2e507d4a36b32e06b4676aad38.PNG","link":"/","description":"路漫漫其修远兮，吾将上下而求索······","socials":{"github":"https://github.com/saw96x","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/saw96x","csdn":"https://blog.csdn.net/saw96x?spm=1001.2101.3001.5343","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"HotSpot虚拟机对象探秘","uid":"c26847ef99f42b8a854d63bbf2df96ed","slug":"HotSpot虚拟机对象探秘","date":"2021-08-12T02:55:37.000Z","updated":"2021-08-13T03:30:24.139Z","comments":true,"path":"api/articles/HotSpot虚拟机对象探秘.json","cover":"https://img-blog.csdnimg.cn/d5af07a1654547758e69d8f48efeea51.jpg","text":"HotSpot虚拟机对象探秘1. 对象的创建1.1 类加载检查虚拟机遇到new之后，首先会去常量池中找这个类的符号引用，并检查这个符号引用代表的类是否已经被加载、解析和初始化过，如果找到了，就可以根据已有的信息划分空间、分配内存、初始化等等；如果没找到，那必须先执行相应的类加载过...","link":"","photos":[],"count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"categories":[{"name":"学习笔记","slug":"学习笔记","count":4,"path":"api/categories/学习笔记.json"}],"tags":[{"name":"Java","slug":"Java","count":5,"path":"api/tags/Java.json"},{"name":"JVM","slug":"JVM","count":3,"path":"api/tags/JVM.json"},{"name":"深入理解Java虚拟机","slug":"深入理解Java虚拟机","count":3,"path":"api/tags/深入理解Java虚拟机.json"}],"author":{"name":"南望","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/db609a2e507d4a36b32e06b4676aad38.PNG","link":"/","description":"路漫漫其修远兮，吾将上下而求索······","socials":{"github":"https://github.com/saw96x","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/saw96x","csdn":"https://blog.csdn.net/saw96x?spm=1001.2101.3001.5343","juejin":"","customs":{}}},"feature":false}}