{"title":"new_article","uid":"77f9387d0e428e786ca4e7013ad4231a","slug":"DFS入门题","date":"2021-11-27T11:18:14.000Z","updated":"2021-11-27T11:38:10.298Z","comments":true,"path":"api/articles/DFS入门题.json","cover":[],"content":"<h4 id=\"113-路径总和-II\"><a href=\"#113-路径总和-II\" class=\"headerlink\" title=\"113. 路径总和 II\"></a><a href=\"https://leetcode-cn.com/problems/path-sum-ii/\">113. 路径总和 II</a></h4><p>给你二叉树的根节点 <code>root</code> 和一个整数目标和 <code>targetSum</code> ，找出所有 <strong>从根节点到叶子节点</strong> 路径总和等于给定目标和的路径。</p>\n<p><strong>叶子节点</strong> 是指没有子节点的节点。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/01/18/pathsumii1.jpg\" alt=\"img\"></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">输入：root &#x3D; [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum &#x3D; 22\n输出：[[5,4,11,2],[5,8,4,5]]<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p><strong>示例 2：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg\" alt=\"img\"></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">输入：root &#x3D; [1,2,3], targetSum &#x3D; 5\n输出：[]<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p><strong>示例 3：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">输入：root &#x3D; [1,2], targetSum &#x3D; 0\n输出：[]<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>树中节点总数在范围 <code>[0, 5000]</code> 内</li>\n<li><code>-1000 &lt;= Node.val &lt;= 1000</code></li>\n<li><code>-1000 &lt;= targetSum &lt;= 1000</code></li>\n</ul>\n<p>代码：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public class pathSum_113 &#123;\n  List&lt;List&lt;Integer&gt;&gt; res &#x3D; new LinkedList&lt;&gt;();\n  Deque&lt;Integer&gt; path &#x3D; new LinkedList&lt;&gt;();\n\n  public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int targetSum) &#123;\n    dfs(root, targetSum);\n    return res;\n  &#125;\n\n  public void dfs(TreeNode root, int targetSum) &#123;\n    if (root &#x3D;&#x3D; null)\n      return;\n    &#x2F;&#x2F;把当前节点加入路径中\n    path.addLast(root.val);\n    targetSum -&#x3D; root.val;\n    &#x2F;&#x2F;如果是叶子节点，且targetSum已经减为0了，说明是一条路径，加入结果集\n    if (root.left &#x3D;&#x3D; null &amp;&amp; root.right &#x3D;&#x3D; null &amp;&amp; targetSum &#x3D;&#x3D; 0) &#123;\n      res.add(new LinkedList&lt;&gt;(path));\n    &#125;\n    dfs(root.left, targetSum);\n    dfs(root.right, targetSum);\n    &#x2F;&#x2F;已经遍历过的末端节点要移出路径\n    path.removeLast();\n  &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h4 id=\"257-二叉树的所有路径\"><a href=\"#257-二叉树的所有路径\" class=\"headerlink\" title=\"257. 二叉树的所有路径\"></a><a href=\"https://leetcode-cn.com/problems/binary-tree-paths/\">257. 二叉树的所有路径</a></h4><p>给你一个二叉树的根节点 <code>root</code> ，按 <strong>任意顺序</strong> ，返回所有从根节点到叶子节点的路径。</p>\n<p><strong>叶子节点</strong> 是指没有子节点的节点。</p>\n<p><strong>示例 1：</strong></p>\n<p><img src=\"https://assets.leetcode.com/uploads/2021/03/12/paths-tree.jpg\" alt=\"img\"></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">输入：root &#x3D; [1,2,3,null,5]\n输出：[&quot;1-&gt;2-&gt;5&quot;,&quot;1-&gt;3&quot;]<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p><strong>示例 2：</strong></p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">输入：root &#x3D; [1]\n输出：[&quot;1&quot;]<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p><strong>提示：</strong></p>\n<ul>\n<li>树中节点的数目在范围 <code>[1, 100]</code> 内</li>\n<li><code>-100 &lt;= Node.val &lt;= 100</code></li>\n</ul>\n<p>代码：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">public class binaryTreePaths_257 &#123;\n  public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123;\n    List&lt;String&gt; res &#x3D; new ArrayList&lt;&gt;();\n    dfs(root, &quot;&quot;, res);\n    return res;\n  &#125;\n\n  public void dfs(TreeNode root, String path, List&lt;String&gt; res) &#123;\n    if (root &#x3D;&#x3D; null)\n      return;\n    StringBuffer sb &#x3D; new StringBuffer(path);\n    sb.append(root.val);\n    if (root.left &#x3D;&#x3D; null &amp;&amp; root.right &#x3D;&#x3D; null) &#123;\n      res.add(sb.toString());\n    &#125; else &#123;\n      sb.append(&quot;-&gt;&quot;);\n      dfs(root.left, sb.toString(), res);\n      dfs(root.right, sb.toString(), res);\n    &#125;\n  &#125;\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n","feature":false,"text":"113. 路径总和 II给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。 叶子节点 是指没有子节点的节点。 示例 1： 输入：root &#x3D; [5,4,8,11,null,13,4,7,2,...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"算法笔记","slug":"算法笔记","count":8,"path":"api/categories/算法笔记.json"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","count":8,"path":"api/tags/数据结构与算法.json"},{"name":"LeetCode","slug":"LeetCode","count":4,"path":"api/tags/LeetCode.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#113-%E8%B7%AF%E5%BE%84%E6%80%BB%E5%92%8C-II\"><span class=\"toc-text\">113. 路径总和 II</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#257-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%89%80%E6%9C%89%E8%B7%AF%E5%BE%84\"><span class=\"toc-text\">257. 二叉树的所有路径</span></a></li></ol>","author":{"name":"南望","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/db609a2e507d4a36b32e06b4676aad38.PNG","link":"/","description":"路漫漫其修远兮，吾将上下而求索······","socials":{"github":"https://github.com/saw96x","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/saw96x","csdn":"https://blog.csdn.net/saw96x?spm=1001.2101.3001.5343","juejin":"","customs":{}}},"mapped":true,"prev_post":{"title":"LeetCode中经典的链表题","uid":"367463c88a16078125a84825dd49eab4","slug":"LeetCode中经典的链表题","date":"2021-11-22T02:39:39.000Z","updated":"2021-11-24T08:08:44.137Z","comments":true,"path":"api/articles/LeetCode中经典的链表题.json","cover":"https://i.loli.net/2021/08/23/z1OTKikv4DnZftY.jpg","text":"1. 两数相加（LC第2题）给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。 请你将两个数相加，并以相同形式返回一个表示和的链表。 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例 1： 输入...","link":"","photos":[],"count_time":{"symbolsCount":"6.8k","symbolsTime":"6 mins."},"categories":[{"name":"算法笔记","slug":"算法笔记","count":8,"path":"api/categories/算法笔记.json"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","count":8,"path":"api/tags/数据结构与算法.json"},{"name":"LeetCode","slug":"LeetCode","count":4,"path":"api/tags/LeetCode.json"}],"author":{"name":"南望","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/db609a2e507d4a36b32e06b4676aad38.PNG","link":"/","description":"路漫漫其修远兮，吾将上下而求索······","socials":{"github":"https://github.com/saw96x","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/saw96x","csdn":"https://blog.csdn.net/saw96x?spm=1001.2101.3001.5343","juejin":"","customs":{}}},"feature":true},"next_post":{"title":"new_article","uid":"77f9387d0e428e786ca4e7013ad4231a","slug":"二分查找详解","date":"2021-11-26T12:52:47.000Z","updated":"2021-11-26T13:54:07.769Z","comments":true,"path":"api/articles/二分查找详解.json","cover":null,"text":"本文转载自：https://leetcode-cn.com/problems/binary-search/solution/er-fen-cha-zhao-xiang-jie-by-labuladong/ 0.二分查找框架int binarySearch(int[] nums, ...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"算法笔记","slug":"算法笔记","count":8,"path":"api/categories/算法笔记.json"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","count":8,"path":"api/tags/数据结构与算法.json"}],"author":{"name":"南望","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/db609a2e507d4a36b32e06b4676aad38.PNG","link":"/","description":"路漫漫其修远兮，吾将上下而求索······","socials":{"github":"https://github.com/saw96x","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/saw96x","csdn":"https://blog.csdn.net/saw96x?spm=1001.2101.3001.5343","juejin":"","customs":{}}},"feature":false}}