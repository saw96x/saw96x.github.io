{"total":18,"pageSize":12,"pageCount":2,"data":[{"title":"二叉树三种遍历的迭代写法","uid":"dd6a595fe87f1a59685b2c89c539382d","slug":"二叉树四种遍历的迭代写法","date":"2021-11-25T14:49:20.000Z","updated":"2021-12-03T12:20:22.032Z","comments":true,"path":"api/articles/二叉树四种遍历的迭代写法.json","cover":[],"text":"前序遍历前序遍历指的是按根节点、左子节点、右子节点这种顺序遍历的过程，因为最先遍历根节点，因此命名为前序遍历，使用递归算法的话，写法很简单，但耗时较多，因此在追求性能的情况下，我们一般使用迭代算法。迭代算法实际上是把递归算法中的系统调用栈显式的自己写出来。 迭代版前序遍历的过程如...","link":"","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[{"name":"算法笔记","slug":"算法笔记","count":9,"path":"api/categories/算法笔记.json"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","count":9,"path":"api/tags/数据结构与算法.json"}],"author":{"name":"南望","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/db609a2e507d4a36b32e06b4676aad38.PNG","link":"/","description":"路漫漫其修远兮，吾将上下而求索······","socials":{"github":"https://github.com/saw96x","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/saw96x","csdn":"https://blog.csdn.net/saw96x?spm=1001.2101.3001.5343","juejin":"","customs":{}}},"feature":true},{"title":"LeetCode中的单调栈题","uid":"e132209059bdfe8fd53e19e341dda430","slug":"LeetCode中的单调栈题","date":"2021-11-24T07:43:03.000Z","updated":"2021-11-24T07:44:38.534Z","comments":true,"path":"api/articles/LeetCode中的单调栈题.json","cover":null,"text":"单调栈系列题目单调栈解法的介绍：https://leetcode-cn.com/problems/next-greater-element-i/solution/dan-diao-zhan-jie-jue-next-greater-number-yi-lei-w/ 5. 每日温度...","link":"","photos":[],"count_time":{"symbolsCount":"4.5k","symbolsTime":"4 mins."},"categories":[{"name":"算法笔记","slug":"算法笔记","count":9,"path":"api/categories/算法笔记.json"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","count":9,"path":"api/tags/数据结构与算法.json"},{"name":"LeetCode","slug":"LeetCode","count":5,"path":"api/tags/LeetCode.json"}],"author":{"name":"南望","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/db609a2e507d4a36b32e06b4676aad38.PNG","link":"/","description":"路漫漫其修远兮，吾将上下而求索······","socials":{"github":"https://github.com/saw96x","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/saw96x","csdn":"https://blog.csdn.net/saw96x?spm=1001.2101.3001.5343","juejin":"","customs":{}}},"feature":"ture"},{"title":"LeetCode中经典的链表题","uid":"367463c88a16078125a84825dd49eab4","slug":"LeetCode中经典的链表题","date":"2021-11-22T02:39:39.000Z","updated":"2021-11-24T08:08:44.137Z","comments":true,"path":"api/articles/LeetCode中经典的链表题.json","cover":"https://i.loli.net/2021/08/23/z1OTKikv4DnZftY.jpg","text":"1. 两数相加（LC第2题）给你两个 非空 的链表，表示两个非负的整数。它们每位数字都是按照 逆序 的方式存储的，并且每个节点只能存储 一位 数字。 请你将两个数相加，并以相同形式返回一个表示和的链表。 你可以假设除了数字 0 之外，这两个数都不会以 0 开头。 示例 1： 输入...","link":"","photos":[],"count_time":{"symbolsCount":"6.8k","symbolsTime":"6 mins."},"categories":[{"name":"算法笔记","slug":"算法笔记","count":9,"path":"api/categories/算法笔记.json"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","count":9,"path":"api/tags/数据结构与算法.json"},{"name":"LeetCode","slug":"LeetCode","count":5,"path":"api/tags/LeetCode.json"}],"author":{"name":"南望","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/db609a2e507d4a36b32e06b4676aad38.PNG","link":"/","description":"路漫漫其修远兮，吾将上下而求索······","socials":{"github":"https://github.com/saw96x","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/saw96x","csdn":"https://blog.csdn.net/saw96x?spm=1001.2101.3001.5343","juejin":"","customs":{}}},"feature":true},{"title":"new_article","uid":"77f9387d0e428e786ca4e7013ad4231a","slug":"二维数组的一维表示","date":"2021-12-03T12:03:47.000Z","updated":"2021-12-03T13:33:04.183Z","comments":true,"path":"api/articles/二维数组的一维表示.json","cover":[],"text":"566. 重塑矩阵在 MATLAB 中，有一个非常有用的函数 reshape ，它可以将一个 m x n 矩阵重塑为另一个大小不同（r x c）的新矩阵，但保留其原始数据。 给你一个由二维数组 mat 表示的 m x n 矩阵，以及两个正整数 r 和 c ，分别表示想要的重构的矩...","link":"","photos":[],"count_time":{"symbolsCount":576,"symbolsTime":"1 mins."},"categories":[{"name":"算法笔记","slug":"算法笔记","count":9,"path":"api/categories/算法笔记.json"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","count":9,"path":"api/tags/数据结构与算法.json"},{"name":"LeetCode","slug":"LeetCode","count":5,"path":"api/tags/LeetCode.json"}],"author":{"name":"南望","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/db609a2e507d4a36b32e06b4676aad38.PNG","link":"/","description":"路漫漫其修远兮，吾将上下而求索······","socials":{"github":"https://github.com/saw96x","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/saw96x","csdn":"https://blog.csdn.net/saw96x?spm=1001.2101.3001.5343","juejin":"","customs":{}}},"feature":false},{"title":"new_article","uid":"77f9387d0e428e786ca4e7013ad4231a","slug":"DFS入门题","date":"2021-11-27T11:18:14.000Z","updated":"2021-11-27T11:38:10.298Z","comments":true,"path":"api/articles/DFS入门题.json","cover":[],"text":"113. 路径总和 II给你二叉树的根节点 root 和一个整数目标和 targetSum ，找出所有 从根节点到叶子节点 路径总和等于给定目标和的路径。 叶子节点 是指没有子节点的节点。 示例 1： 输入：root &#x3D; [5,4,8,11,null,13,4,7,2,...","link":"","photos":[],"count_time":{"symbolsCount":"2.2k","symbolsTime":"2 mins."},"categories":[{"name":"算法笔记","slug":"算法笔记","count":9,"path":"api/categories/算法笔记.json"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","count":9,"path":"api/tags/数据结构与算法.json"},{"name":"LeetCode","slug":"LeetCode","count":5,"path":"api/tags/LeetCode.json"}],"author":{"name":"南望","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/db609a2e507d4a36b32e06b4676aad38.PNG","link":"/","description":"路漫漫其修远兮，吾将上下而求索······","socials":{"github":"https://github.com/saw96x","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/saw96x","csdn":"https://blog.csdn.net/saw96x?spm=1001.2101.3001.5343","juejin":"","customs":{}}},"feature":false},{"title":"new_article","uid":"77f9387d0e428e786ca4e7013ad4231a","slug":"二分查找详解","date":"2021-11-26T12:52:47.000Z","updated":"2021-11-26T13:54:07.769Z","comments":true,"path":"api/articles/二分查找详解.json","cover":null,"text":"本文转载自：https://leetcode-cn.com/problems/binary-search/solution/er-fen-cha-zhao-xiang-jie-by-labuladong/ 0.二分查找框架int binarySearch(int[] nums, ...","link":"","photos":[],"count_time":{"symbolsCount":"11k","symbolsTime":"10 mins."},"categories":[{"name":"算法笔记","slug":"算法笔记","count":9,"path":"api/categories/算法笔记.json"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","count":9,"path":"api/tags/数据结构与算法.json"}],"author":{"name":"南望","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/db609a2e507d4a36b32e06b4676aad38.PNG","link":"/","description":"路漫漫其修远兮，吾将上下而求索······","socials":{"github":"https://github.com/saw96x","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/saw96x","csdn":"https://blog.csdn.net/saw96x?spm=1001.2101.3001.5343","juejin":"","customs":{}}},"feature":false},{"title":"LeetCode中的一些栈题","uid":"7e171348ffe43d4c5779ddb0408bc26b","slug":"LeetCode中经典的栈题","date":"2021-11-25T14:48:29.000Z","updated":"2021-11-25T14:48:47.967Z","comments":true,"path":"api/articles/LeetCode中经典的栈题.json","cover":null,"text":"1. 有效的括号（LC第20题）给定一个只包括 &#39;(&#39;，&#39;)&#39;，&#39;&#123;&#39;，&#39;&#125;&#39;，&#39;[&#39;，&#39;]&#39; 的字符串 s ，判断字符串是否有效。 有效字符串需满足： 左括号必须...","link":"","photos":[],"count_time":{"symbolsCount":"4k","symbolsTime":"4 mins."},"categories":[{"name":"算法笔记","slug":"算法笔记","count":9,"path":"api/categories/算法笔记.json"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","count":9,"path":"api/tags/数据结构与算法.json"},{"name":"LeetCode","slug":"LeetCode","count":5,"path":"api/tags/LeetCode.json"}],"author":{"name":"南望","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/db609a2e507d4a36b32e06b4676aad38.PNG","link":"/","description":"路漫漫其修远兮，吾将上下而求索······","socials":{"github":"https://github.com/saw96x","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/saw96x","csdn":"https://blog.csdn.net/saw96x?spm=1001.2101.3001.5343","juejin":"","customs":{}}},"feature":false},{"title":"JVM虚拟机的类加载机制","uid":"0ebc4600a20ae0476600d84a88d43c7f","slug":"JVM虚拟机的类加载机制","date":"2021-09-05T00:32:05.000Z","updated":"2021-09-19T01:25:45.321Z","comments":true,"path":"api/articles/JVM虚拟机的类加载机制.json","cover":"https://i.loli.net/2021/08/23/nc3P9ztCBIVS1m7.jpg","text":"JVM虚拟机的类加载机制JVM把描述类的数据从class文件中加载进内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。 与Java类型相关的诸多工作都是在运行期完成的，这让Java的编译增加了额外的困难，也增加...","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"技术笔记","slug":"技术笔记","count":6,"path":"api/categories/技术笔记.json"}],"tags":[{"name":"Java","slug":"Java","count":8,"path":"api/tags/Java.json"},{"name":"JVM","slug":"JVM","count":6,"path":"api/tags/JVM.json"},{"name":"深入理解Java虚拟机","slug":"深入理解Java虚拟机","count":6,"path":"api/tags/深入理解Java虚拟机.json"}],"author":{"name":"南望","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/db609a2e507d4a36b32e06b4676aad38.PNG","link":"/","description":"路漫漫其修远兮，吾将上下而求索······","socials":{"github":"https://github.com/saw96x","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/saw96x","csdn":"https://blog.csdn.net/saw96x?spm=1001.2101.3001.5343","juejin":"","customs":{}}},"feature":true},{"title":"剑指 Offer 04. 二维数组中的查找","uid":"fbb40c3574c6d879e5f206056adff580","slug":"剑指 Offer 04. 二维数组中的查找","date":"2021-08-28T12:24:08.000Z","updated":"2021-08-30T01:45:48.396Z","comments":true,"path":"api/articles/剑指 Offer 04. 二维数组中的查找.json","cover":"https://i.loli.net/2021/08/23/nTgK3iZQVLxvqy5.jpg","text":"题目详情在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 示例: 现有矩阵 matrix 如下： [ [1, 4, 7, 11, 15], ...","link":"","photos":[],"count_time":{"symbolsCount":"1.6k","symbolsTime":"1 mins."},"categories":[{"name":"算法笔记","slug":"算法笔记","count":9,"path":"api/categories/算法笔记.json"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","count":9,"path":"api/tags/数据结构与算法.json"},{"name":"剑指Offer","slug":"剑指Offer","count":2,"path":"api/tags/剑指Offer.json"}],"author":{"name":"南望","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/db609a2e507d4a36b32e06b4676aad38.PNG","link":"/","description":"路漫漫其修远兮，吾将上下而求索······","socials":{"github":"https://github.com/saw96x","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/saw96x","csdn":"https://blog.csdn.net/saw96x?spm=1001.2101.3001.5343","juejin":"","customs":{}}},"feature":false},{"title":"Class文件中的属性表","uid":"5da49ad2e7903119112e022f920d0056","slug":"Class文件中的属性表","date":"2021-08-23T00:45:31.000Z","updated":"2021-08-29T02:39:39.620Z","comments":true,"path":"api/articles/Class文件中的属性表.json","cover":"https://i.loli.net/2021/08/14/Sqjh2YfiQXBWbEu.jpg","text":"Class文件中的属性表Class文件，字段表，方法表都可以携带自己的属性表集合，以描述某些场景专有的信息。 为了能正确解析Class文件，《Java虚拟机规范》最初只预定义了9项所有Java虚拟机实现都应当能识别的属性，而在最新的《Java虚拟机规范》的Java SE 12版中...","link":"","photos":[],"count_time":{"symbolsCount":461,"symbolsTime":"1 mins."},"categories":[{"name":"技术笔记","slug":"技术笔记","count":6,"path":"api/categories/技术笔记.json"}],"tags":[{"name":"Java","slug":"Java","count":8,"path":"api/tags/Java.json"},{"name":"JVM","slug":"JVM","count":6,"path":"api/tags/JVM.json"},{"name":"深入理解Java虚拟机","slug":"深入理解Java虚拟机","count":6,"path":"api/tags/深入理解Java虚拟机.json"}],"author":{"name":"南望","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/db609a2e507d4a36b32e06b4676aad38.PNG","link":"/","description":"路漫漫其修远兮，吾将上下而求索······","socials":{"github":"https://github.com/saw96x","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/saw96x","csdn":"https://blog.csdn.net/saw96x?spm=1001.2101.3001.5343","juejin":"","customs":{}}},"feature":true},{"title":"JVM中的类文件结构","uid":"581c1d5b4dc9ad92f487897aa0f3fdd0","slug":"JVM中的类文件结构","date":"2021-08-21T01:40:04.000Z","updated":"2021-08-29T02:40:32.244Z","comments":true,"path":"api/articles/JVM中的类文件结构.json","cover":"https://i.loli.net/2021/08/14/kbjcFenifLQaN5x.jpg","text":"JVM中的类文件结构Class文件是一组以8个字节为基础单位的二进制流，各个数据项目中严格按照顺序紧凑排列在一起，中间没有任何分隔符，当遇到了占位8个自己以上空间的数据项时，则会按照高位在前的方式分割成8个字节进行存储。 1. Class文件格式Class文件格式采用一种类似于C...","link":"","photos":[],"count_time":{"symbolsCount":"4k","symbolsTime":"4 mins."},"categories":[{"name":"技术笔记","slug":"技术笔记","count":6,"path":"api/categories/技术笔记.json"}],"tags":[{"name":"Java","slug":"Java","count":8,"path":"api/tags/Java.json"},{"name":"JVM","slug":"JVM","count":6,"path":"api/tags/JVM.json"},{"name":"深入理解Java虚拟机","slug":"深入理解Java虚拟机","count":6,"path":"api/tags/深入理解Java虚拟机.json"}],"author":{"name":"南望","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/db609a2e507d4a36b32e06b4676aad38.PNG","link":"/","description":"路漫漫其修远兮，吾将上下而求索······","socials":{"github":"https://github.com/saw96x","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/saw96x","csdn":"https://blog.csdn.net/saw96x?spm=1001.2101.3001.5343","juejin":"","customs":{}}},"feature":true},{"title":"JVM垃圾回收","uid":"b4694def951abc4bafb5168cc2a7630a","slug":"JVM垃圾回收","date":"2021-08-15T08:16:37.000Z","updated":"2021-09-18T03:59:48.606Z","comments":true,"path":"api/articles/JVM垃圾回收.json","cover":"https://img-blog.csdnimg.cn/992408165d9448b88f720e3fb7e442d8.jpg","text":"JVM垃圾回收1. 如何判断对象可以回收1.1 简要介绍： 引用计数法，如果某个对象被引用了，则他的计数加1，不再被引用了，则减1，计数为0则回收。弊端：循环引用，比如a和b相互引用，即使他们两个永远都不再被使用了，但是由于存在引用计数，所以永远都不会被回收。早期python虚拟...","link":"","photos":[],"count_time":{"symbolsCount":"10k","symbolsTime":"9 mins."},"categories":[{"name":"技术笔记","slug":"技术笔记","count":6,"path":"api/categories/技术笔记.json"}],"tags":[{"name":"Java","slug":"Java","count":8,"path":"api/tags/Java.json"},{"name":"JVM","slug":"JVM","count":6,"path":"api/tags/JVM.json"},{"name":"深入理解Java虚拟机","slug":"深入理解Java虚拟机","count":6,"path":"api/tags/深入理解Java虚拟机.json"},{"name":"源码分析","slug":"源码分析","count":3,"path":"api/tags/源码分析.json"}],"author":{"name":"南望","slug":"blog-author","avatar":"https://img-blog.csdnimg.cn/db609a2e507d4a36b32e06b4676aad38.PNG","link":"/","description":"路漫漫其修远兮，吾将上下而求索······","socials":{"github":"https://github.com/saw96x","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"https://www.zhihu.com/people/saw96x","csdn":"https://blog.csdn.net/saw96x?spm=1001.2101.3001.5343","juejin":"","customs":{}}},"feature":true}]}