[{"title":"new_article","url":"//post/二维数组的一维表示.html","content":"\n#### [566. 重塑矩阵](https://leetcode-cn.com/problems/reshape-the-matrix/)\n\n在 MATLAB 中，有一个非常有用的函数 `reshape` ，它可以将一个 `m x n` 矩阵重塑为另一个大小不同（`r x c`）的新矩阵，但保留其原始数据。\n\n给你一个由二维数组 `mat` 表示的 `m x n` 矩阵，以及两个正整数 `r` 和 `c` ，分别表示想要的重构的矩阵的行数和列数。\n\n重构后的矩阵需要将原始矩阵的所有元素以相同的 **行遍历顺序** 填充。\n\n如果具有给定参数的 `reshape` 操作是可行且合理的，则输出新的重塑矩阵；否则，输出原始矩阵。\n\n**示例 1：**\n\n![img](https://assets.leetcode.com/uploads/2021/04/24/reshape1-grid.jpg)\n\n```\n输入：mat = [[1,2],[3,4]], r = 1, c = 4\n输出：[[1,2,3,4]]\n```\n\n**示例 2：**\n\n![img](https://assets.leetcode.com/uploads/2021/04/24/reshape2-grid.jpg)\n\n```\n输入：mat = [[1,2],[3,4]], r = 2, c = 4\n输出：[[1,2],[3,4]]\n```\n\n**提示：**\n\n- `m == mat.length`\n- `n == mat[i].length`\n- `1 <= m, n <= 100`\n- `-1000 <= mat[i][j] <= 1000`\n- `1 <= r, c <= 300`\n\n这题我第一次做采用的思路是把原数组转为一维数组，然后再转为新数组，看题解发现，二维数组可以直接做一维数组表示，这无疑大大减轻了时间和空间复杂度。\n\n\n\n","tags":["数据结构与算法","LeetCode"],"categories":["算法笔记"]},{"title":"new_article","url":"//post/DFS入门题.html","content":"\n#### [113. 路径总和 II](https://leetcode-cn.com/problems/path-sum-ii/)\n\n给你二叉树的根节点 `root` 和一个整数目标和 `targetSum` ，找出所有 **从根节点到叶子节点** 路径总和等于给定目标和的路径。\n\n**叶子节点** 是指没有子节点的节点。\n\n**示例 1：**\n\n![img](https://assets.leetcode.com/uploads/2021/01/18/pathsumii1.jpg)\n\n```\n输入：root = [5,4,8,11,null,13,4,7,2,null,null,5,1], targetSum = 22\n输出：[[5,4,11,2],[5,8,4,5]]\n```\n\n**示例 2：**\n\n![img](https://assets.leetcode.com/uploads/2021/01/18/pathsum2.jpg)\n\n```\n输入：root = [1,2,3], targetSum = 5\n输出：[]\n```\n\n**示例 3：**\n\n```\n输入：root = [1,2], targetSum = 0\n输出：[]\n```\n\n**提示：**\n\n- 树中节点总数在范围 `[0, 5000]` 内\n- `-1000 <= Node.val <= 1000`\n- `-1000 <= targetSum <= 1000`\n\n代码：\n\n```\npublic class pathSum_113 {\n  List<List<Integer>> res = new LinkedList<>();\n  Deque<Integer> path = new LinkedList<>();\n\n  public List<List<Integer>> pathSum(TreeNode root, int targetSum) {\n    dfs(root, targetSum);\n    return res;\n  }\n\n  public void dfs(TreeNode root, int targetSum) {\n    if (root == null)\n      return;\n    //把当前节点加入路径中\n    path.addLast(root.val);\n    targetSum -= root.val;\n    //如果是叶子节点，且targetSum已经减为0了，说明是一条路径，加入结果集\n    if (root.left == null && root.right == null && targetSum == 0) {\n      res.add(new LinkedList<>(path));\n    }\n    dfs(root.left, targetSum);\n    dfs(root.right, targetSum);\n    //已经遍历过的末端节点要移出路径\n    path.removeLast();\n  }\n}\n```\n\n#### [257. 二叉树的所有路径](https://leetcode-cn.com/problems/binary-tree-paths/)\n\n给你一个二叉树的根节点 `root` ，按 **任意顺序** ，返回所有从根节点到叶子节点的路径。\n\n**叶子节点** 是指没有子节点的节点。\n\n**示例 1：**\n\n![img](https://assets.leetcode.com/uploads/2021/03/12/paths-tree.jpg)\n\n```\n输入：root = [1,2,3,null,5]\n输出：[\"1->2->5\",\"1->3\"]\n```\n\n**示例 2：**\n\n```\n输入：root = [1]\n输出：[\"1\"]\n```\n\n**提示：**\n\n- 树中节点的数目在范围 `[1, 100]` 内\n- `-100 <= Node.val <= 100`\n\n代码：\n\n```\npublic class binaryTreePaths_257 {\n  public List<String> binaryTreePaths(TreeNode root) {\n    List<String> res = new ArrayList<>();\n    dfs(root, \"\", res);\n    return res;\n  }\n\n  public void dfs(TreeNode root, String path, List<String> res) {\n    if (root == null)\n      return;\n    StringBuffer sb = new StringBuffer(path);\n    sb.append(root.val);\n    if (root.left == null && root.right == null) {\n      res.add(sb.toString());\n    } else {\n      sb.append(\"->\");\n      dfs(root.left, sb.toString(), res);\n      dfs(root.right, sb.toString(), res);\n    }\n  }\n}\n```\n","tags":["数据结构与算法","LeetCode"],"categories":["算法笔记"]},{"title":"new_article","url":"//post/二分查找详解.html","content":"\n本文转载自：https://leetcode-cn.com/problems/binary-search/solution/er-fen-cha-zhao-xiang-jie-by-labuladong/\n\n## 0.二分查找框架\n\n\tint binarySearch(int[] nums, int target) {\n\t    int left = 0, right = ...;\n\t\n\t    while(...) {\n\t        int mid = left + (right - left) / 2;\n\t        if (nums[mid] == target) {\n\t            ...\n\t        } else if (nums[mid] < target) {\n\t            left = ...\n\t        } else if (nums[mid] > target) {\n\t            right = ...\n\t        }\n\t    }\n\t    return ...;\n\t}\n\n分析二分查找的一个技巧是：不要出现 else，而是把所有情况用 else if 写清楚，这样可以清楚地展现所有细节。本文都会使用 else if，旨在讲清楚，读者理解后可自行简化。\n\n其中 ... 标记的部分，就是可能出现细节问题的地方，当你见到一个二分查找的代码时，首先注意这几个地方。后文用实例分析这些地方能有什么样的变化。\n\n另外声明一下，计算 mid 时需要防止溢出，代码中 left + (right - left) / 2 就和 (left + right) / 2 的结果相同，但是有效防止了 left 和 right 太大直接相加导致溢出。\n\n## 1.寻找一个数（基本的二分搜索）\n\n这个场景是最简单的，肯能也是大家最熟悉的，即搜索一个数，如果存在，返回其索引，否则返回 -1。\n\n    int binarySearch(int[] nums, int target) {\n        int left = 0; \n        int right = nums.length - 1; // 注意\n        while(left <= right) {\n            int mid = left + (right - left) / 2;\n            if(nums[mid] == target)\n                return mid; \n            else if (nums[mid] < target)\n                left = mid + 1; // 注意\n            else if (nums[mid] > target)\n                right = mid - 1; // 注意\n        }\n        return -1;\n    }\n\n**1、为什么 while 循环的条件中是 <=，而不是 <？**+\n\n答：因为初始化 right 的赋值是 nums.length - 1，即最后一个元素的索引，而不是 nums.length。\n\n这二者可能出现在不同功能的二分查找中，区别是：前者相当于两端都闭区间 [left, right]，后者相当于左闭右开区间 [left, right)，因为索引大小为 nums.length 是越界的。\n\n我们这个算法中使用的是前者 [left, right] 两端都闭的区间。这个区间其实就是每次进行搜索的区间。\n\n什么时候应该停止搜索呢？当然，找到了目标值的时候可以终止：\n\n    if(nums[mid] == target)\n        return mid; \n\n但如果没找到，就需要 while 循环终止，然后返回 -1。那 while 循环什么时候应该终止？搜索区间为空的时候应该终止，意味着你没得找了，就等于没找到嘛。\n\nwhile(left <= right) 的终止条件是 left == right + 1，写成区间的形式就是 [right + 1, right]，或者带个具体的数字进去 [3, 2]，可见这时候区间为空，因为没有数字既大于等于 3 又小于等于 2 的吧。所以这时候 while 循环终止是正确的，直接返回 -1 即可。\n\nwhile(left < right) 的终止条件是 left == right，写成区间的形式就是 [left, right]，或者带个具体的数字进去 [2, 2]，这时候区间非空，还有一个数 2，但此时 while 循环终止了。也就是说这区间 [2, 2] 被漏掉了，索引 2 没有被搜索，如果这时候直接返回 -1 就是错误的。\n\n当然，如果你非要用 while(left < right) 也可以，我们已经知道了出错的原因，就打个补丁好了：\n\n    //...\n    while(left < right) {\n        // ...\n    }\n    return nums[left] == target ? left : -1;\n\n**2、为什么 left = mid + 1，right = mid - 1？我看有的代码是 right = mid 或者 left = mid，没有这些加加减减，到底怎么回事，怎么判断？**\n\n答：这也是二分查找的一个难点，不过只要你能理解前面的内容，就能够很容易判断。\n\n刚才明确了「搜索区间」这个概念，而且本算法的搜索区间是两端都闭的，即 [left, right]。那么当我们发现索引 mid 不是要找的 target 时，下一步应该去搜索哪里呢？\n\n当然是去搜索 [left, mid-1] 或者 [mid+1, right] 对不对？因为 mid 已经搜索过，应该从搜索区间中去除。\n\n3、此算法有什么缺陷？\n\n答：至此，你应该已经掌握了该算法的所有细节，以及这样处理的原因。但是，这个算法存在局限性。\n\n比如说给你有序数组 nums = [1,2,2,2,3]，target 为 2，此算法返回的索引是 2，没错。但是如果我想得到 target 的左侧边界，即索引 1，或者我想得到 target 的右侧边界，即索引 3，这样的话此算法是无法处理的。\n\n这样的需求很常见，你也许会说，找到一个 target，然后向左或向右线性搜索不行吗？可以，但是不好，因为这样难以保证二分查找对数级的复杂度了。\n\n我们后续的算法就来讨论这两种二分查找的算法。\n\n## 二、寻找左侧边界的二分搜索\n\n以下是最常见的代码形式，其中的标记是需要注意的细节：\n\n\tint left_bound(int[] nums, int target) {\n\t    if (nums.length == 0) return -1;\n\t    int left = 0;\n\t    int right = nums.length; // 注意\n\t\n\t    while (left < right) { // 注意\n\t        int mid = (left + right) / 2;\n\t        if (nums[mid] == target) {\n\t            right = mid;\n\t        } else if (nums[mid] < target) {\n\t            left = mid + 1;\n\t        } else if (nums[mid] > target) {\n\t            right = mid; // 注意\n\t        }\n\t    }\n\t    return left;\n\t}\n\n**1、为什么 while 中是 < 而不是 <=?**\n\n答：用相同的方法分析，因为 right = nums.length 而不是 nums.length - 1。因此每次循环的「搜索区间」是 [left, right) 左闭右开。\n\nwhile(left < right) 终止的条件是 left == right，此时搜索区间 [left, left) 为空，所以可以正确终止。\n\nPS：这里先要说一个搜索左右边界和上面这个算法的一个区别，也是很多读者问的：刚才的 right 不是 nums.length - 1 吗，为啥这里非要写成 nums.length 使得「搜索区间」变成左闭右开呢？\n\n因为对于搜索左右侧边界的二分查找，这种写法比较普遍，我就拿这种写法举例了，保证你以后遇到这类代码可以理解。你非要用两端都闭的写法反而更简单，我会在后面写相关的代码，把三种二分搜索都用一种两端都闭的写法统一起来，你耐心往后看就行了。\n\n**2、为什么没有返回 -1 的操作？如果 nums 中不存在 target 这个值，怎么办？**\n\n答：因为要一步一步来，先理解一下这个「左侧边界」有什么特殊含义：\n\n对于nums = [1,2,2,2,3]，target 为 2，这个数组，算法会返回 1。这个 1 的含义可以这样解读：nums 中小于 2 的元素有 1 个。\n\n比如对于有序数组 nums = [2,3,5,7], target = 1，算法会返回 0，含义是：nums 中小于 1 的元素有 0 个。\n\n再比如说 nums = [2,3,5,7], target = 8，算法会返回 4，含义是：nums 中小于 8 的元素有 4 个。\n\n综上可以看出，函数的返回值（即 left 变量的值）取值区间是闭区间 [0, nums.length]，所以我们简单添加两行代码就能在正确的时候 return -1：\n\n    while (left < right) {\n        //...\n    }\n    // target 比所有数都大\n    if (left == nums.length) return -1;\n    // 类似之前算法的处理方式\n    \treturn nums[left] == target ? left : -1;\n\n**3、为什么 left = mid + 1，right = mid ？和之前的算法不一样？**\n\n答：这个很好解释，因为我们的「搜索区间」是 [left, right) 左闭右开，所以当 nums[mid] 被检测之后，下一步的搜索区间应该去掉 mid 分割成两个区间，即 [left, mid) 或 [mid + 1, right)。\n\n**4、为什么该算法能够搜索左侧边界？**\n\n答：关键在于对于 nums[mid] == target 这种情况的处理：\n\n    if (nums[mid] == target)\n        right = mid;\n\n可见，找到 target 时不要立即返回，而是缩小「搜索区间」的上界 right，在区间 [left, mid) 中继续搜索，即不断向左收缩，达到锁定左侧边界的目的。\n\n**5、为什么返回 left 而不是 right？**\n\n答：都是一样的，因为 while 终止的条件是 left == right。\n\n**6、能不能想办法把 right 变成 nums.length - 1，也就是继续使用两边都闭的「搜索区间」？这样就可以和第一种二分搜索在某种程度上统一起来了。**\n\n答：当然可以，只要你明白了「搜索区间」这个概念，就能有效避免漏掉元素，随便你怎么改都行。下面我们严格根据逻辑来修改：\n\n因为你非要让搜索区间两端都闭，所以 right 应该初始化为 nums.length - 1，while 的终止条件应该是 left == right + 1，也就是其中应该用 <=：\n\n    int left_bound(int[] nums, int target) {\n        // 搜索区间为 [left, right]\n        int left = 0, right = nums.length - 1;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            // if else ...\n        }\n\n因为搜索区间是两端都闭的，且现在是搜索左侧边界，所以 left 和 right 的更新逻辑如下：\n\n    if (nums[mid] < target) {\n        // 搜索区间变为 [mid+1, right]\n        left = mid + 1;\n    } else if (nums[mid] > target) {\n        // 搜索区间变为 [left, mid-1]\n        right = mid - 1;\n    } else if (nums[mid] == target) {\n        // 收缩右侧边界\n        right = mid - 1;\n    }\n\n由于 while 的退出条件是 left == right + 1，所以当 target 比 nums 中所有元素都大时，会存在以下情况使得索引越界：\n\n因此，最后返回结果的代码应该检查越界情况：\n\n    if (left >= nums.length || nums[left] != target)\n        return -1;\n    return left;\n\n至此，整个算法就写完了，完整代码如下：\n\n    int left_bound(int[] nums, int target) {\n        int left = 0, right = nums.length - 1;\n        // 搜索区间为 [left, right]\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] < target) {\n                // 搜索区间变为 [mid+1, right]\n                left = mid + 1;\n            } else if (nums[mid] > target) {\n                // 搜索区间变为 [left, mid-1]\n                right = mid - 1;\n            } else if (nums[mid] == target) {\n                // 收缩右侧边界\n                right = mid - 1;\n            }\n        }\n        // 检查出界情况\n        if (left >= nums.length || nums[left] != target)\n            return -1;\n        return left;\n    }\n\n这样就和第一种二分搜索算法统一了，都是两端都闭的「搜索区间」，而且最后返回的也是 left 变量的值。只要把住二分搜索的逻辑，两种形式大家看自己喜欢哪种记哪种吧。\n\n## 三、寻找右侧边界的二分查找\n\n类似寻找左侧边界的算法，这里也会提供两种写法，还是先写常见的左闭右开的写法，只有两处和搜索左侧边界不同，已标注：\n\n    int right_bound(int[] nums, int target) {\n        if (nums.length == 0) return -1;\n        int left = 0, right = nums.length;\n    \n        while (left < right) {\n            int mid = (left + right) / 2;\n            if (nums[mid] == target) {\n                left = mid + 1; // 注意\n            } else if (nums[mid] < target) {\n                left = mid + 1;\n            } else if (nums[mid] > target) {\n                right = mid;\n            }\n        }\n        return left - 1; // 注意\n    }\n\n**1、为什么这个算法能够找到右侧边界？**\n\n答：类似地，关键点还是这里：\n\n    if (nums[mid] == target) {\n        left = mid + 1;\n\n当 nums[mid] == target 时，不要立即返回，而是增大「搜索区间」的下界 left，使得区间不断向右收缩，达到锁定右侧边界的目的。\n\n**2、为什么最后返回 left - 1 而不像左侧边界的函数，返回 left？而且我觉得这里既然是搜索右侧边界，应该返回 right 才对。**\n\n答：首先，while 循环的终止条件是 left == right，所以 left 和 right 是一样的，你非要体现右侧的特点，返回 right - 1 好了。\n\n至于为什么要减一，这是搜索右侧边界的一个特殊点，关键在这个条件判断：\n\n    if (nums[mid] == target) {\n        left = mid + 1;\n        // 这样想: mid = left - 1\n\n因为我们对 left 的更新必须是 left = mid + 1，就是说 while 循环结束时，nums[left] 一定不等于 target 了，而 nums[left-1] 可能是 target。\n\n至于为什么 left 的更新必须是 left = mid + 1，同左侧边界搜索，就不再赘述。\n\n3、为什么没有返回 -1 的操作？如果 nums 中不存在 target 这个值，怎么办？\n\n答：类似之前的左侧边界搜索，因为 while 的终止条件是 left == right，就是说 left 的取值范围是 [0, nums.length]，所以可以添加两行代码，正确地返回 -1：\n\n    while (left < right) {\n        // ...\n    }\n    if (left == 0) return -1;\n    return nums[left-1] == target ? (left-1) : -1;\n\n4、是否也可以把这个算法的「搜索区间」也统一成两端都闭的形式呢？这样这三个写法就完全统一了，以后就可以闭着眼睛写出来了。\n\n答：当然可以，类似搜索左侧边界的统一写法，其实只要改两个地方就行了：\n\n    int right_bound(int[] nums, int target) {\n        int left = 0, right = nums.length - 1;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] < target) {\n                left = mid + 1;\n            } else if (nums[mid] > target) {\n                right = mid - 1;\n            } else if (nums[mid] == target) {\n                // 这里改成收缩左侧边界即可\n                left = mid + 1;\n            }\n        }\n        // 这里改为检查 right 越界的情况，见下图\n        if (right < 0 || nums[right] != target)\n            return -1;\n        return right;\n    }\n\n当 target 比所有元素都小时，right 会被减到 -1，所以需要在最后防止越界：\n\n至此，搜索右侧边界的二分查找的两种写法也完成了，其实将「搜索区间」统一成两端都闭反而更容易记忆，你说是吧？\n四、逻辑统一\n\n来梳理一下这些细节差异的因果逻辑：\n\n第一个，最基本的二分查找算法：\n\n因为我们初始化 right = nums.length - 1\n所以决定了我们的「搜索区间」是 [left, right]\n所以决定了 while (left <= right)\n同时也决定了 left = mid+1 和 right = mid-1\n\n因为我们只需找到一个 target 的索引即可\n所以当 nums[mid] == target 时可以立即返回\n\n第二个，寻找左侧边界的二分查找：\n\n因为我们初始化 right = nums.length\n所以决定了我们的「搜索区间」是 [left, right)\n所以决定了 while (left < right)\n同时也决定了 left = mid + 1 和 right = mid\n\n因为我们需找到 target 的最左侧索引\n所以当 nums[mid] == target 时不要立即返回\n而要收紧右侧边界以锁定左侧边界\n\n第三个，寻找右侧边界的二分查找：\n\n因为我们初始化 right = nums.length\n所以决定了我们的「搜索区间」是 [left, right)\n所以决定了 while (left < right)\n同时也决定了 left = mid + 1 和 right = mid\n\n因为我们需找到 target 的最右侧索引\n所以当 nums[mid] == target 时不要立即返回\n而要收紧左侧边界以锁定右侧边界\n\n又因为收紧左侧边界时必须 left = mid + 1\n所以最后无论返回 left 还是 right，必须减一\n\n对于寻找左右边界的二分搜索，常见的手法是使用左闭右开的「搜索区间」，我们还根据逻辑将「搜索区间」全都统一成了两端都闭，便于记忆，只要修改两处即可变化出三种写法：\n\n    int binary_search(int[] nums, int target) {\n        int left = 0, right = nums.length - 1; \n        while(left <= right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] < target) {\n                left = mid + 1;\n            } else if (nums[mid] > target) {\n                right = mid - 1; \n            } else if(nums[mid] == target) {\n                // 直接返回\n                return mid;\n            }\n        }\n        // 直接返回\n        return -1;\n    }\n    \n    int left_bound(int[] nums, int target) {\n        int left = 0, right = nums.length - 1;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] < target) {\n                left = mid + 1;\n            } else if (nums[mid] > target) {\n                right = mid - 1;\n            } else if (nums[mid] == target) {\n                // 别返回，锁定左侧边界\n                right = mid - 1;\n            }\n        }\n        // 最后要检查 left 越界的情况\n        if (left >= nums.length || nums[left] != target)\n            return -1;\n        return left;\n    }\n\n\n    int right_bound(int[] nums, int target) {\n        int left = 0, right = nums.length - 1;\n        while (left <= right) {\n            int mid = left + (right - left) / 2;\n            if (nums[mid] < target) {\n                left = mid + 1;\n            } else if (nums[mid] > target) {\n                right = mid - 1;\n            } else if (nums[mid] == target) {\n                // 别返回，锁定右侧边界\n                left = mid + 1;\n            }\n        }\n        // 最后要检查 right 越界的情况\n        if (right < 0 || nums[right] != target)\n            return -1;\n        return right;\n    }\n\n如果以上内容你都能理解，那么恭喜你，二分查找算法的细节不过如此。\n\n通过本文，你学会了：\n\n1、分析二分查找代码时，不要出现 else，全部展开成 else if 方便理解。\n\n2、注意「搜索区间」和 while 的终止条件，如果存在漏掉的元素，记得在最后检查。\n\n3、如需定义左闭右开的「搜索区间」搜索左右边界，只要在 nums[mid] == target 时做修改即可，搜索右侧时需要减一。\n\n4、如果将「搜索区间」全都统一成两端都闭，好记，只要稍改 nums[mid] == target 条件处的代码和返回的逻辑即可，推荐拿小本本记下，作为二分搜索模板。\n\n作者：labuladong\n链接：https://leetcode-cn.com/problems/binary-search/solution/er-fen-cha-zhao-xiang-jie-by-labuladong/\n来源：力扣（LeetCode）\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n","tags":["数据结构与算法"],"categories":["算法笔记"]},{"title":"二叉树三种遍历的迭代写法","url":"//post/二叉树四种遍历的迭代写法.html","content":"\n## 前序遍历\n\n前序遍历指的是按根节点、左子节点、右子节点这种顺序遍历的过程，因为最先遍历根节点，因此命名为前序遍历，使用递归算法的话，写法很简单，但耗时较多，因此在追求性能的情况下，我们一般使用迭代算法。迭代算法实际上是把递归算法中的系统调用栈显式的自己写出来。\n\n迭代版前序遍历的过程如动画所示：\n\n1. 首先，根节点入栈。\n2. 进入循环，终止条件为栈空。\n3. 每次从栈中弹出元素，然后访问这个被弹出元素（对这个元素进行需要的操作，如打印，加入结果集等等）\n4. 把上一步被弹出元素的右子节点压入栈中。\n5. 把上一步被弹出元素的左子节点压入栈中。\n6. 回到第二步，继续。\n\n这个过程还是相对好理解的，先遍历根节点，然后压入右节点和左节点，因为栈的出栈顺序和入栈顺序是相反的，因此是先压入右节点。\n\n![](https://pic.leetcode-cn.com/c455ec4e7f33352334ceb3af14e3b53297a36cc7891dab2abf66be35b239d664.gif)\n\n代码：\n\n```java\npublic List<Integer> preorderTraversal2(TreeNode root) {\n  List<Integer> result = new ArrayList<>();\n  if (root == null)\n    return result;\n  Deque<TreeNode> stack = new LinkedList<>();\n  stack.push(root);\n  while (!stack.isEmpty()) {\n    TreeNode node = stack.pop();\n    result.add(node.val);\n    //因为从栈中弹出，顺序会反过来，所以要反着来，让右子树先入栈\n    if (node.right != null)\n      stack.push(node.right);\n    if (node.left != null)\n      stack.push(node.left);\n  }\n  return result;\n}\n```\n\n## 中序遍历\n\n看完前序遍历，我们来看看中序遍历，中序遍历是以左节点，根节点，右节点，这样的顺序遍历的。也利用到了栈这个数据结构，我们先看动画来大致感受一下过程。\n\n![](https://pic.leetcode-cn.com/47fff35dd3fd640ba60349c78b85242ae8f4b850f06a282cd7e92c91e6eff406-1.gif)\n\n中序遍历的过程是这样的：\n\n1. 开始循环，终止条件为栈空或是当前访问的节点为空。\n2. 从根节点开始，不断将左节点入栈，知道左节点为空。\n3. 出栈，将弹出元素加入结果集。\n4. 将弹出元素的右节点加入栈中。\n5. 回到第1步。\n\n过程这样理解，因为要先访问左节点，所以先将左节点加入栈中，然后开始弹出并加入结果集，这一步就完成了访问左节点和访问根节点了，然后每弹出一个节点就加入它的右子节点，然后之后再弹出，这样右节点也访问了，这就完成了中序遍历。\n\n代码：\n\n```java\npublic List<Integer> inorderTraversal2(TreeNode root) {\n  List<Integer> result = new ArrayList<>();\n  Deque<TreeNode> stack = new LinkedList<>();\n  while (root != null || !stack.isEmpty()) {\n    while (root != null) {\n      stack.push(root);\n      root = root.left;\n    }\n    root = stack.pop();\n    result.add(root.val);\n    root = root.right;\n  }\n  return result;\n}\n```\n\n## 后序遍历\n\n相对与前两个遍历而言，后序遍历是最难写的，思路还是一样，利用栈，完成左节点，右节点，根节点的遍历。难的地方在于左右节点入栈后不知道根节点是谁，所以需要一个临时的变量来保存根节点的变量。\n\n但是后序遍历又可以另辟蹊径，它是左右根这个顺序，而前序遍历是根左右这个顺序，我们可以调整一下前序遍历的顺序，变为根右左，然后反转一下，就变成了左右根了。\n\n代码：\n\n```java\nList<Integer> postorderTraversal1(TreeNode root) {\n  List<Integer> result = new ArrayList<>();\n  if (root == null)\n    return result;\n  Deque<TreeNode> stack = new LinkedList<>();\n  Deque<Integer> revStack = new LinkedList<>();\n  stack.push(root);\n  while (!stack.isEmpty()) {\n    TreeNode node = stack.pop();\n    revStack.push(node.val);\n    if (node.left != null)\n      stack.push(node.left);\n    if (node.right != null)\n      stack.push(node.right);\n  }\n  while (!revStack.isEmpty()) {\n    result.add(revStack.pop());\n  }\n  return result;\n}\n```\n\n但上面那种做法无疑有失技术水准，正经做法还是贴一下，理解与否看个人：\n\n```java\nList<Integer> postorderTraversal2(TreeNode root) {\n  List<Integer> result = new ArrayList<>();\n  if (root == null)\n    return result;\n  Deque<TreeNode> stack = new LinkedList<>();\n  stack.push(root);\n  TreeNode cur = root;\n  while (!stack.isEmpty()) {\n    TreeNode peek = stack.peek();\n    if (peek.left != null && peek.left != cur && peek.right != cur)\n      stack.push(peek.left);\n    else if (peek.right != null && peek.right != cur)\n      stack.push(peek.right);\n    else {\n      result.add(stack.pop().val);\n      cur = peek;\n    }\n  }\n  return result;\n}\n```\n\n## 层序遍历\n\n层序遍历，顾名思义就是按照二叉树每层的顺序来遍历，使用迭代法是配合广度优先搜索，比前三种要好理解得多。\n\n![img](https://pic.leetcode-cn.com/94cd1fa999df0276f1dae77a9cca83f4cabda9e2e0b8571cd9550a8ee3545f56.gif)\n\n```java\npublic List<List<Integer>> levelOrder(TreeNode root) {\n  List<List<Integer>> res = new LinkedList<>();\n  if (root == null)\n    return res;\n  Queue<TreeNode> queue = new LinkedList<>();\n  queue.add(root);\n  while (!queue.isEmpty()) {\n    int n = queue.size();\n    List<Integer> list = new LinkedList<>();\n    for (int i = 0; i < n; i++) {\n      TreeNode node = queue.poll();\n      list.add(node.val);\n      if (node.left != null)\n        queue.add(node.left);\n      if (node.right != null)\n        queue.add(node.right);\n    }\n    res.add(list);\n  }\n  return res;\n}\n```\n\n","tags":["数据结构与算法"],"categories":["算法笔记"]},{"title":"LeetCode中的一些栈题","url":"//post/LeetCode中经典的栈题.html","content":"\n#### [1. 有效的括号（LC第20题）](https://leetcode-cn.com/problems/valid-parentheses/)\n\n给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。\n\n有效字符串需满足：\n\n1. 左括号必须用相同类型的右括号闭合。\n2. 左括号必须以正确的顺序闭合。\n\n**示例 1：**\n\n```\n输入：s = \"()\"\n输出：true\n```\n\n**示例 2：**\n\n```\n输入：s = \"()[]{}\"\n输出：true\n```\n\n**示例 3：**\n\n```\n输入：s = \"(]\"\n输出：false\n```\n\n**示例 4：**\n\n```\n输入：s = \"([)]\"\n输出：false\n```\n\n**示例 5：**\n\n```\n输入：s = \"{[]}\"\n输出：true\n```\n\n**提示：**\n\n- `1 <= s.length <= 104`\n- `s` 仅由括号 `'()[]{}'` 组成\n\n1. 只使用栈对字符串进行逐一匹配处理，对字符串遍历，如果遇上左括号，则入栈，如果遇上右括号，则判断当前栈顶是不是对应的左括号，如果是，则弹出，如果栈为空，或者不是对应的左括号，则return false。字符串全部遍历完之后，还要判断一下栈是否为空，如果为空，说明所有的左括号都和对应的右括号匹配了，此时才确定是匹配了。\n\n```java\npublic static boolean isValid1(String s) {\n  if (s == null || \"\".equals(s))\n    return true;\n  int i = 0;\n  Stack<Character> stack = new Stack<>();\n  stack.push(s.charAt(i++));\n  while (i < s.length()) {\n    if (s.charAt(i) == '(' || s.charAt(i) == '[' || s.charAt(i) == '{')\n      stack.push(s.charAt(i));\n    else if (s.charAt(i) == ')') {\n      if (stack.empty() || stack.peek() != '(')\n        return false;\n      else if (stack.peek() == '(')\n        stack.pop();\n    } else if (s.charAt(i) == '}') {\n      if (stack.empty() || stack.peek() != '{')\n        return false;\n      else if (stack.peek() == '{')\n        stack.pop();\n    } else if (s.charAt(i) == ']') {\n      if (stack.empty() || stack.peek() != '[')\n        return false;\n      else if (stack.peek() == '[')\n        stack.pop();\n    }\n    i++;\n  }\n  return stack.empty();\n}\n```\n\n2. 利用hashmap，思路相似，但是不用在意过多的细节。\n\n```java\npublic static boolean isValid2(String s) {\n  if (s == null || \"\".equals(s))\n    return true;\n  HashMap<Character, Character> map = new HashMap<>() {\n    {\n      put('(', ')');\n      put('{', '}');\n      put('[', ']');\n      put('?', '?');//处理边界问题\n    }\n  };\n  Stack<Character> stack = new Stack<>() {{\n    push('?');\n  }};\n  for (char c : s.toCharArray()) {\n    //如果是左括号，那么就推入栈中\n    if (map.containsKey(c))\n      stack.push(c);\n      //如果是右括号，那么就看栈顶的左括号对应的是不是正确的右括号，不是就返回false\n      //如果第一个字符是右括号，此时栈是空的，会报错，所以加了问号\n    else if (map.get(stack.pop()) != c)\n      return false;\n  }\n  //最后会遗留一个左括号\n  return stack.size() == 1;\n}\n```\n\n#### [2. 字符串解码（LC第394题）](https://leetcode-cn.com/problems/decode-string/)\n\n给定一个经过编码的字符串，返回它解码后的字符串。\n\n编码规则为: `k[encoded_string]`，表示其中方括号内部的 *encoded_string* 正好重复 *k* 次。注意 *k* 保证为正整数。\n\n你可以认为输入字符串总是有效的；输入字符串中没有额外的空格，且输入的方括号总是符合格式要求的。\n\n此外，你可以认为原始数据不包含数字，所有的数字只表示重复的次数 *k* ，例如不会出现像 `3a` 或 `2[4]` 的输入。\n\n**示例 1：**\n\n```\n输入：s = \"3[a]2[bc]\"\n输出：\"aaabcbc\"\n```\n\n**示例 2：**\n\n```\n输入：s = \"3[a2[c]]\"\n输出：\"accaccacc\"\n```\n\n**示例 3：**\n\n```\n输入：s = \"2[abc]3[cd]ef\"\n输出：\"abcabccdcdcdef\"\n```\n\n**示例 4：**\n\n```\n输入：s = \"abc3[cd]xyz\"\n输出：\"abccdcdcdxyz\"\n```\n\n代码：\n\n```java\npublic static String decodeString(String s) {\n    //设置两个栈，一个保存数字，一个保存已经生成的字符串结果\n    Deque<Integer> numStack = new LinkedList<>();\n    Deque<String> resStack = new LinkedList<>();\n    //重复次数\n    int mul = 0;\n    StringBuffer res = new StringBuffer();\n    for (Character c : s.toCharArray()) {\n      //如果遇上数字，则保存为重复次数\n      if (c >= '0' && c <= '9') {\n        mul = mul * 10 + (c - '0');\n      } else if (c == '[') {\n        //遇上左括号，先把外部的重复次数和已经生成的字符串存入栈中，后面遇上右括号再弹出来生成字符串\n        numStack.push(mul);\n        resStack.push(res.toString());\n        //进入括号内部，要重新开始\n        mul = 0;\n        res = new StringBuffer();\n      } else if (c == ']') {\n        //遇上右括号，开始生成字符串\n        //弹出重复次数\n        int curMul = numStack.pop();\n        StringBuffer stringBuffer = new StringBuffer();\n        //生成字符串\n        for (int i = 0; i < curMul; i++) {\n          stringBuffer.append(res);\n        }\n        //总结果字符串是之前已经生成的字符串加上本次生成的字符串\n        res = new StringBuffer(resStack.pop() + stringBuffer);\n      } else {\n        res.append(c);\n      }\n    }\n    return res.toString();\n  }\n```\n","tags":["数据结构与算法","LeetCode"],"categories":["算法笔记"]},{"title":"LeetCode中的单调栈题","url":"//post/LeetCode中的单调栈题.html","content":"\n## 单调栈系列题目\n\n**单调栈解法的介绍**：https://leetcode-cn.com/problems/next-greater-element-i/solution/dan-diao-zhan-jie-jue-next-greater-number-yi-lei-w/\n\n#### [5. 每日温度（LC第739题）](https://leetcode-cn.com/problems/daily-temperatures/)\n\n请根据每日 `气温` 列表 `temperatures` ，请计算在每一天需要等几天才会有更高的温度。如果气温在这之后都不会升高，请在该位置用 `0` 来代替。\n\n**示例 1:**\n\n```\n输入: temperatures = [73,74,75,71,69,72,76,73]\n输出: [1,1,4,2,1,1,0,0]\n```\n\n**示例 2:**\n\n```\n输入: temperatures = [30,40,50,60]\n输出: [1,1,1,0]\n```\n\n**示例 3:**\n\n```\n输入: temperatures = [30,60,90]\n输出: [1,1,0]\n```\n\n**提示：**\n\n- `1 <= temperatures.length <= 105`\n- `30 <= temperatures[i] <= 100`\n\n两种思路，暴力法和单调栈法。\n\n### 暴力法：\n\n二重循环，每遇到一个温度小于等于本日温度的日子，就自增计数器，遇上了大于的本日温度的日子则给结果赋计数器的值，然后结束本轮循环。\n\n```java\npublic int[] dailyTemperatures1(int[] temperatures) {\n  int[] res = new int[temperatures.length];\n  for (int i = 0; i < temperatures.length; i++) {\n    int temp = 1;\n    for (int j = i + 1; j < temperatures.length; j++) {\n      if (temperatures[j] <= temperatures[i])\n        temp++;\n      else {\n        res[i] = temp;\n        break;\n      }\n    }\n  }\n  return res;\n}\n```\n\n### 单调递减栈法\n\n贴一下动画的详解：https://leetcode-cn.com/problems/daily-temperatures/solution/leetcode-tu-jie-739mei-ri-wen-du-by-misterbooo/\n\n对每个元素进行如下处理：\n\n1. 如果栈空直接入栈。\n2. 栈不空，则判断栈顶的元素是大于还是小于当前处理的元素，如果大于，那么为了维护栈的递减性，则需要将栈顶元素弹出，同时，当前元素的下标减栈顶元素的下标则为本位置的结果。\n3. 重复以上操作。\n\n```java\npublic int[] dailyTemperatures2(int[] temperatures) {\n  Deque<Integer> stack = new LinkedList<>();\n  int[] res = new int[temperatures.length];\n  for (int i = 0; i < temperatures.length; i++) {\n    while (!stack.isEmpty() && temperatures[i] > temperatures[stack.peek()]) {\n      int a = stack.peek();\n      stack.pop();\n      res[a] = i - a;\n    }\n    stack.push(i);\n  }\n  return res;\n}\n```\n\n#### [6. 下一个更大元素 I（LC第496题）](https://leetcode-cn.com/problems/next-greater-element-i/)\n\n给你两个 **没有重复元素** 的数组 `nums1` 和 `nums2` ，其中`nums1` 是 `nums2` 的子集。\n\n请你找出 `nums1` 中每个元素在 `nums2` 中的下一个比其大的值。\n\n`nums1` 中数字 `x` 的下一个更大元素是指 `x` 在 `nums2` 中对应位置的右边的第一个比 `x` 大的元素。如果不存在，对应位置输出 `-1` 。\n\n**示例 1:**\n\n```\n输入: nums1 = [4,1,2], nums2 = [1,3,4,2].\n输出: [-1,3,-1]\n解释:\n    对于 num1 中的数字 4 ，你无法在第二个数组中找到下一个更大的数字，因此输出 -1 。\n    对于 num1 中的数字 1 ，第二个数组中数字1右边的下一个较大数字是 3 。\n    对于 num1 中的数字 2 ，第二个数组中没有下一个更大的数字，因此输出 -1 。\n```\n\n**示例 2:**\n\n```\n输入: nums1 = [2,4], nums2 = [1,2,3,4].\n输出: [3,-1]\n解释:\n    对于 num1 中的数字 2 ，第二个数组中的下一个较大数字是 3 。\n    对于 num1 中的数字 4 ，第二个数组中没有下一个更大的数字，因此输出 -1 。\n```\n\n**提示：**\n\n- `1 <= nums1.length <= nums2.length <= 1000`\n- `0 <= nums1[i], nums2[i] <= 104`\n- `nums1`和`nums2`中所有整数 **互不相同**\n- `nums1` 中的所有整数同样出现在 `nums2` 中\n\n**进阶：**你可以设计一个时间复杂度为 `O(nums1.length + nums2.length)` 的解决方案吗？\n\n### 暴力法：时间复杂度O(n^2)\n\n```java\npublic int[] nextGreaterElement1(int[] nums1, int[] nums2) {\n  int[] res = new int[nums1.length];\n  for (int i = 0; i < nums1.length; i++) {\n    int flag = 0;\n    for (int j = 0; j < nums2.length; j++) {\n      if (nums1[i] == nums2[j] && nums2.length - 1 != j) {\n        flag = 1;\n        continue;\n      } else if (flag == 1 && nums2[j] > nums1[i]) {\n        res[i] = nums2[j];\n        break;\n      } else if (j == nums2.length - 1)\n        res[i] = -1;\n    }\n  }\n  return res;\n}\n```\n\n### 单调栈法：\n\n本题配合哈希表一起解，先用单调栈法求出num2每个元素对应的nextGreaterNum，然后存入哈希表，之后再对num1遍历，对num1中的每个元素取出哈希表中的nextGreaterNum，然后给结果赋值，如果没有对应的键，说明没有nextGreaterNum了，就可以给结果赋-1。\n\n```java\n//单调栈法\npublic int[] nextGreaterElement2(int[] nums1, int[] nums2) {\n  int[] res = new int[nums1.length];\n  Deque<Integer> stack = new LinkedList<>();\n  HashMap<Integer, Integer> hashMap = new HashMap<>();\n  for (int i = 0; i < nums2.length; i++) {\n    while (!stack.isEmpty() && stack.peek() < nums2[i]) {\n      hashMap.put(stack.pop(), nums2[i]);\n    }\n    stack.push(nums2[i]);\n  }\n  for (int i = 0; i < nums1.length; i++) {\n    res[i] = hashMap.containsKey(nums1[i]) ? (hashMap.get(nums1[i])) : -1;\n  }\n  return res;\n}\n```\n\n#### [7. 下一个更大元素 II（LC第503题）](https://leetcode-cn.com/problems/next-greater-element-ii/)\n\n给定一个循环数组（最后一个元素的下一个元素是数组的第一个元素），输出每个元素的下一个更大元素。数字 x 的下一个更大的元素是按数组遍历顺序，这个数字之后的第一个比它更大的数，这意味着你应该循环地搜索它的下一个更大的数。如果不存在，则输出 -1。\n\n**示例 1:**\n\n```\n输入: [1,2,1]\n输出: [2,-1,2]\n解释: 第一个 1 的下一个更大的数是 2；\n数字 2 找不到下一个更大的数； \n第二个 1 的下一个最大的数需要循环搜索，结果也是 2。\n```\n\n**注意:** 输入数组的长度不会超过 10000。\n\n基本思路还是单调栈，但要注意对循环的处理。这里的处理办法是将长度乘2，然后下标取模即可。\n\n```java\npublic int[] nextGreaterElements(int[] nums) {\n  int[] res = new int[nums.length];\n  Arrays.fill(res, -1);\n  Deque<Integer> stack = new LinkedList<>();\n  int length = nums.length;\n  for (int i = 0; i < nums.length * 2; i++) {\n    while (!stack.isEmpty() && nums[stack.peek()] < nums[i % length]) {\n      res[stack.pop()] = nums[i % length];\n    }\n    stack.push(i % length);\n  }\n  return res;\n}\n```\n\n","tags":["数据结构与算法","LeetCode"],"categories":["算法笔记"]},{"title":"LeetCode中经典的链表题","url":"//post/LeetCode中经典的链表题.html","content":"\n####  [1. 两数相加（LC第2题）](https://leetcode-cn.com/problems/add-two-numbers/)\n\n给你两个 **非空** 的链表，表示两个非负的整数。它们每位数字都是按照 **逆序** 的方式存储的，并且每个节点只能存储 **一位** 数字。\n\n请你将两个数相加，并以相同形式返回一个表示和的链表。\n\n你可以假设除了数字 0 之外，这两个数都不会以 0 开头。\n\n**示例 1：**\n\n![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2021/01/02/addtwonumber1.jpg)\n\n```\n输入：l1 = [2,4,3], l2 = [5,6,4]\n输出：[7,0,8]\n解释：342 + 465 = 807.\n```\n\n**示例 2：**\n\n```\n输入：l1 = [0], l2 = [0]\n输出：[0]\n```\n\n**示例 3：**\n\n```\n输入：l1 = [9,9,9,9,9,9,9], l2 = [9,9,9,9]\n输出：[8,9,9,9,0,0,0,1]\n```\n\n**提示：**\n\n- 每个链表中的节点数在范围 `[1, 100]` 内\n- `0 <= Node.val <= 9`\n- 题目数据保证列表表示的数字不含前导零\n\n本题思路很正常，主要的难点在于各种细节的处理。直接看代码上的注释。\n\n```java\npublic ListNode addTwoNumbers(ListNode l1, ListNode l2) {\n  //设置哑节点\n  ListNode dummy = new ListNode(0);\n  //curr为当前两个链表节点值相加的结果的新节点\n  ListNode p1 = l1, p2 = l2, curr = dummy;\n  //进位\n  int carry = 0;\n  while (p1 != null || p2 != null) {\n    int x = (p1 != null) ? p1.val : 0;\n    int y = (p2 != null) ? p2.val : 0;\n    //当前节点值相加的结果还要加上进位\n    int sum = carry + x + y;\n    //本次相加产生的进位\n    carry = sum / 10;\n    //本级相加的结果对10取余数\n    curr.next = new ListNode(sum % 10);\n    //移动节点\n    curr = curr.next;\n    if (p1 != null)\n      p1 = p1.next;\n    if (p2 != null)\n      p2 = p2.next;\n  }\n  //最高位有进位还要补上\n  if (carry > 0)\n    curr.next = new ListNode(carry);\n  return dummy.next;\n}\n```\n\n本题的几个重点：\n\n1. 注意对进位的处理，首先，当前节点值相加还要加上上一次相加带来的进位。其次，本次产生的进位直接用sum/10得到，不用if分类讨论，而本次相加的结果则对10取余数即可。\n2. 当全部加完之后，最高位可能也有进位，要记得补上。\n3. 使用哑节点避免出现空指针的情况。\n\n#### [2. 删除链表的倒数第 N 个结点（LC第19题）](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)\n\n给你一个链表，删除链表的倒数第 `n` 个结点，并且返回链表的头结点。\n\n**示例 1：**\n\n![img](https://assets.leetcode.com/uploads/2020/10/03/remove_ex1.jpg)\n\n```\n输入：head = [1,2,3,4,5], n = 2\n输出：[1,2,3,5]\n```\n\n**示例 2：**\n\n```\n输入：head = [1], n = 1\n输出：[]\n```\n\n**示例 3：**\n\n```\n输入：head = [1,2], n = 1\n输出：[1]\n```\n\n**提示：**\n\n- 链表中结点的数目为 `sz`\n- `1 <= sz <= 30`\n- `0 <= Node.val <= 100`\n- `1 <= n <= sz`\n\n**进阶：**你能尝试使用一趟扫描实现吗？\n\n这题实际上是要删除第length-n+1个节点，基于这个本质有两个思路：\n\n1. 第一个常规思路：**两趟扫描，第一趟得到链表的长度，第二趟移动到第length-n个节点，从而调整指针指向将length-n+1个节点删除**。\n2. 进阶思路：**一趟扫描，设置两个指针，其中一个指针先走到n+1个节点上，然后两个指针开始同时走，当在前面的指针到达终点时，后面的指针也移到了第length-n个节点上，可以删除了。**\n\n思路1代码：\n\n```java\npublic ListNode removeNthFromEnd1(ListNode head, int n) {\n  ListNode dummy = new ListNode(0);\n  dummy.next = head;\n  int length = 0;\n  ListNode movement = head;\n  if (movement != null) {\n    movement = movement.next;\n    length++;\n  }\n  length -= n;\n  movement = dummy;\n  while (length != 0) {\n    length--;\n    movement = movement.next;\n  }\n  movement.next = movement.next.next;\n  return dummy.next;\n}\n```\n\n思路2代码：\n\n```java\npublic ListNode removeNthFromEnd2(ListNode head, int n) {\n  //设置两个指针，第一个指针先移动到第二个指针前面n+1个节点处\n  //然后同时移动两个指针，当第一个指针达到链表末尾，第二个指针也就达到了要删除节点的前一个\n  ListNode dummy = new ListNode(0);\n  dummy.next = head;\n  ListNode first = dummy;\n  ListNode second = dummy;\n  for (int i = 1; i <= n + 1; i++) {\n    first = first.next;\n  }\n  while (first != null) {\n    first = first.next;\n    second = second.next;\n  }\n  second.next = second.next.next;\n  return dummy.next;\n}\n```\n\n#### [3. 合并两个有序链表（LC第21题）](https://leetcode-cn.com/problems/merge-two-sorted-lists/)\n\n将两个升序链表合并为一个新的 **升序** 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 \n\n**示例 1：**\n\n![img](https://assets.leetcode.com/uploads/2020/10/03/merge_ex1.jpg)\n\n```\n输入：l1 = [1,2,4], l2 = [1,3,4]\n输出：[1,1,2,3,4,4]\n```\n\n**示例 2：**\n\n```\n输入：l1 = [], l2 = []\n输出：[]\n```\n\n**示例 3：**\n\n```\n输入：l1 = [], l2 = [0]\n输出：[0]\n```\n\n**提示：**\n\n- 两个链表的节点数目范围是 `[0, 50]`\n- `-100 <= Node.val <= 100`\n- `l1` 和 `l2` 均按 **非递减顺序** 排列\n\n思路很朴素，一个个比，一个个连，但是实现方式有两种：\n\n1. 直接迭代，注意点在与迭代完后必然还会剩一个节点，要记得接上：\n\n```java\npublic ListNode mergeTwoLists1(ListNode l1, ListNode l2) {\n    //哑节点\n  ListNode dummy = new ListNode(0);\n  ListNode cur = dummy;\n  while (l1 != null && l2 != null) {\n    if (l1.val < l2.val) {\n      cur.next = l1;\n      l1 = l1.next;\n    } else {\n      cur.next = l2;\n      l2 = l2.next;\n    }\n    cur = cur.next;\n  }\n  //当l1和l2经过上面的迭代后，还会剩下最后一个，要补上\n  cur.next = (l1 == null) ? l2 : l1;\n  return dummy.next;\n}\n```\n\n2. 递归，比较考验思考，但是代码很简洁漂亮：\n\n```java\npublic ListNode mergeTwoLists2(ListNode l1, ListNode l2) {\n  if (l1 == null)\n    return l2;\n  if (l2 == null)\n    return l1;\n  if (l1.val < l2.val) {\n    l1.next = mergeTwoLists2(l1.next, l2);  //对l1.next, l2为头节点的两个链表进行合并\n    return l1;\n  } else {\n    l2.next = mergeTwoLists2(l2.next, l1); //对l2.next, l1为头节点的两个链表进行合并\n    return l2;\n  }\n}\n```\n\n#### [4. 环形链表（LC第141题）](https://leetcode-cn.com/problems/linked-list-cycle/)\n\n给你一个链表的头节点 `head` ，判断链表中是否有环。\n\n如果链表中有某个节点，可以通过连续跟踪 `next` 指针再次到达，则链表中存在环。 为了表示给定链表中的环，评测系统内部使用整数 `pos` 来表示链表尾连接到链表中的位置（索引从 0 开始）。如果 `pos` 是 `-1`，则在该链表中没有环。**注意：`pos` 不作为参数进行传递**，仅仅是为了标识链表的实际情况。\n\n如果链表中存在环，则返回 `true` 。 否则，返回 `false` 。\n\n**示例 1：**\n\n![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist.png)\n\n```\n输入：head = [3,2,0,-4], pos = 1\n输出：true\n解释：链表中有一个环，其尾部连接到第二个节点。\n```\n\n**示例 2：**\n\n![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test2.png)\n\n```\n输入：head = [1,2], pos = 0\n输出：true\n解释：链表中有一个环，其尾部连接到第一个节点。\n```\n\n**示例 3：**\n\n![img](https://assets.leetcode-cn.com/aliyun-lc-upload/uploads/2018/12/07/circularlinkedlist_test3.png)\n\n```\n输入：head = [1], pos = -1\n输出：false\n解释：链表中没有环。\n```\n\n**提示：**\n\n- 链表中节点的数目范围是 `[0, 104]`\n- `-105 <= Node.val <= 105`\n- `pos` 为 `-1` 或者链表中的一个 **有效索引** 。\n\n思路相当简单，但是对第一次见到这个题目可能不那么容易想到，不过见过一次就不可能忘了：**设置两个指针，一个一次走两步，一个一次走一步，如果有环，那么二者必然相遇，如果没有环，那么快的那个会先到达终点。**\n\n```java\n//双指针法,时间复杂度:O(n)，空间复杂度：O(1)，无需使用额外空间\npublic boolean hasCycle1(ListNode head) {\n    if (head == null || head.next == null)\n        return false;\n    ListNode slow = head, fast = head.next;\n    //让快指针走的更快，没有环就会到达终点返回false，否则快慢指针必然相遇\n    //返回true\n    while (slow != fast) {\n        if (fast == null || fast.next == null) {\n            return false;\n        }\n        slow = slow.next;\n        fast = fast.next.next;\n    }\n    return true;\n}\n```\n\n#### [5. 反转链表（LC第206题）](https://leetcode-cn.com/problems/reverse-linked-list/)\n\n给你单链表的头节点 `head` ，请你反转链表，并返回反转后的链表。\n\n**示例 1：**\n\n![img](https://assets.leetcode.com/uploads/2021/02/19/rev1ex1.jpg)\n\n```\n输入：head = [1,2,3,4,5]\n输出：[5,4,3,2,1]\n```\n\n**示例 2：**\n\n![img](https://assets.leetcode.com/uploads/2021/02/19/rev1ex2.jpg)\n\n```\n输入：head = [1,2]\n输出：[2,1]\n```\n\n**示例 3：**\n\n```\n输入：head = []\n输出：[]\n```\n\n**提示：**\n\n- 链表中节点的数目范围是 `[0, 5000]`\n- `-5000 <= Node.val <= 5000`\n\n**进阶：**链表可以选用迭代或递归方式完成反转。你能否用两种方法解决这道题？\n\n直接看代码上的注释吧：\n\n```java\npublic ListNode reverseList1(ListNode head) {\n        //pre是cur节点的上一个节点，cur是当前处理的节点\n        ListNode pre = null, cur = head;\n        while (cur != null) {\n            //临时保存cur的下个节点\n            ListNode temp = cur.next;\n            //把cur指向它的前一个节点，实现反转\n            cur.next = pre;\n            //pre和cur前移\n            pre = cur;\n            cur = temp;\n        }\n        return pre;\n    }\n```\n\n#### [6. 两两交换链表中的节点（LC第24题）](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)\n\n给定一个链表，两两交换其中相邻的节点，并返回交换后的链表。\n\n**你不能只是单纯的改变节点内部的值**，而是需要实际的进行节点交换。\n\n**示例 1：**\n\n![img](https://assets.leetcode.com/uploads/2020/10/03/swap_ex1.jpg)\n\n```\n输入：head = [1,2,3,4]\n输出：[2,1,4,3]\n```\n\n**示例 2：**\n\n```\n输入：head = []\n输出：[]\n```\n\n**示例 3：**\n\n```\n输入：head = [1]\n输出：[1]\n```\n\n**提示：**\n\n- 链表中节点的数目在范围 `[0, 100]` 内\n- `0 <= Node.val <= 100`\n\n \n\n**进阶：**你能在不修改链表节点值的情况下解决这个问题吗?（也就是说，仅修改节点本身。）\n\n迭代法：\n\n```java\npublic ListNode swapPairs1(ListNode head) {\n  //设置哑节点\n  ListNode dummyHead = new ListNode(0);\n  dummyHead.next = head;\n  ListNode temp = dummyHead;\n  //因为每次反转要处理两个节点，所以检测条件也要两个都检测\n  while (temp.next != null && temp.next.next != null) {\n    ListNode l1 = temp.next, l2 = temp.next.next;\n    //l1的前一个节点指向l2\n    temp.next = l2;\n    //l1的下一个节点变为l2的下一个节点\n    l1.next = l2.next;\n    //l2的下一个节点变为l1\n    l2.next = l1;\n    //temp前进\n    temp = l1;\n  }\n  return dummyHead.next;\n}\n```\n\n递归法（看不懂）：\n\n```java\npublic ListNode swapPairs2(ListNode head) {\n  if (head == null || head.next == null)\n    return head;\n  ListNode newHead = head.next;\n  head.next = swapPairs2(newHead.next);\n  newHead.next = head;\n  return newHead;\n}\n```\n","tags":["数据结构与算法","LeetCode"],"categories":["算法笔记"]},{"title":"JVM虚拟机的类加载机制","url":"//post/JVM虚拟机的类加载机制.html","content":"\n# JVM虚拟机的类加载机制\n\nJVM把描述类的数据从class文件中加载进内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型，这个过程被称作虚拟机的类加载机制。\n\n与Java类型相关的诸多工作都是在运行期完成的，这让Java的编译增加了额外的困难，也增加了性能开销，但是却为Java应用提供了极高的扩展性和灵活性，Java天生可以动态扩展的语言特性就是依赖运行期动态加载和动态连接这个特点实现的。\n\n## 1.1 类加载的时机\n\n一个类从被加载到内存开始，到卸载处内存为止它的整个生命周期将会经历加载\n（Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化（Initialization）、使用（Using）和卸载（Unloading）七个阶段，其中验证、准备、解析三个部分统称为连接（Linking）。\n\n其中，加载、验证、准备、初始化和卸载这五个阶段的顺序是确定的，类型的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定特性（也称为动态绑定或晚期绑定）。\n\n而何时开始进行类加载，也就是第一阶段“加载”，JVM规范并没有进行强制约束。但是对于初始化阶段，《Java虚拟机规范》则是严格规定了有且只有六种情况必须立即对类进行“初始化”。\n\n1. 遇到new、getstatic、putstatic或invokestatic这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。一般会生成这4条指令的场景有：使用new关键字实例化对象的时候，读取或设置一个类型的静态字段，调用一个类型的静态方法的时候。\n2. 使用反射时，如果类型没有进行过初始化，则需要先触发其初始化。\n3. 当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。\n4. 虚拟机启动时，虚拟机会先初始化带main方法的那个类（主类）\n5. 当使用JDK 7新加入的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化。\n6. 当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。\n\n接口的加载过程与类加载过程稍有不同，针对接口需要做一些特殊说明：接口也有初始化过程，这点与类是一致的，接口与类真正有所区别的是前面讲述的六种“有且仅有”需要触发初始化场景中的第三种：当一个类在初始化时，要求其父类全部都已经初始化过了，但是一个接口在初始化时，并不要求其父接口全部都完成了初始化，只有在真正使用到父接口的时候（如引用接口中定义的常量）才会初始化。\n\n## 1.2 类加载过程\n\n### 1.2.1 加载\n\n这个加载指的是“加载”（Loading）这一过程，在加载阶段，JVM需要完成下面这三件事：\n\n1. 通过一个类的全限定名来获取定义此类的二进制字节流。\n2. 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构。\n3. 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口。\n\n规范只简单的给了要求，并未要求具体的实现，因此开发人员在上面玩出了各种花样，war包，jar包等等就是其产物。\n\n相对于类加载过程的其他阶段，非数组类型的加载阶段是开发人员可控性最强的阶段。对于数组类而言，情况就有所不同，数组类本身不通过类加载器创建，它是由Java虚拟机直接在内存中动态构造出来的，但是其元素类型还是要通过类加载器来加载，数组类创建遵循以下规则：\n\n* 如果元素是引用类型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组C将被标识在加载该组件类型的类加载器的类名称空间上。\n* 如果元素是基本类型，Java虚拟机将会把数组C标记为与引导类加载器关联。\n* 数组类的可访问性与它的组件类型的可访问性一致，如果组件类型不是引用类型，它的数组类的可访问性将默认为public，可被所有的类和接口访问到。\n\n加载阶段结束后，二进制字节流就按虚拟机设定的格式存储在方法区中，格式由虚拟机自己定义。类型数据妥善安置在方法区之后，会在Java堆内存中实例化一个java.lang.Class类的对象，这个对象将作为程序访问方法区中的类型数据的外部接口。\n\n加载阶段与连接阶段的部分动作（如一部分字节码文件格式验证动作）是交叉进行的，加载阶段尚未完成，连接阶段可能已经开始，但这些夹在加载阶段之中进行的动作，仍然属于连接阶段的一部分，这两个阶段的开始时间仍然保持着固定的先后顺序。\n\n### 1.2.2 验证\n\n这是连接阶段的第一步，目的是确保文件中的字节流符合约束，保证代码运行后不危害虚拟机自身安全。\n\nJava是相对安全的语言（相比C/C++），使用代码通常很难做出危害虚拟机的事，但Class文件并不一定只能由Java源码编译而来，它可以使用包括靠键盘0和1直接在二进制编辑器中敲出Class文件在内的任何途径产生。因此验证字节码是JVM保护自己的必要措施之一。\n\n由于验证阶段非常重要，同时从代码量和耗费的执行性能的角度上讲，验证阶段的工作量在虚拟机的类加载过程中占了相当大的比重，因此其约束和规则相当之多（JDK7之后），但从整体上看，验证阶段大致上会完成下面四个阶段的检验动作：文件格式验证、元数据验证、字节码验证和符号引用验证。\n\n1. 文件格式验证\n\n   这一阶段可能包含以下验证点：\n\n   * 是否以魔数0xCAFEBABE开头。\n   * 主、次版本号是否在当前Java虚拟机接受范围之内。\n   * 常量池的常量中是否有不被支持的常量类型（检查常量tag标志）。\n   * ······\n\n   实际上第一阶段的验证点远不止此，这只是一小部分内容，该阶段的主要目的是保证输入的字节流能否正确地解析并存储于方法区之内，这阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证之后，这段字节流才被允许进入Java虚拟机内存的方法区中进行存储，所以后面的三个验证阶段全部是基于方法区的存储结构上进行的，不会再直接读取、操作字节流了。\n\n2. 元数据验证\n\n   这一阶段是对字节码描述的信息进行语义分析，以保证信息符合规范要求，验证点可能包括：\n\n   * 这个类是否有父类\n   * 是否继承了不允许被继承的类\n   * 字段和方法是否与父类产生了矛盾\n   * ······\n\n3. 字节码验证\n\n   这是最复杂的阶段，主要目的是通过数据流分析和控制流分析，确定\n   程序语义是合法的、符合逻辑的。这阶段对类的方法提（Code属性)进行校验分析，保证方法不出现危险行为，如：\n\n   * 保证保证任何跳转指令都不会跳转到方法体以外的字节码指令上。\n   * 保证类型转换总是有效的。\n   * ······\n\n   如果一个方法体通过了字节码验证，仍然不能保证它一定就是安全的，因为不能通过程序准确地检查出程序是否能在有限的时间之内结束运行。\n\n4. 符号引用验证\n\n   \n\n","tags":["Java","JVM","深入理解Java虚拟机"],"categories":["技术笔记"]},{"title":"剑指 Offer 04. 二维数组中的查找","url":"//post/剑指 Offer 04. 二维数组中的查找.html","content":"\n## 题目详情\n\n在一个 n * m 的二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个高效的函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。\n\n\n\n示例:\n\n现有矩阵 matrix 如下：\n\n[\n  [1,   4,  7, 11, 15],\n  [2,   5,  8, 12, 19],\n  [3,   6,  9, 16, 22],\n  [10, 13, 14, 17, 24],\n  [18, 21, 23, 26, 30]\n]\n\n给定 target = 5，返回 true。\n\n给定 target = 20，返回 false。\n\n限制：\n\n0 <= n <= 1000\n\n0 <= m <= 1000\n\n## 解法\n\n直接通过举例子说明解法吧，就用题目给的实例吧\n\n[\n  [1,   4,   7,   11, 15],\n  [2,   5,   8,   12, 19],\n  [3,   6,   9,   16, 22],\n  [10, 13, 14, 17, 24],\n  [18, 21, 23, 26, 30]\n]\n\n我们通过选取一个角落的数字和目标进行对比，从而排除掉不可能存在目标的区域\n\n第一步，目标是5，我们选取右上角的15，很明显5比15要小，而这个矩阵又有行列递增的性质，15既然是最后一列的第一个，那么说明它肯定是这一列最小的，而5比15还要小，那么这一列很明显可以排除。\n\n第二步，重复第一步，继续找剩下区域的右上角，如法炮制，我们可以把第四列，第三列也都排除掉，现在已经只剩两列了。\n\n第三步，我们还是选右上角，因为第三列，第四列，第五列已经都排除掉了，所以此时的右上角是4，5比4要大，而4已经它所在这一行最大的了，因此我们把这一行排除。\n\n第四步，找右上角，这次给我们找到了，因此返回true。\n\n总结一下步骤，每次循环都选取右上角的数字，然后根据对比的情况，比如是比目标小还是比目标打，从而变更搜寻的行或者列，当找到目标或者当前正在搜索的行或列已经越界时，跳出循环。\n\nJava代码\n\n```java\npublic boolean findNumberIn2DArray(int[][] matrix, int target) {\n    int rows = matrix.length;\n    if (rows == 0)\n      return false;\n    int cols = matrix[0].length;\n    boolean found = false;\n    if (!matrix.equals(null) && rows > 0 && cols > 0) {\n      int nowRow = 0, nowCol = matrix[0].length - 1;\n      while (nowRow < rows && nowCol >= 0) {\n        if (matrix[nowRow][nowCol] == target) {\n          found = true;\n          break;\n        } else if (matrix[nowRow][nowCol] > target) {\n          nowCol--;\n        } else {\n          nowRow++;\n        }\n      }\n    }\n    return found;\n  }\n```\n\n\n\n","tags":["数据结构与算法","剑指Offer"],"categories":["算法笔记"]},{"title":"Class文件中的属性表","url":"//post/Class文件中的属性表.html","content":"\n# Class文件中的属性表\n\nClass文件，字段表，方法表都可以携带自己的属性表集合，以描述某些场景专有的信息。\n\n为了能正确解析Class文件，《Java虚拟机规范》最初只预定义了9项所有Java虚拟机实现都应当能识别的属性，而在最新的《Java虚拟机规范》的Java SE 12版中，预定义属性已经增加到29项。先看看总表\n\n![1.PNG](https://i.loli.net/2021/08/23/kt1x9aH3domLrJN.png)\n\n![1.PNG](https://i.loli.net/2021/08/23/kt1x9aH3domLrJN.png)\n\n![3.PNG](https://i.loli.net/2021/08/23/XSPrYLW3ODlkgBb.png)\n\n对于每一个属性，它的名称都要从常量池中引用一个CONSTANT_Utf8_info类型的常量来表示，而属性值的结构则是完全自定义的，只需要通过一个u4的长度属性去说明属性值所占用的位数即可。一个符合规则的属性表应该满足下表中所定义的结构。\n\n![4.PNG](https://i.loli.net/2021/08/23/wmUkjleYfAoaSu8.png)\n\n## 1. Code属性\n\n代码在经过编译器编译后，最终变为字节码存储在Code属性内，它出现在方法表的属性集合里，但并非所有方法表都有这个属性，比如接口或抽象方法就不存在Code属性。它的结构如表所示。\n\n![1.PNG](https://i.loli.net/2021/08/23/M9KSwXC6jlyD3Zx.png)\n\nattribute_name_index是一项指向CONSTANT_Utf8_info型常量的索引，此常量值固定为“Code”，它代表了该属性的属性名称\n\n","tags":["Java","JVM","深入理解Java虚拟机"],"categories":["技术笔记"]},{"title":"JVM中的类文件结构","url":"//post/JVM中的类文件结构.html","content":"\n# JVM中的类文件结构\n\n**Class文件是一组以8个字节为基础单位的二进制流**，各个数据项目中严格按照顺序紧凑排列在一起，中间没有任何分隔符，当遇到了占位8个自己以上空间的数据项时，则会按照高位在前的方式分割成8个字节进行存储。\n\n## 1. Class文件格式\n\nClass文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：**“无符号数”和“表”**。后面的解析都要以这种数据类型为基础。\n\n* 无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，**无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值**。\n* 表是由多个无符号数或者其他表作为数据项构成的复合数据类型，为了便于区分，所有表的命名都习惯性地以“_info”结尾。**表用于描述有层次关系的复合结构的数据，整个Class文件本质上也可以视作是一张表**。\n\n## 2. Class文件结构\n\n### 2.1 魔数与Class文件的版本\n\n每个Class文件的头4个字节被称为**魔数**（Magic Number），**它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件**。很多文件格式都采用这种方式进行格式验证。\n\n使用魔数当然是基于安全考量，扩展名可以随意改动嘛。Class文件的魔数取得很有“浪漫气息”，值为0xCAFEBABE（咖啡宝贝？）\n\n**紧接着魔数的4个字节存储的是Class文件的版本号**：第5和第6个字节是次版本号（Minor Version），第7和第8个字节是主版本号（Major Version），版本号主要用来判断当前的虚拟机能否运行此class文件，高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件（即使文件格式并未发生变化），这是规范中明确定义的。\n\n### 2.2 常量池\n\n在版本号之后的是常量池入口，常量池可以比喻为Class文件里的资源仓库，**它是Class文件结构中与其他项目关联最多的数据**，通常也是占用Class文件空间最大的数据项目之一，另外，它还是在Class文件中第一个出现的表类型数据项目。\n\n常量池的入口有一项u2类型的数据，表示常量池容量计数值（constant_pool_count），和编程语言习惯不同的是，**这个计数是从1开始的而非0**，这样做的目的在于，如果后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义，可以把索引值设置为0来表示。只有常量池是例外，其他的结构的容量计数都从0开始。\n\n常量池中主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）。前者比较接近Java语言层面的常量概念，如文本字符串，被声明为final的常量值。而后者则属于编译原理方面的概念，主要包括以下几类：\n\n* 被模块导出或者开放的包（Package）\n* 被模块导出或者开放的包（Package）\n* 被模块导出或者开放的包（Package）\n* 方法的名称和描述符\n* 方法句柄和方法类型（Method Handle、Method Type、Invoke Dynamic）\n* 动态调用点和动态常量（Dynamically-Computed Call Site、Dynamically-Computed Constant）\n\nJava代码在编译时，在class文件中不会保存各方法，字段在内存中的布局信息，只有在虚拟机在做类加载时，才会从常量池中获取对应的符号引用，然后再在类创建时或运行时解析、翻译到具体的内存地址之中。\n\n常量池中的每一项常量都是一个表，截止至jdk13，常量表中一共有17种不同类型的常量，他们都有一个共同的特点，**表结构起始的第一位是个u1类型的标志位**，代表着当前常量属于哪种常量类型。他们所代表的具体含义如表所示。\n\n![捕获.PNG](https://i.loli.net/2021/08/19/cJI9BKfsXVubHwk.png)\n\n**每种常量的结构中，都有一项类型为u1的tag作为标志位来区分常量类型**，此外，还有各种各样的结构，详情继续看表\n\n![1.PNG](https://i.loli.net/2021/08/19/QG2TdunpEbRiIgs.png)\n\n![2.PNG](https://i.loli.net/2021/08/19/6X3QqZEsaUI74BL.png)\n\n![3.PNG](https://i.loli.net/2021/08/19/PQhXIiKm7vuLUEF.png)\n\n![4.PNG](https://i.loli.net/2021/08/19/3mwXEut4piByClL.png)\n\n### 2.3 访问标志\n\n在常量池结束之后，**紧接着的2个字节代表访问标志（access_flags），这个标志用来识别类或接口的访问信息**，包括：这个class文件是类还是接口；是public还是private；是否定义为abstract；是否被声明为final等等。\n\n具体含义如表所示\n\n![捕获.PNG](https://i.loli.net/2021/08/21/oYy7mUNLAVnw2HJ.png)\n\n访问标志中一共有2个字节，也就是16个标记位可以使用，截止到JDK9发布后，定义了9个，没用到的要求一律为0。\n\n### 2.4 类索引、父类索引与接口索引集合\n\n类索引（this_class）和父类索引（super_class）都是一个u2类型的数据，而接口索引集合（interfaces）是一组u2类型的数据的集合，**Class文件中由这三项数据来确定该类型的继承关系**。\n\n**类索引引用确定这个类的全限定明，父类索引引用用去确定它的父类的全限定名**。除了Object外，所有Java类都有父类，所有Java类的父类索引都不为0.\n\n**接口索引集合则用来描述这个类实现了哪些接口**，它们在文件中的排列顺序和implements关键字后的接口顺序一样。\n\n接口索引集合的第一项u2类型的数据为接口计数器，表示索引表的容量。如果该类没实现任何及接口，则该计数器的值0。\n\n类索引、父类索引和接口索引集合都按顺序排列在访问标志之后，类索引和父类索引用两个u2类型的索引值表示，它们各自指向一个类型为CONSTANT_Class_info的类描述符常量，通过CONSTANT_Class_info类型的常量中的索引值可以找到定义在CONSTANT_Utf8_info类型的常量中的全限定名字符串。\n\n### 2.5 字段表集合\n\n**字段表（field_info）用于描述接口或者类中声明的变量**。Java语言中的字段包括实例变量和类变量（静态变量，用static修饰），不包括方法中的局部变量。\n\n字段可以包括的修饰符有字段的作用域（public、private、protected修饰符）、是实例变量还是类变量（static修饰符）、可变性（final）、并发可见性（volatile修饰符，是否强制从主内存读写）、可否被序列化（transient修饰符）、字段数据类型（基本类型、对象、数组）、字段名称。\n\n上述信息中，要么有某个修饰符，要么没有，因此很适合用标志位来表示，而更具体的信息，比如字段名等，这些只能引用常量池中的常量来描述。\n\n字段表结构如表所示\n\n![捕获.PNG](https://i.loli.net/2021/08/21/Mo9LJ12kpjUdwAi.png)\n\n字段修饰符放在access_flags中，用来表示是否有某个修饰符，它和类中的access_flags非常像。\n\n![](https://i.loli.net/2021/08/21/1DNJLkCp2oiOfZm.png)\n\n跟随access_flags标志的是两项索引值，name_index和descriptor_index，它们都是对常量池项的引用，分别表示字段的简单名称，字段和方法的描述符。简单名称不说，描述符的作用是用来描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。根据描述符规则，基本数据类型（byte、char、double、float、int、long、short、boolean）以及代表无返回值的void类型都用一个大写字符来表示，而对象类型则用字符L加对象的全限定名来表示。\n\n![捕获.PNG](https://i.loli.net/2021/08/21/J6pXOj8x5D4ua1y.png)\n\n对于数组类型，每有一个维度就将使用一个前置的\"[\"字符来描述如一个定义为“java.lang.String[][]”类型的二维数组将被记录成“[[Ljava/lang/String；”。\n\n用描述符来描述方法时，按照先参数列表、后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号“()”之内。如方法java.lang.String toString()的描述符\n为“()Ljava/lang/String；”，方法int indexOf(char[]source，int sourceOffset，int sourceCount，char[]target，int targetOffset，int targetCount，int fromIndex)的描述符为“([CII[CIII)I”。\n\n字段表集合中不会列出从父类或者父接口中继承而来的字段，但有可能出现原本Java代码之中不存在的字段，譬如在内部类中为了保持对外部类的访问性，编译器就会自动添加指向外部类实例的字段。\n\n还有一个有趣的现象，在Java语言中，字段是无法重载的，但在class文件中，只要两个字段的描述符不是完全相同，那么字段重名是合法的。\n\n### 2.6 方法表集合\n\nclass文件存储格式中对方法的描述和对字段的描述采用了几乎完全一致的方式，起含义也非常相似，仅在访问标志和属性表集合的可选项中有所区别。\n\n![捕获.PNG](https://i.loli.net/2021/08/21/zahmFgG4QxWMVPX.png)\n\n方法的定义通过访问标志，名称索引，描述符索引来表达清楚，而方法中的代码，经过Javac编译器编译成字节码指令之后，存放在方法属性表集合中一个名为“Code”的属性里面。\n\n### 2.7 属性表集合\n\n属性表（attribute_info）在前面的讲解之中已经出现过数次，Class文件、字段表、方法表都可以携带自己的属性表集合，以描述某些场景专有的信息。\n\n属性表和class文件中其他部分的严格要求不同，属性表集合的限制稍微宽松一\n些，不再要求各个属性表具有严格顺序，并且《Java虚拟机规范》允许只要不与已有属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，Java虚拟机运行时会忽略掉它不认识的属性。为了能正确解析Class文件，《Java虚拟机规范》最初只预定义了9项所有Java虚拟机实现都应当能识别的属性，而在最新的《Java虚拟机规范》的Java SE 12版本中，预定义属性已经增加到29项。\n\n属性表的详情我开个新笔记来讲，它内容实在太多了。。\n","tags":["Java","JVM","深入理解Java虚拟机"],"categories":["技术笔记"]},{"title":"JVM垃圾回收","url":"//post/JVM垃圾回收.html","content":"\n# JVM垃圾回收\n\n## 1. 如何判断对象可以回收\n\n### 1.1 简要介绍：\n\n1. 引用计数法，如果某个对象被引用了，则他的计数加1，不再被引用了，则减1，计数为0则回收。弊端：循环引用，比如a和b相互引用，即使他们两个永远都不再被使用了，但是由于存在引用计数，所以永远都不会被回收。早期python虚拟机采用这种算法。\n\n2. 可达性分析算法：首先确定根对象（肯定不能被垃圾回收的对象），进行垃圾回收前对所有对象进行一次扫描，如果被根对象直接或间接应用的对象就不能被回收，如果没有被引用，那么就可以被回收。许多主流的商用程序语言（Java，C#等等）都采用这种算法进行\n\n   ![](https://img-blog.csdnimg.cn/a1dedc915d8b4c4a849f483359dcab00.PNG)\n\n### 1.2 可达性分析算法：\n\n\n\n* Java虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象\n\n* 扫描堆中的对象，看是否能够沿这GC Root对象为起点的引用链找到该对象，找不到，表示可以回收\n\n  #### 哪些对象可以作为GC Root对象\n\n SystemClass：由自举/系统类加载器加载的类。例如，rt.jar中所有诸如[java.util](https://www.baidu.com/s?wd=java.util&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao).*的类。\n JNILocal：原生代码中的本地变量，例如用户定义的JNI（Java本地接口，一般用来使Java代码和其他语言代码进行交互）代码或JVM内部代码。\n JNIGlobal：原生代码中的全局变量，例如用户定义的JNI代码或JVM内部代码。\n ThreadBlock：当前活跃的线程块中引用的对象。\n Thread：启动且未停止的线程。\n BusyMonitor：其wait()或notify()方法被调用，或被同步synchronized的对象。例如，通过调用synchronized(Object)或者进入其某个synchronized方法。静态方法对应类，非静态方法对应对象。\n JavaLocal：本地变量。例如，仍在线程的栈中的方法输入参数或本地创建的对象。\n NativeStack：（例如用户定义的JNI代码或JVM内部代码这样的）原生代码的入或出参数。通常发生在许多方法有原生部分，方法参数处理的对象成为GC根对象。例如，参数用于文件、网络I/O或反射。\n Finalizer：在队列中等待其finalizer运行的对象。\n Unfinalized：拥有finalize方法，但是还没有被终结且不在finalizer队列的对象。\n Unreachable：从其他根对象不可达的对象，但是被内存分析器标记为根对象。\n Unknown：没有根类型的对象。一些转储(dump)，例如IBM可移植对转储文件，没有根信息。对于这些转储，内存分析器解析程序将没有被其他根[对象引用](https://www.baidu.com/s?wd=对象引用&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)的对象标记为此类根对象。\n\n如果觉得上面的太复杂，那么简单来说，在Java语言中，可作为GC Roots的对象包括下面4种：\n\n* 虚拟机栈（栈帧中的本地变量表）中引用的对象。\n* 方法区中类静态属性引用的对象。\n* 方法区中常量引用的对象。\n* 本地方法栈中JNI（即一般说的Native方法）引用的对象。\n\n### 1.3 四种引用\n\n\n\n![](https://img-blog.csdnimg.cn/12f2c23e724f4dd0b0babbfaa8df9529.PNG)\n\n此图中，实线表示强引用，虚线表示其余引用 \n\n1. 强引用\n\n   **可以被GC Root对象直接或间接的找到，这种关系是强引用**，一般情况下，我们书写的代码基本上形成的引用关系都是强引用，**只有当所有强引用都断开时，对象才会被垃圾回收**，除此之外是绝不可能将其回收的。\n\n   ```java\n   Object o = new Object();   //  强引用\n   o = null; //断开强引用，被回收\n   ```\n\n2. 软引用\n\n   在Java中，软引用本质上是一种特殊设计的类，因此软引用实际上是被手动创建出来的，使用SoftReference类创建出来\n\n   ```java\n   String str = new String(\"abc\");                                     // 强引用\n   SoftReference<String> softRef = new SoftReference<String>(str);     // str被软引用\n   ```\n\n    **如果一个对象只具有软引用（通过SoftReference建立），则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些软引用对象的内存。**只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。\n\n   最具代表性的应用，如浏览器的后退按钮，点击后退要返回到上一个页面，如果重新加载，可能耗时较长，如果将其存储到内存中，则会造成浪费，这时可以使用软引用进行缓存，如果缓存资源充足，那么就将页面保存到缓存中，如果紧张，由于软引用的特性，页面缓存会被垃圾回收器回收。\n\n   可以配合**引用队列**使用，如果软引用它引用的对象被回收时，软引用本身（SoftReference实例）会被放到引用队列中，可以对其方便的进行进一步处理，比如释放SoftReference实例占用的内存。\n\n3. 弱引用\n\n   和软引用相似，弱引用对象也要手动创建出来，使用WeakReference建立\n\n   ```java\n   String str = new String(\"abc\");                                     //强引用\n   WeakReference<String> abcWeakRef = new WeakReference<String>(str);  //str被弱引用\n   ```\n\n   和软引用不同的是，**无论空间是否充足，只要垃圾回收器运行了，那么检测到弱引用，就会即刻将其回收**。但是垃圾回收器的线程优先级很低，不太经常运行，所以不会发生马上就会被清理掉的情况。如果这个对象是偶尔的使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么你应该用 WeakReference 来记住此对象。  \n\n   可以配合**引用队列**使用，如果软引用它引用的对象被回收时，软引用本身（WeakReference实例）会被放到引用队列中，可以对其方便的进行进一步处理，比如释放WeakReference实例占用的内存。\n\n4. 虚引用\n\n   “虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，**虚引用并不会决定对象的生命周期**。**如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。**\n\n   ```java\n   String str = new String(\"abc\");                                     //强引用\n   PhantomReference<String> ref = new PhantomReference<String>(str);  //str被虚引用\n   ```\n\n    虚引用主要用来跟踪对象被垃圾回收器回收的活动，同时，和软引用以及弱引用不同的是，**虚引用必须要和引用队列一起使用**，下面用一个例子来说明其作用和特征。\n\n   用Java中使用ByteBuffer分配直接内存的例子来说明一下，一个名叫Cleaner的虚引用关联了ByteBuffer实例对象，而我们借助ByteBuffer实例对象分配一些直接内存，当对ByteBuffer实例对象的强引用被断开后，ByteBuffer被回收了，但是其获取的直接内存不能被JVM垃圾回收器释放（因为它是底层的内存），这时候就要通过Cleaner这个虚引用，它进入引用队列，进行后续处理，通过这个虚引用获取到那块直接内存，然后将其释放。\n\n### 1.4 回收前的筛选判断\n\n即使在可达性分析算法中不可达的对象，也**并非一定会被垃圾回收**，要真正回收一个对象，至少要经历两次标记过程：\n\n1. 如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，**筛选的条件是此对象是否有必要执行finalize（）方法**。当对象没有覆盖finalize（）方法，或者finalize（）方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。\n2. 如果这个对象被判定为有必要执行finalize（）方法，那么这个对象将会放置在一个叫做**F-Queue**的队列之中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它。但**此线程不保证一定会等待finalize()方法运行结束**，这是为了防止发生死循环时其他队列中的对象无法执行finalize()。finalize（）方法是对象逃脱死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模的标记，**如果对象要在finalize（）中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可**，如果对象没能在finalize()中建立关联，那么它就会真的被回收了。\n\n## 2. 垃圾回收算法\n\n### 2.1 标记-清除算法\n\n这种算法是最基础的手机算法，言简意赅，算法分为“标记”和“清除”（Mark-Sweep）两个阶段：**首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象**。\n\n在JVM中，标记过程就是上文说的回收前的筛选判断（两次标记）。这种算法相当简单，但是仍然不经常使用它，它的主要不足有两个：**一个是效率问题，标记和清除两个过程的效率都不高；另一个是空间问题，标记清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作**。\n\n### 2.2 复制算法\n\n为了解决效率问题，一种称为“复制”（Copying）的收集算法出现了，**它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。**\n\n这样使得每次都是对整个半区进行内存回收，内存分配时也就不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效。只是这种算法的代价是将**内存缩小为了原来的一半**，未免太高了一点。\n\n### 2.3 标记-整理算法\n\n还有一种“标记-整理”（Mark-Compact）算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。\n\n在JVM中，主要使用的**复制算法**和**标记-整理算法**，他们分别针对不同生命周期的对象。\n\n## 3. 分代垃圾回收\n\n当前商业虚拟机的垃圾回收都采用**分代收集**的思想，它建立在两个分代假说之上：\n\n1. 弱分代假说（Weak Generational Hypothesis）：绝大多数对象都是朝生夕灭的。\n2. 强分代假说（Strong Generational Hypothesis）：熬过越多次垃圾收集过程的对象就越难以消亡。\n\n基于这两种假说，分代收集策略把Java堆划分出不同的区域，根据年龄（熬过垃圾回收的次数）将其分为**新生代和老年代**。\n\n新生代的区域存储刚被创建出来的对象，一般有研究表明，新生代中的对象98%是“朝生夕死”的，而在经历了n次垃圾回收后仍然存活的对象，则会被放到老年代，一般老年代中的对象生命周期都较长。\n\n虚拟机对不同的区域采用不同的垃圾回收算法，由于新生代大多数对象生命周期极短，因此采用改良后的复制算法来回收。\n\n不是按照1:1的比例来划分内存空间，而是**将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。**\n\nHotSpot虚拟机默认Eden和Survivor的大小比例是8:1，因此每次只会浪费10%的空间。但是我们不能断定，某次新生代的垃圾回收之后，10%的内存一定装得下存活的实例对象，因此当Survivor对象不够用时，需要依赖其他内存进行分配担保。\n\n**如果另外一块Survivor空间没有足够空间存放上一次新生代收集下来的存活对象时，这些对象将直接通过分配担保机制进入老年代。**\n\n对于老年代，虚拟机采用的垃圾回收算法是**标记-整理**算法，一方面老年代对象不多，使用这种算法效率略低可以接受，另一方面也可以清理出整块的内存，方便后续的内存分配。\n\n但是，分代收集并非只是简单划分内存区域那么容易，它至少存在一个明显的困难：**对象之间会存在跨代引用**。\n\n假如要现在进行一次只局限于新生代区域内的收集（Minor GC），但新生代中的对象是完全有可能被老年代所引用的，为了找出该区域中的存活对象，不得不在固定的GC Roots之外，再额外遍历整个老年代中所有对象来确保可达性分析结果的正确性，反过来也是一样。\n\n这种方案虽然理论上可行，但是会带来很大的性能负担，为了解决这个问题，第三条假说诞生了：跨代引用假说（Intergenerational Reference Hypothesis）：跨代引用相对于同代引用来说仅占极少数。\n\n依据这条假说，只需在新生代上建立一个全局的数据结构（该结构被称为“记忆集”，Remembered Set），这个结构把老年代划分成若干小块，标识出老年代的哪一块内存会存在跨代引用。此后当发生Minor GC时，**只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描**。虽然这种方法需要在对象改变引用关系（如将自己或者某个属性赋值）时维护记录数据的正确性，会增加一些运行时的开销，但比起收集时扫描整个老年代来说仍然是划算的。\n\n## 4. 垃圾收集器\n\n\n\n![](https://img-blog.csdnimg.cn/81b0bee23de84984be80643c396c9131.PNG)\n\n如图，这是JDK1.8前HotSpot虚拟机包含的所有收集器，如果两个收集器存在连线，就说明它们可以搭配使用，虚拟机所处的区域，则表示它是属于新生代收集器还是老年代收集器。\n\n### 4.1 Serial收集器\n\n它是最基本，发展历史最悠久的收集器，它是单线程收集器，在进行垃圾收集时必须暂停其他所有线程，直到它收集结束。\n\n看起来它效率很低，但实际上，**它依然是虚拟机运行在Client（客户端）模式下的默认新生代收集器**。\n\n它有着自己的优点：简单高效、没有线程交互开销，对于内存没有非常大的新生代已经足够使用了。\n\n### 4.2 ParNew收集器\n\n它是Serial收集器的多线程版本，除此之外它就没什么创新之处了，但**它却是不少运行在Server模式下的虚拟机中的新生代收集器（主要是JDK7之前，它甚至是Server模式下新生代的首选）**，其中有一个与性能无关但很重要的原因是，除了Serial收集器外，**目前只有它能与CMS收集器（划时代意义的垃圾收集器）配合工作**。\n\n但随着垃圾收集器技术的不断改进，更先进的G1收集器带着CMS继承者和替代者的光环登场。G1是一个面向全堆的收集器，不需要其他新生代收集器的配合工作，所以自JDK 9开始，ParNew加CMS收集器的组合就不再是官方推荐的服务端模式下的收集器解决方案了。官方希望它能完全被G1所取代。读者也可以理解为从此以后，**ParNew合并入CMS，成为它专门处理新生代的组成部分**。**ParNew可以说是HotSpot虚拟机中第一款退出历史舞台的垃圾收集器**。\n\n### 4.3 Parallel Scavenge收集器\n\nParallel Scavenge收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器，它的特点是，**此收集器的目标是达到一个可控制的吞吐量（CPU用于运行用户代码的时间与CPU总消耗时间的比值）**，因此它也常被称为“吞吐量优先”收集器。高吞吐量可以高效率的利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务。\n\nParallel Scavenge收集器还有一个特点，它有一个参数-XX：+UseAdaptiveSizePolicy值得关注。这是一个开关参数，**当这个参数打开之后，就不需要指定一些列细节参数，虚拟机会根据当前系统的运行情况收集性能监控信**\n**息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量，这种调节方式称为GC自适应的调节策略**。\n\n### 4.4 Serial Old收集器\n\n它是Serial收集器的老年代版本，同样是单线程收集器，使用“标记-整理”算法，这个收集器的主要意义也是在于给Client模式下的虚拟机使用，如果在Server模式下，那么它主要还有两大用途：一种用途是在JDK 1.5以及之前的版本中与Parallel Scavenge收集器搭配使用，另一种用途就是作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure（后文介绍）时使用。\n\n### 4.5 Paraller Old收集器\n\n它是Parallel Scavenge收集器的老年代版本，使用多线程和“标记-整理”算法。\n\n在它出现之前，Parallel Scavenge收集器一直处于比较尴尬的地位。Parallel Scavenge收集器只能和Serial Old收集器配合使用，但是由于Serial Old收集器在服务端应用性能上的拖累，使用了Parallel Scavenge收集器也未必能在整体应用上获得吞吐量最大化的效果，在老年代很大而且硬件比较高级的环境中，这种组合的吞吐量甚至还不一定又ParNew+CMS的组合给力。\n\n直到Parallel Old收集器出现后，“吞吐量优先”收集器终于有了比较名副其实的应用组合，**在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器**。\n\n### 4.6 CMS收集器\n\nCMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。相当一部分Java应用集中在互联网应用的服务端上，这类应用尤其注重服务的响应速度，CMS收集器就很符合这类应用的需求。\n\n从名字（包含“Mark Sweep”）上就可以看出，CMS收集器是基于“标记—清除”算法实现的，它的运作过程相对于前面几种收集器来说更复杂一些，整个过程分为4个步骤，包括：\n\n1. 初始标记（CMS initial mark）\n2. 并发标记（CMS concurrent mark）\n3. 重新标记（CMS remark）\n4. 并发清除（CMS concurrent sweep）\n\n其中，第一步和第三步仍然需要停止所有线程（Stop The World）。初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快，并发标记阶段就是进行GC RootsTracing的过程，而重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，这个阶段的停顿时间一般会比初始标记阶段稍长一些，但远比并发标记的时间短。\n\n而耗时最长的并发标记和并非清楚过程收集器线程都可以与用户线程一起工作，所有，从总体来说，CMS收集器的执行是与用户线程一起并发执行的，可以达到低停顿时间。\n\n虽然它相当优秀，但是它还远远达不到完美的程度，它又以下3个明显的缺点：\n\n1. **CMS收集器对CPU资源非常敏感。**当CPU不足4个时，CMS对用户程序的影响可能变得很大，甚至可能导致执行速度降低了50%。为了应付这种情况，虚拟机提供了一种称为“增量式并发收集器”（Incremental Concurrent Mark Sweep/i-CMS）的CMS收集器变种。就是在并发标记、清理的时候让GC线程、用户线程交替运行，尽量减少GC线程的独占资源的时间，这样整个垃圾收集的过程会更长，但对用户程序的影响就会显得少一些，也就是速度下降没有那么明显。实际上，他的效果很一般，当前版本不再提倡用户使用。\n2. **CMS收集器无法处理浮动垃圾（Floating Garbage），可能现“Concurrent Mode Failure”失败而导致另一次Full GC的产生。**由于在并发清理解答，用户线程仍在运行，就会产生新垃圾，这些垃圾必须得下一次GC再清理，这种垃圾就被称为“浮动垃圾”。CMS收集器需要预留一部分空间提供并发时其他线程使用，要是CMS运行期间预留的内存无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败，这时虚拟机将启动后备预案：临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就很长了。\n3. **由于采用了“标记-清除“算法，收集结束时会有大量空间碎片产生。**，CMS收集器提供了一个-XX：+UseCMSCompactAtFullCollection开关参数（默认就是开启的），用于在CMS收集器顶不住要进行FullGC时开启内存碎片的合并整理过程，内存整理的过程是无法并发的，空间碎片问题没有了，但停顿时间不得不变长。\n\n### 4.7 G1收集器\n\nG1（Garbage-First）收集器是当今收集器技术发展的最前沿成果之一，G1是一款面向服务端应用的垃圾收集器。HotSpot开发团队赋予它的使命是（在比较长期的）未来可以替换掉JDK 1.5中发布的CMS收集器。和其他收集器相比，它具备如下特点：\n\n1. 并行与并发\n2. 分代收集\n3. 空间整合，整体上来看是基于**标记-整理**算法实现，局部看是基于**复制**算法实现\n4. 可预测的停顿\n\n使用G1收集器时，Java堆的内存布局就与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留有新生代和老年代的概念，但新生代和老年代不再是物理隔离的了，它们都是一部分Region（不需要连续）的集合。\n\nG1收集器的实现较为复杂，有空专门写一篇笔记来介绍G1收集器。\n\n除了这7种收集器之外，还有其他更先进，更复杂的收集器，如ZGC，Shenandoah收集器等，本文并未描述（因为真的很复杂）。\n\n### 4.8 如何选择垃圾收集器\n\n这个问题的答案主要受三个方向影响：\n\n1. 应用程序的主要关注点是什么？\n2. 运行应用的基础设施如何？\n3. 使用JDK的发行商是什么？\n\n## 5. 内存分配与回收策略\n\n### 5.1 两种回收\n\n**新生代GC**（Minor GC）：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。\n\n**老年代GC**（Major GC/Full GC）：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。Major GC的速度一般会比Minor GC慢10倍以上。\n\n### 5.2 对象优先在Eden区分配\n\n大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。\n\n虚拟机提供了-XX：+PrintGCDetails这个收集器日志参数，告诉虚拟机在发生垃圾收集行为时打印内存回收日志，并且在进程退出的时候输出当前的内存各区域分配情况。\n\n### 5.3 大对象直接进入老年代\n\n所谓的大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串以及数组。\n\n大对象对虚拟机的内存分配来说就是一个坏消息（替Java虚拟机抱怨一句，比遇到一个大对象更加坏的消息就是遇到一群“朝生夕灭”的“短命大对象”，写程序的时候应当避免）\n\n经常出现大对象容易导致内存还有不少空间时就提前触发垃圾收集以获取足够的连续空间来“安置”它们。\n\n虚拟机提供了一个**-XX：PretenureSizeThreshold**参数，令大于这个设置值的对象直接在老年代分配。目的是为了防止Eden和两个survivor区之间发生大量内存复制。\n\n### 5.4 长期存活的对象将进入老年代\n\n虚拟机给每个对象定义了一个对象年龄（Age）计数器。如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1。\n\n对象在Survivor区中每“熬过”一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程度（默认为15岁），就将会被晋升到老年代中。\n\n对象晋升老年代的年龄阈值，可以通过参数**-XX：MaxTenuringThreshold**设置\n\n### 5.5 动态对象年龄判定\n\n为了能更好地适应不同程序的内存状况，虚拟机并不是永远地要求对象的年龄必须达到了MaxTenuringThreshold才能晋升老年代。\n\n如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到MaxTenuringThreshold中要求的年龄。\n\n### 5.6 空间分配担保\n\n前面提到过，新生代使用复制收集算法，但为了内存利用率，只使用其中一个Survivor空间来作为轮换备份，因此当出现大量对在MinorGC后仍然存活的情况（最极端的情况就是内存回收后新生代中所有对象都存活），就需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代。\n\n在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那么Minor GC可以确保是安全的。\n\n如果不成立，则虚拟机会查看HandlePromotionFailure设置值是否允许担保失败。如果允许，那么会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者HandlePromotionFailure设置不允许冒险，那这时也要改为进行一次Full GC。\n\n","tags":["Java","JVM","深入理解Java虚拟机","源码分析"],"categories":["技术笔记"]},{"title":"HotSpot虚拟机对象探秘","url":"//post/HotSpot虚拟机对象探秘.html","content":"\n# HotSpot虚拟机对象探秘\n\n## 1. 对象的创建\n\n### 1.1 类加载检查\n\n虚拟机遇到new之后，首先会去常量池中找这个类的**符号引用**，并检查这个符号引用代表的类是否已经被加载、解析和初始化过，如果找到了，就可以根据已有的信息划分空间、分配内存、初始化等等；**如果没找到，那必须先执行相应的类加载过程**，类加载过程以后的笔记在详细说明。\n\n### 1.2 内存分配\n\n类加载检查通过之后，虚拟机将为新生对象分配内存，所需内存大小在类加载完成后就已经完全确定了，**虚拟机要做的只是把一块确定大小的内存从Java堆中划分出来**，怎么划分又要分两种情况看了。\n\n1. **假设Java堆中内存时绝对规整的**，所有用过的内存都放在一边，空闲的内存放在另一边，那中间再放一个指针作为分界点指示器，那分配内存只要移动指针就完事了，这种分配方式被称为**指针碰撞**。\n2. **假设内存并不是规整的**，使用的内存和空闲的内存相互交错，这时候**虚拟机得维护一个列表**，记录那些内存块是空闲的，分配时就从列表里找到一个够大的空间分配给实例，并更新列表，这种分配方式被称为**空闲列表**。\n\n选择哪种方式由**Java堆是否规整来决定**，而Java堆是否规整又由**所采用的垃圾收集器是否带有压缩整理功能决定**。\n\n除了如何划分可用空间外，还有另外需要考虑的问题**线程安全**问题，可能出现正在给对象A分配内存，指针还没来得及修改，对象B又同时使用了原来的指针来分配内存的情况。解决这个问题有两种方案，**一种是对分配内存空间的动作进行同步处理，另一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为本地线程分配缓冲**（Thread Local Allocation Buffer,TLAB）\n\n### 1.3 初始化\n\n内存分配完成后，**虚拟机需要将分配到的内存空间都初始化为零值**，**如果使用了TLAB，这一工作过程也可以提前至TLAB分配时进行**，这一步保证了对象实例字段在Java代码中不初始化就可以直接使用，这也是Java默认初始值的原理。\n\n### 1.4 进行必要的设置\n\n虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头（Object Header）之中。根据虚拟机当前的运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。\n\n### 1.5 <init>方法的执行\n\n虚拟机的眼中，新对象已经诞生，但是从Java程序的角度，还差最后一步，执行new指令之后会接着执行＜init＞方法，把对象按照程序员的意愿进行初始化，这样一个真正程序可用的对象才算完全产生出来。\n\n## 2. 对象的内存布局\n\n在HotSpot中，对象在堆中的存储布局可以分为三个部分：**对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）**。\n\n### 2.1 对象头\n\n对象头部分包括两类信息，**第一类是用于存储对象自身的运行时数据**，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。\n\n这部分数据的长度在32位和64位的虚拟机（未开启压缩指针）中分别为32个比特和64个比特，官方称其为“Mark Word”，考虑到空间效率，它为设计为一个有着动态定义的数据结构，以便在极小的空间内存储尽量多的数据，根据对象的状态复用自己的存储空间。例如在32位的HotSpot虚拟机中，如对象未被同步锁锁定的状态\n下，Mark Word的32个比特存储空间中的25个比特用于存储对象哈希码，4个比特用于存储对象分代年龄，2个比特用于存储锁标志位，1个比特固定为0。\n\n**第二类信息是类型指针，即对象指向它的类型元数据的指针，JVM通过它来确定该对象是哪个类的实例**，但并非所有JVM实现都必须保存类型指针。如果对象是一个数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是如果数组的长度是不确定的，将无法通过元数据中的信息推断出数组的大小。\n\n### 2.2 实例数据\n\n**这部分是对象真正存储的有效信息，即我们定义的各种类型的字段，父类继承的和子类定义的字段都会被记录起来。**\n\n这部分的存储顺序会受到虚拟机分配策略参数（-XX：FieldsAllocationStyle参数）和字段在Java源码中定义顺序的影响。HotSpot虚拟机默认的分配顺序为longs/doubles、ints、shorts/chars、bytes/booleans、oops（OrdinaryObject Pointers，OOPs）。\n\n从默认的分配策略可以看出，**相同宽度的字段总放在一起存放**，在满足这个前提条件的情况下，在父类中定义的变量会出现在子类之前。如果HotSpot虚拟机的\n+XX：CompactFields参数值为true（默认就为true），那子类之中较窄的变量也允许插入父类变量的空隙之中，以节省出一点点空间。\n\n### 2.3 对齐填充\n\n第三部分是对齐填充，这并不是必然存在的，也没有特别的含义，**它仅仅起着占位符的作用**。由于HotSpot虚拟机的自动内存管理系统要求对象起始地址必须是8字节的整数倍，因此，如果对象实例数据部分没有对齐的话，就需要通过对齐填充来补全。\n\n## 3. 对象的访问定位\n\n在Java中，我们要使用一个对象，会通过栈上的reference（引用）来操作堆中的具体实例对象，在JVM规范中并没有定义引用应该通过什么方式实现，因此对象的访问方式也是因机而异，主流的方式有两种：**使用句柄，直接指针**。\n\n### 3.1 使用句柄访问\n\n如果使用句柄访问的话，Java堆中将可能会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息。其结构如图所示\n\n![](https://i.loli.net/2021/08/14/xIQegjKZid8sabE.png)\n\n使用句柄访问的最大好处是reference中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要被修改。\n\n### 3.2 使用直接指针访问\n\n·如果使用直接指针访问的话，Java堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销，如图所示\n\n![](https://i.loli.net/2021/08/14/R7vA2Vz5k3yfWrj.png)\n\n使用直接指针来访问最大的好处就是速度更快，它节省了一次指针定位的时间开销，由于对象访问在Java中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本，就本书讨论的主要虚拟机HotSpot而言，它主要使用第二种方式进行对象访问。\n\n","tags":["Java","JVM","深入理解Java虚拟机"],"categories":["技术笔记"]},{"title":"带图形界面的贪吃蛇","url":"//post/带图形界面的贪吃蛇.html","content":"\n比较早的代码了，属于典型的为了面向对象而面向对象的代码。。。\n运行环境VS2019，图形由easyx库实现：https://easyx.cn/。\n\n已经在注释中写出了出现的eaysx库函数的基本作用，注释前带“*”的是easyx的库函数，详情请查阅文档https://docs.easyx.cn/zh-cn/intro\n\n完整的源码见最下方\n***\n\n# 成品\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200601212808270.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhdzk2eA==,size_16,color_FFFFFF,t_70)\n# 基本游戏框架搭建\nmain函数：\n\n```cpp\n#include \"Snake.h\"\nusing namespace std;\nint main()\n{\n\tSnake my_snake;\n\tmy_snake.startup();\n\twhile (1)\n\t{\n\t\tmy_snake.clean();\n\t\tmy_snake.UpdateWithoutInput();\n\t\tmy_snake.UpdateWithInput();\n\t\tmy_snake.show();\n\t}\n\tmy_snake.gameover();\n\treturn 0;\n}\n```\n第一行通过无参的构造函数初始化数据，包括界面宽度等等\nstartup开始生成画面\n进入循环，包括：\n- 清除旧画面\n- 更新无需用户输入的数据\n- 更新需要用户输入的数据\n- 根据更新后的数据生成新画面，从而达到动画效果\n\n（退出游戏的部分在UpdateWithoutInput中。）\n\n# Snake类\n```cpp\n#pragma once\n#include<graphics.h>\n#include<Windows.h>\n#include<conio.h>\n#include<ctime>\n#include<vector>\n#include<cstdlib>\nusing namespace std;\nclass Snake\n{\npublic:\n\tSnake();\n\tbool check();//检测生成的食物是否和蛇重合了\n\tvoid SnakeMove();\n\tvoid startup();\n\tvoid clean();\n\tvoid show();\n\tvoid UpdateWithoutInput();\n\tvoid UpdateWithInput();\n\tvoid gameover();\nprivate:\n\tint High;\n\tint Width;\n\tint Background;\n\tint dir;//方向\n\tint score;\n\tint speed;//画面更新速度，动态难度\n\tint food_x, food_y;\n\tvector<int> snake_x, snake_y; //蛇的每一节的坐标\n};\n```\n\n食物只出现一次，所以直接用int类型作为坐标\n蛇的长度理论上来说是可以无限增长的，因此使用vector来保存蛇的每一节的坐标。\n\n# 初始化\n初始化的函数包括Snake的无参构造函数和startup函数：\n```cpp\nSnake::Snake() \n{\n\tHigh = 720;\n\tWidth = 1280;\n\tBackground = LIGHTGRAY;//*easyx的颜色宏\n\tdir = 5;//方向参考1235键位，类似wasd\n\tscore = 0;\n\tspeed = 300;\n\tfood_x = rand() % (Width-40) + 21; //限定食物出现在屏幕范围内\n\tfood_y = rand() % (High-40) + 21;\n\tsnake_x.resize(4), snake_y.resize(4);//蛇的初始长度为4\n}\nvoid Snake::startup() \n{\n\tsrand((unsigned int)(time)(NULL));\n\tinitgraph(Width, High);//*easyx初始化函数，以参数生成相应分辨率的窗口\n\tsetbkcolor(Background);//*设置背景色\n\tcleardevice();//*清空原有背景\n\t\n\tfor (int i = 0; i < 4; i++)//初始化蛇的坐标数据\n\t{\n\t\tsnake_x[i] = Width / 2 - 40 * i;\n\t\tsnake_y[i] = High / 2;\n\t}\n\t\n\tBeginBatchDraw();//*\n\t//这个函数用于开始批量绘图。\n\t//执行后，任何绘图操作都将暂时不输出到绘图窗口上，\n\t//直到执行 FlushBatchDraw 或 EndBatchDraw 才将之前的绘图输出。\n\t//主要的用处是保证刷新画面不发生屏幕闪烁\n}\n```\n\n# 动画效果\n```cpp\nvoid Snake::clean() \n{\n\tsetlinecolor(Background);//*设置线的颜色\n\tsetfillcolor(Background);//*设置填充色\n\tfor (unsigned i = 0; i < snake_x.size(); i++)\n\t{\n\t\tfillcircle(snake_x[i], snake_y[i], 20);//*画圆\n\t}\n}\n\nvoid Snake::show() \n{\n\tfor (unsigned i = 0; i < snake_x.size(); i++) \n\t{\n\t\tif (i == 0) \n\t\t{\n\t\t\tsetfillcolor(LIGHTMAGENTA);\n\t\t\tfillcircle(snake_x[i], snake_y[i], 20);\n\t\t}\n\t\telse \n\t\t{\n\t\t\tsetfillcolor(LIGHTRED);\n\t\t\tfillcircle(snake_x[i], snake_y[i], 20);\n\t\t}\n\t}\n\t\n\tFlushBatchDraw();//*与BeginBatchDraw配合使用\n\tsetfillcolor(YELLOW);\n\t//*以下均为字体设置与字体显示，用于显示分数\n\tTCHAR s[5];\n\tfillcircle(food_x, food_y, 20);\n\tsettextstyle(60, 0, _T(\"宋体\"));\n\tsettextcolor(RGB(25, 32, 94));\n\t_stprintf_s(s, 5, _T(\"%d\"), score);\n\touttextxy(430, 620, _T(\"Score:\"));\n\touttextxy(640, 620, s);\n\n\tSleep(speed);//用sleep控制速度，speed越小蛇动的越快\n}\n```\n\n动画效果通过clean和show配合。\n\nclean绘制背景色的圆，达到擦除的效果，然后show再绘制新的圆，达成动画效果。\n\n# 蛇的移动\n这个地方算是核心了\n```cpp\nvoid Snake::SnakeMove() \n{\n\tsrand((unsigned int)(time)(NULL));\n\t//如果蛇头的坐标和食物的坐标有一定程度的重合，那么在蛇尾增加新的坐标\n\tif (food_x >= snake_x[0] - 20 &&\n\t\tfood_x <= snake_x[0] + 20 &&\n\t\tfood_y >= snake_y[0] - 20 &&\n\t\tfood_y <= snake_y[0] + 20) \n\t{\n\t\tif (dir == 1) \n\t\t{\n\t\t\tsnake_x.push_back(snake_x[snake_x.size() - 1] + 40);\n\t\t\tsnake_y.push_back(snake_y[snake_y.size() - 1]);\n\t\t}\n\t\telse if (dir == 2)\n\t\t{\n\t\t\tsnake_x.push_back(snake_x[snake_x.size() - 1]);\n\t\t\tsnake_y.push_back(snake_y[snake_y.size() - 1] - 40);\n\t\t}\n\t\telse if (dir == 3) \n\t\t{\n\t\t\tsnake_x.push_back(snake_x[snake_x.size() - 1] - 40);\n\t\t\tsnake_y.push_back(snake_y[snake_y.size() - 1]);\n\t\t}\n\t\telse if (dir == 5) \n\t\t{\n\t\t\tsnake_x.push_back(snake_x[snake_x.size() - 1]);\n\t\t\tsnake_y.push_back(snake_y[snake_y.size() - 1] + 40);\n\t\t}\n\t\t\n\t\tscore++;//加分\n\t\tif (speed >= 150) //调整速度\n\t\t{\n\t\t\tspeed -= 5 * score;\n\t\t}\n\t\t//擦除旧食物，更新食物的坐标\n\t\tsetlinecolor(Background)；\n\t\tsetfillcolor(Background);\n\t\tfillcircle(food_x, food_y, 20);\n\t\tfood_x = rand() % (Width - 40) + 21;\n\t\tfood_y = rand() % (High - 40) + 21;\n\t\t//如果生成的食物坐标和蛇重合了，再更新食物的坐标,check是检测是否重合的函数。\n\t\twhile (!check()) \n\t\t{\n\t\t\tfood_x = rand() % (Width - 40) + 21;\n\t\t\tfood_y = rand() % (High - 40) + 21;\n\t\t}\n\t}\n\t//蛇移动，通过从后往前迭代更新坐标，形成移动\n\tfor (int i = snake_x.size() - 1; i > 0; i--)\n\t{\n\t\tsnake_x[i] = snake_x[i - 1];\n\t\tsnake_y[i] = snake_y[i - 1];\n\t}\n\t//头节点根据方向特殊处理\n\tif (dir == 1) \n\t{\n\t\tsnake_x[0] = snake_x[1] - 40;\n\t\tsnake_y[0] = snake_y[1];\n\t}\n\telse if (dir == 2) \n\t{\n\t\tsnake_x[0] = snake_x[1];\n\t\tsnake_y[0] = snake_y[1] + 40;\n\t}\n\telse if (dir == 3) \n\t{\n\t\tsnake_x[0] = snake_x[1] + 40;\n\t\tsnake_y[0] = snake_y[1];\n\t}\n\telse if (dir == 5) \n\t{\n\t\tsnake_x[0] = snake_x[1];\n\t\tsnake_y[0] = snake_y[1] - 40;\n\t}\n\t//检测是否撞墙或者咬到自己了\n\tfor (unsigned i = 1; i < snake_x.size(); i++)\n\t{\n\t\tif ((snake_x[0] >= snake_x[i] - 20 &&\n\t\t\tsnake_x[0] <= snake_x[i] + 20 &&\n\t\t\tsnake_y[0] >= snake_y[i] - 20 &&\n\t\t\tsnake_y[0] <= snake_y[i] + 20) ||\n\t\t\t((snake_x[0] - 20 <= 0) ||\n\t\t\t(snake_x[0] + 20 >= 1280) ||\n\t\t\t\t(snake_y[0] - 20 <= 0) ||\n\t\t\t\t(snake_y[0] + 20 >= 720))) \n\t\t{//停留三秒退出游戏\n\t\t\tSleep(3000);\n\t\t\texit(0);\n\t\t}\n\t}\n}\n\nbool Snake::check() \n{\n\tfor (int i = 0; i < snake_x.size(); i++) \n\t{\n\t\tif ((food_x >= snake_x[i] - 40 && food_x <= snake_x[i] + 40) &&\n\t\t\t(food_y >= snake_y[i] - 40 && food_y <= snake_y[i] + 40))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\n```\n# 数据更新\n```cpp\nvoid Snake::UpdateWithoutInput() \n{\n\tSnakeMove();\n}\nvoid Snake::UpdateWithInput()\n{\n\tchar input;\n\tif (_kbhit()) //kbhit检测是否敲击键盘\n\t{//用getch获取用户输入，然后作条件判断来确定蛇如何移动\n\t\tinput = _getch();\n\t\tif ((input == 'a' || input == '1') && dir != 3) //无法向当前方向的方向移动，下同\n\t\t{\n\t\t\tdir = 1;\n\t\t\tSnakeMove();\n\t\t}\n\t\telse if ((input == 's' || input == '2') && dir != 5)\n\t\t{\n\t\t\tdir = 2;\n\t\t\tSnakeMove();\n\t\t}\n\t\telse if ((input == 'w' || input == '5') && dir != 2) \n\t\t{\n\t\t\tdir = 5;\n\t\t\tSnakeMove();\n\t\t}\n\t\telse if ((input == 'd' || input == '3') && dir != 1)\n\t\t{\n\t\t\tdir = 3;\n\t\t\tSnakeMove();\n\t\t}\n\t\tif (input == 27) //如果按esc就暂停游戏，esc的ASCII码是27\n\t\t{\n\t\t\tinput = 'n';\n\t\t\twhile (1) \n\t\t\t{\n\t\t\t\tinput = _getch();\n\t\t\t\tif (input == 27)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\n```\n\n# 结束游戏\n```cpp\nvoid Snake::gameover() \n{\n\tEndBatchDraw();//*配合另外两个BatchDraw\n\tclosegraph();//*关闭窗口\n}\n```\n\n# 源码\n```cpp\n#include<graphics.h>\n#include<Windows.h>\n#include<conio.h>\n#include<ctime>\n#include<vector>\n#include<cstdlib>\nusing namespace std;\nclass Snake\n{\npublic:\n\tSnake();\n\tbool check();//检测生成的食物是否和蛇重合了\n\tvoid SnakeMove();\n\tvoid startup();\n\tvoid clean();\n\tvoid show();\n\tvoid UpdateWithoutInput();\n\tvoid UpdateWithInput();\n\tvoid gameover();\nprivate:\n\tint High;\n\tint Width;\n\tint Background;\n\tint dir;//方向\n\tint score;\n\tint speed;//画面更新速度，动态难度\n\tint food_x, food_y;\n\tvector<int> snake_x, snake_y; //蛇的每一节的坐标\n};\nSnake::Snake()\n{\n\tHigh = 720;\n\tWidth = 1280;\n\tBackground = LIGHTGRAY;//easyx的颜色宏\n\tdir = 5;//方向参考1235键位，类似wasd\n\tscore = 0;\n\tspeed = 300;\n\tfood_x = rand() % (Width - 40) + 21; //限定食物出现在屏幕范围内\n\tfood_y = rand() % (High - 40) + 21;\n\tsnake_x.resize(4), snake_y.resize(4);//蛇的初始长度为4\n}\nbool Snake::check()\n{\n\tfor (int i = 0; i < snake_x.size(); i++)\n\t{\n\t\tif ((food_x >= snake_x[i] - 40 && food_x <= snake_x[i] + 40) &&\n\t\t\t(food_y >= snake_y[i] - 40 && food_y <= snake_y[i] + 40))\n\t\t\treturn false;\n\t}\n\treturn true;\n}\nvoid Snake::SnakeMove()\n{\n\tsrand((unsigned int)(time)(NULL));\n\t//如果蛇头的坐标和食物的坐标有一定程度的重合，那么在蛇尾增加新的坐标\n\tif (food_x >= snake_x[0] - 20 &&\n\t\tfood_x <= snake_x[0] + 20 &&\n\t\tfood_y >= snake_y[0] - 20 &&\n\t\tfood_y <= snake_y[0] + 20)\n\t{\n\t\tif (dir == 1)\n\t\t{\n\t\t\tsnake_x.push_back(snake_x[snake_x.size() - 1] + 40);\n\t\t\tsnake_y.push_back(snake_y[snake_y.size() - 1]);\n\t\t}\n\t\telse if (dir == 2)\n\t\t{\n\t\t\tsnake_x.push_back(snake_x[snake_x.size() - 1]);\n\t\t\tsnake_y.push_back(snake_y[snake_y.size() - 1] - 40);\n\t\t}\n\t\telse if (dir == 3)\n\t\t{\n\t\t\tsnake_x.push_back(snake_x[snake_x.size() - 1] - 40);\n\t\t\tsnake_y.push_back(snake_y[snake_y.size() - 1]);\n\t\t}\n\t\telse if (dir == 5)\n\t\t{\n\t\t\tsnake_x.push_back(snake_x[snake_x.size() - 1]);\n\t\t\tsnake_y.push_back(snake_y[snake_y.size() - 1] + 40);\n\t\t}\n\n\t\tscore++;//加分\n\t\tif (speed >= 150) //调整速度\n\t\t{\n\t\t\tspeed -= 5 * score;\n\t\t}\n\t\t//擦除旧食物，更新食物的坐标\n\t\tsetlinecolor(Background);\n\t\t\tsetfillcolor(Background);\n\t\tfillcircle(food_x, food_y, 20);\n\t\tfood_x = rand() % (Width - 40) + 21;\n\t\tfood_y = rand() % (High - 40) + 21;\n\t\t//如果生成的食物坐标和蛇重合了，再更新食物的坐标,check是检测是否重合的函数。\n\t\twhile (!check())\n\t\t{\n\t\t\tfood_x = rand() % (Width - 40) + 21;\n\t\t\tfood_y = rand() % (High - 40) + 21;\n\t\t}\n\t}\n\t//蛇移动，通过从后往前迭代更新坐标，形成移动\n\tfor (int i = snake_x.size() - 1; i > 0; i--)\n\t{\n\t\tsnake_x[i] = snake_x[i - 1];\n\t\tsnake_y[i] = snake_y[i - 1];\n\t}\n\t//头节点根据方向特殊处理\n\tif (dir == 1)\n\t{\n\t\tsnake_x[0] = snake_x[1] - 40;\n\t\tsnake_y[0] = snake_y[1];\n\t}\n\telse if (dir == 2)\n\t{\n\t\tsnake_x[0] = snake_x[1];\n\t\tsnake_y[0] = snake_y[1] + 40;\n\t}\n\telse if (dir == 3)\n\t{\n\t\tsnake_x[0] = snake_x[1] + 40;\n\t\tsnake_y[0] = snake_y[1];\n\t}\n\telse if (dir == 5)\n\t{\n\t\tsnake_x[0] = snake_x[1];\n\t\tsnake_y[0] = snake_y[1] - 40;\n\t}\n\t//检测是否撞墙或者咬到自己了\n\tfor (unsigned i = 1; i < snake_x.size(); i++)\n\t{\n\t\tif ((snake_x[0] >= snake_x[i] - 20 &&\n\t\t\tsnake_x[0] <= snake_x[i] + 20 &&\n\t\t\tsnake_y[0] >= snake_y[i] - 20 &&\n\t\t\tsnake_y[0] <= snake_y[i] + 20) ||\n\t\t\t((snake_x[0] - 20 <= 0) ||\n\t\t\t\t(snake_x[0] + 20 >= 1280) ||\n\t\t\t\t(snake_y[0] - 20 <= 0) ||\n\t\t\t\t(snake_y[0] + 20 >= 720)))\n\t\t{//停留三秒退出游戏\n\t\t\tSleep(3000);\n\t\t\texit(0);\n\t\t}\n\t}\n}\nvoid Snake::startup()\n{\n\tsrand((unsigned int)(time)(NULL));\n\tinitgraph(Width, High);\n\tsetbkcolor(Background);\n\tcleardevice();\n\tfor (int i = 0; i < 4; i++)\n\t{\n\t\tsnake_x[i] = Width / 2 - 40 * i;\n\t\tsnake_y[i] = High / 2;\n\t}\n\tBeginBatchDraw();\n}\nvoid Snake::clean()\n{\n\tsetlinecolor(Background);//设置线的颜色\n\tsetfillcolor(Background);//设置填充色\n\tfor (unsigned i = 0; i < snake_x.size(); i++)\n\t{\n\t\tfillcircle(snake_x[i], snake_y[i], 20);//画圆\n\t}\n}\nvoid Snake::show()\n{\n\tfor (unsigned i = 0; i < snake_x.size(); i++)\n\t{\n\t\tif (i == 0)\n\t\t{\n\t\t\tsetfillcolor(LIGHTMAGENTA);\n\t\t\tfillcircle(snake_x[i], snake_y[i], 20);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsetfillcolor(LIGHTRED);\n\t\t\tfillcircle(snake_x[i], snake_y[i], 20);\n\t\t}\n\t}\n\n\tFlushBatchDraw();//与BeginBatchDraw配合使用\n\tsetfillcolor(YELLOW);\n\t//以下均为字体设置与字体显示，用于显示分数\n\tTCHAR s[5];\n\tfillcircle(food_x, food_y, 20);\n\tsettextstyle(60, 0, _T(\"宋体\"));\n\tsettextcolor(RGB(25, 32, 94));\n\t_stprintf_s(s, 5, _T(\"%d\"), score);\n\touttextxy(430, 620, _T(\"Score:\"));\n\touttextxy(640, 620, s);\n\n\tSleep(speed);//用sleep控制速度，speed越小蛇动的越快\n}\nvoid Snake::UpdateWithoutInput()\n{\n\tSnakeMove();\n}\nvoid Snake::UpdateWithInput()\n{\n\tchar input;\n\tif (_kbhit())\n\t{\n\t\tinput = _getch();\n\t\tif ((input == 'a' || input == '1') && dir != 3)\n\t\t{\n\t\t\tdir = 1;\n\t\t\tSnakeMove();\n\t\t}\n\t\telse if ((input == 's' || input == '2') && dir != 5)\n\t\t{\n\t\t\tdir = 2;\n\t\t\tSnakeMove();\n\t\t}\n\t\telse if ((input == 'w' || input == '5') && dir != 2)\n\t\t{\n\t\t\tdir = 5;\n\t\t\tSnakeMove();\n\t\t}\n\t\telse if ((input == 'd' || input == '3') && dir != 1)\n\t\t{\n\t\t\tdir = 3;\n\t\t\tSnakeMove();\n\t\t}\n\t\tif (input == 27)\n\t\t{\n\t\t\tinput = 'n';\n\t\t\twhile (1)\n\t\t\t{\n\t\t\t\tinput = _getch();\n\t\t\t\tif (input == 27)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n}\nvoid Snake::gameover()\n{\n\tEndBatchDraw();\n\tclosegraph();\n}\n\nint main()\n{\n\tSnake my_snake;\n\tmy_snake.startup();\n\twhile (1)\n\t{\n\t\tmy_snake.clean();\n\t\tmy_snake.UpdateWithoutInput();\n\t\tmy_snake.UpdateWithInput();\n\t\tmy_snake.show();\n\t}\n\tmy_snake.gameover();\n\treturn 0;\n}\n```\n","tags":["小游戏","C++"],"categories":["技术分享"]},{"title":"JVM内存结构","url":"//post/JVM内存结构.html","content":"\n本篇笔记不定期更新\n## 内存结构图\n先上图\n![在这里插入图片描述](https://img-blog.csdnimg.cn/bf995bbfbfcc4629ab3ef9f83c78d099.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhdzk2eA==,size_16,color_FFFFFF,t_70#pic_center)\n这张图差不多就把JVM的内存结构以及和class源文件，JVM执行引擎，以及操作系统自带的本地方法接口之间的关系囊括进去了。\n\n下面我们就JVM内存结构的几个组成部分来逐一简单介绍一下\n\n## 1. 程序计数器\n\n### 1.1 定义\n\nProgram Counter Register 程序计数器（寄存器）\n\n### 1.2 作用\n\n1. 在执行当前指令时，记住下一条JVM指令的执行地址，所以PCR也被称为寄存器，在物理上通过CPU寄存器实现\n2. 在多线程程序中起到一个记录上下文的作用，方便切换线程时可以继续运行\n3. 字节码解释器通过改变PCR的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要PCR来完成\n4. 如果线程正在执行Java方法，那么PCR记录的市正在执行的虚拟机字节码指令的地址，如果正在执行的是Native方法，这个计数器值则为空（Undefined）\n\n### 1.3 特点\n\n* Java支持多线程，而PCR是线程私有的，每个线程都有自己的PCR\n* 不会存在内存溢出此内存区域，是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域\n* 生命周期与线程相同\n\n## 2. 虚拟机栈\n\n栈--线程运行需要的内存空间，由栈帧组成，栈帧看为栈内的元素\n\n栈帧--每个方法运行时所需要的内存，参数，局部变量，返回地址等等····\n\n当调用某个方法时，会给栈帧分配内存，并将这个栈帧压入栈中，运行完毕后，会释放内存，也就是弹出栈帧。\n\n当方法调用方法时，就会压入多个栈帧\n\n### 2.1 定义\n\nJava Virtual Machine Stacks\n\n* 每个线程运行时需要的内存，称为虚拟机栈\n* 每个栈由多个栈帧（Frame）祖传，对应着每次方法调用时所占用的内存，一般来说是局部变量\n* 每个线程只能由一个活动栈帧，对应着当前正在执行的那个方法，也就是目前栈顶的那个栈帧\n* 线程私有的，生命周期与线程相同\n* 栈中有局部变量表，存放了编译期可知的各种基本数据类型、对象引用（reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。\n\n问题辨析\n\n1. 垃圾回收是否涉及栈内存？不涉及，栈内存只和方法有关，方法运行完毕后栈帧出栈，内存自动回收。\n\n2. 栈内存分配越大越好吗？不是，内存分配得越大，线程就越少，因为物理内存是确定的，内存分配的越大，能更多次的进行方法递归。一般来说，默认的分配内存已经够用了。\n\n3. 方法内的局部变量是否线程安全？\n\n   是的，因为每个线程只对应一个虚拟机栈，和其他方法的线程是互不干扰的，本质上操作的局部变量完全没有关系，因此是线程安全的。但如果不是局部变量，而是静态变量，或者是方法参数、或者是局部变量作为返回值返回了，那么就线程不安全，因为这时不同线程操纵的变量是同一个变量了。\n\n   简单来说，如果方法内局部变量没有逃离方法的作用范围，那么他就是线程安全的\n\n### 2.2 栈内存溢出\n\n   -Xss 栈内存分配大小命令\n\n   StackOverflowError\n\n   * 栈帧过多导致栈内存溢出，如递归调用但没设置中止条件，或是出现了循环引用问题\n   * 栈帧过大导致栈内存溢出\n\n### 2.3 实际演示 \n在idea中，通过断点调试，我们可以观测到栈帧的存在\n运行如下代码\n```java\npublic class StackTest {\n  public static int add(int a, int b) {\n    return a + b;\n  }\n\n  public static void main(String[] args) {\n    add(1, 2);  //在这句打断点\n  }\n}\n```\n程序运行到断点处停止，我们看debugger窗口\n![在这里插入图片描述](https://img-blog.csdnimg.cn/bd5113f93e4b4afead467b0d2084cc8c.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhdzk2eA==,size_16,color_FFFFFF,t_70#pic_center)\n可以看得到Frames这个子窗口，这表示的就是栈帧的集合，也就是虚拟机栈，我们的程序在main方法中的add暂停，所以目前栈帧中只有一个main方法，我们运行到下一步看看\n![在这里插入图片描述](https://img-blog.csdnimg.cn/52e00e7f2a634217ba041a3cb4d6d410.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhdzk2eA==,size_16,color_FFFFFF,t_70#pic_center)\n可以看到main栈帧的上方有了add，这符合栈后进先出的特点，可以预见，如果addd中继续调用方法，那么add栈帧之上又会有新的栈帧。\n\n现在我们继续运行程序，让add方法运行完毕\n![在这里插入图片描述](https://img-blog.csdnimg.cn/d94890ad9d104242b18f54d08027e2bd.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhdzk2eA==,size_16,color_FFFFFF,t_70#pic_center)\n可以看到add的栈帧消失了，也就是add方法的运行内存被释放了。\n这个小demo可以看出栈帧扮演的角色和运行方式。\n\n## 3. 本地方法栈 \n\nNative Method Stacks\n\n* 发挥的作用和虚拟机栈发挥的作用相似，区别只是本地方法栈执行本地方法，虚拟机栈执行Java方法\n\n* 本地方法：Native Method ，不是Java编写的代码，通常是操作系统自带的方法代码。\n\n* 本地方法栈为本地方法的运行提供内存空间\n* 在规范中对本地方法栈的实现方式（语言、数据结构）没有强制规定，具体的虚拟机可以自由的实现它，有的虚拟机（Sun HotSpot）甚至将本地方法栈和虚拟机栈合二为一\n\n## 4. 堆\n\n\n\n### 4.1定义\n\nHeap 堆\n\n* 通过new关键字，创建对象都会使用堆内存\n* 唯一目的就是存放对象实例，这一点在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配，但随着优化技术的产生，将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了\n* 可以细分为新生代和老年代，再细一点的有Eden空间、From Survivor空间、To Survivor空间等\n* 根据规范规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，实现时可以实现成固定大小或可扩展的，目前主流虚拟机都是可扩展的\n\n特点\n\n* 它是线程共享的，堆中对象都需要考虑线程安全的问题\n* 有垃圾回收机制\n* 对多数应用而言，堆是Java虚拟机所管理的内存中最大的一块\n* 在虚拟机启动时创建\n\n### 4.2 堆内存溢出\n\n-Xmx 堆内存分配大小命令\n\nOutOfMemoryError : Java heap space\n\n垃圾回收：没人用的对象，就作为垃圾被回收\n\n堆内存溢出：大量的对象被不断创建，同时一直被使用，可能导致堆内存溢出\n\n### 4.3 堆内存诊断\n\n在idea控制台窗口即可运行\n\n1. jps工具\n   * 查看当前系统中有哪些Java进程\n2. jmap工具\n   * 查看堆内存占用情况 ，不连续，只能查看某一时刻的情况\n   * jmap -heap 进程id\n3. jconsole\n   * 图形界面，多功能检测工具，可连续监测\n\n案例：\n\n* 垃圾回收后，内存占用率仍然很高\n* 使用jvisualvm工具，通过堆dump功能查看对象在某一时刻的具体情况，从而做出诊断\n\n## 5. 方法区\n\n### 5.1 定义\n\nMethod Area\n\n方法区是所有Java虚拟机线程共享的区域，它存储了与类结构相关的信息，如成员变量，方法数据，成员方法和构造器的代码部分，运行时常量池。\n\n方法区在虚拟机启动时就被创建，逻辑上它是堆的组成部分，但具体实现不同的jvm有所不同\n\n### 5.2 组成\n\n待补充\n\n### 5.3 方法区内存溢出\n\n-XX:MaxMetaspaceSize 设置元空间大小\n\nOutOfMemoryError:Metaspace\n\n* 1.8以前会导致永久代内存溢出\n* 1.8以后会导致元空间内存溢出\n\n### 5.4 运行时常量池\n\n* 常量池，就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息\n* 运行时常量池，常量池是 *.class 文件中的，当该类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址\n\n### 5.5 StringTable特性\n\n* 常量池中的字符串仅是符号，第一次用到时才变为对象\n* 利用串池的机制，来避免重复创建字符串对象\n* 字符串变量拼接的原理是StringBuilder（jdk1.8）\n* 字符串常量拼接的原理是编译期优化\n* 可以使用intern方法，主动将串池中还没有的字符串对象放入串池\n  * 1.8中，将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池，会把串池中的对象返回\n  * 1.6中，将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则会把此对象复制一份，再放入串池，会把串池中的对象返回\n\n### 5.6 StringTable位置\n\n* 1.8，StringTable在堆（Heap）中\n* 1.6，StringTable在永久代（PermGen）中\n\n### 5.7 StringTable垃圾回收\n\n### 5.8 StringTable性能调优\n\n* StringTable本质上是哈希表，因此调优就是调整桶的个数，适当的把桶的个数调大，减少哈希碰撞   -XX:StringTableSize=桶个数\n* 考虑将字符串对象是否入池\n* 既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当量池无法再申请到内存时会抛出OutOfMemoryError异常。\n\n## 6. 直接内存\n\n### 6.1 定义\n\nDirect Memory\n\n* 常见于NIO（一种基于通道（Channel）与缓\n  冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作）操作，用于数据缓存区\n* 分配回收成本较高，但读写性能高，因为避免了在Java堆和Native堆中来回复制数据\n* 不受JVM内存回收管理\n\n### 6.2 分配和回收原理\n\n* 使用了Unsafe对象完成直接内存的分配回收，并且回收需要主动调用的freeMemory方法\n* ByteBuffer的实现类内部，使用了Cleaner（虚引用）来检测ByteBuffer对象，一旦ByteBuffer对象被垃圾回收，那么就会有ReferenceHandler线程通过Cleaner的clean方法调用freeMemory来释放直接内存\n","tags":["Java","JVM","深入理解Java虚拟机"],"categories":["技术笔记"]},{"title":"剑指 Offer 03. 数组中重复的数字的4种解法（Java语言）","url":"//post/剑指 Offer 03. 数组中重复的数字的4种解法（Java语言）.html","content":"\n## 题目详情\n\n找出数组中重复的数字。\n\n在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。\n\n示例 1：\n\n输入：\n[2, 3, 1, 0, 2, 5, 3]\n输出：2 或 3 \n\n## 解法一：暴力法，双层循环\n直接进行两层循环，对每个数字都逐一比较，空间复杂度O(1)，时间复杂度O(n^2)，总的来说是下下策，执行用时吓死人\n![在这里插入图片描述](https://img-blog.csdnimg.cn/3075c099b4af457dbd8c8ffe43a3945f.PNG#pic_center)\nJava代码\n```java\npublic int findRepeatNumber_1(int[] nums) {\n    for (int i = 0; i < nums.length; i++)\n      for (int j = i + 1; j < nums.length; j++)\n        if (nums[i] == nums[j])\n          return nums[i];\n    return -1;\n  }\n```\n## 解法二 排序后相邻的两两比较\n很容易想到的方法，排序后两两比较，空间复杂度O(1)，时间复杂度O(nlogn)，只能说是中下策，但执行用时已经有了相当的改善\n![在这里插入图片描述](https://img-blog.csdnimg.cn/9f01f52a148f4f3399936eedf4904588.PNG#pic_center)\nJava代码\n```java\npublic int findRepeatNumber_2(int[] nums) {\n    Arrays.sort(nums);\n    for (int i = 0; i < nums.length - 1; i++) {\n      if (nums[i] == nums[i + 1])\n        return nums[i];\n    }\n    return -1;\n  }\n```\n## 解法三 利用数组实现一个map映射\n首先，判断重复，常见的办法就是利用HashMap或是HashSet来判断，但我们观察数组发现，给定的值都是0~n-1，那么我们没必要使用集合类来加重负担，直接用数组就可以完成映射，给定的数组元素为键，出现次数为值。\n空间复杂度为O(n)，时间复杂度为O(n)，在大多数面试中已经算是可以让人接受的答案了。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/44d453122fbd47539088318a84a3b140.PNG#pic_center)\n```java\npublic int findRepeatNumber_3(int[] nums) {\n    int[] map = new int[nums.length];\n    for (int i = 0; i < nums.length; i++) {\n      if (map[nums[i]] == 0)\n        map[nums[i]]++;\n      else\n        return nums[i];\n    }\n    return -1;\n  }\n```\n## 解法四 利用重排后的元素碰撞\n解法三已经达到了空间时间复杂度都是O(n)的情况，实际上还能继续优化，达到O(1)的空间复杂度。\n我们知道，数组中的元素是0~n-1，那么可以想到，如果没有重复的元素，那么排序后，每个元素都应该和它的下标相同，那么如果有重复的元素，那么两个元素就会撞到一起。\n基于这种思路，我们设计如下算法：对每个元素都进行处理，把它交换到它应该在的位置，如果交换前发现那个位置上的元素和它相等，也就是撞车了，那么很明显这个元素就是重复的数字。\n每个数字只要进行交换就能找到自己的位置，时间复杂度是O(n)，且没有用到额外的空间，因此空间复杂度只有O(1)\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/5be8fe2d4adf4ba1afedb4e5c97c069e.PNG#pic_center)\n```java\npublic int findRepeatNumber_4(int[] nums) {\n    for (int i = 0; i < nums.length; i++) {\n      while (nums[i] != i) {\n        //两个数撞了\n        if (nums[i] == nums[nums[i]]) {\n          return nums[i];\n        }\n        //把一个数交换到它应该在的位置\n        int temp = nums[nums[i]];\n        nums[nums[i]] = nums[i];\n        nums[i] = temp;\n      }\n    }\n    return -1;\n  }\n```\n","tags":["数据结构与算法","剑指Offer"],"categories":["算法笔记"]},{"title":"Springboot的自动装配原理浅析","url":"//post/Springboot的自动装配原理浅析.html","content":"\n最近在学习Springboot，不少文章和视频在完成了第一个快速入门的项目之后就直接进入了Springboot运行的原理部分，因此决定写一篇文章加深理解。\n\n原理的理解主要使用了查看源码和画流程图的方式。\n\n### pom.xml\n对于一个maven项目，我们一般首要分析其pom文件，查看相关依赖。\n\n```xml\n<dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n            <exclusions>\n                <exclusion>\n                    <groupId>org.junit.vintage</groupId>\n                    <artifactId>junit-vintage-engine</artifactId>\n                </exclusion>\n            </exclusions>\n        </dependency>\n    </dependencies>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n            </plugin>\n        </plugins>\n    </build>\n```\n可以看到依赖方面都是很简单的内容，加入了测试启动器和web启动器以及springboot的build插件，但我们发现了一个不一般的地方，他们都没有版本号！这是为什么呢？\n   我们往上查看，可以发现这样的父依赖。\n\n```xml\n<parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.3.4.RELEASE</version>\n        <relativePath/> <!-- lookup parent from repository -->\n    </parent>\n```\n   我们点进去查看，会发现。。。还有一层父依赖！\n   ```xml\n   <parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-dependencies</artifactId>\n    <version>2.3.4.RELEASE</version>\n  </parent>\n   ```\n   继续点进去查看。\n```xml\n<properties>\n    <activemq.version>5.15.13</activemq.version>\n    <antlr2.version>2.7.7</antlr2.version>\n    <appengine-sdk.version>1.9.82</appengine-sdk.version>\n    <artemis.version>2.12.0</artemis.version>\n    <aspectj.version>1.9.6</aspectj.version>\n    <assertj.version>3.16.1</assertj.version>\n    <atomikos.version>4.0.6</atomikos.version>\n    <awaitility.version>4.0.3</awaitility.version>\n    <bitronix.version>2.1.4</bitronix.version>\n    <build-helper-maven-plugin.version>3.1.0</build-helper-maven-plugin.version>\n    <byte-buddy.version>1.10.14</byte-buddy.version>\n    <caffeine.version>2.8.5</caffeine.version>\n    <cassandra-driver.version>4.6.1</cassandra-driver.version>\n    ...........\n```\n```\n这样的信息就是这些依赖尽头的主体了，这个文件有大量的配置信息，标注了每个可能用到的依赖的版本号，因此我们不用指定依赖的版本，springboot会根据你使用的版本自动给你安排合适的版本，再也不用担心依赖版本的冲突导致的崩溃啦！\n\npom.xml文件我们就说到这里，接下来才是重头戏了！\n\n思维导图：\n\t![在这里插入图片描述](https://img-blog.csdnimg.cn/20200929160256862.png#pic_center)\n\n### 启动类的@SpringBootApplication注解\n启动类包括两个重要的部分，一个是@SpringBootApplication注解，另一个是其中的run方法，我们先从这个注解开始说起。\n\n首先，这个注解的作用，猜也猜得到，是标注这个应用是一个springboot应用，这样springboot就可以帮我们对其进行自动配置，我们想要了解，spring boot是如何通过注解来自动装配的，装配了什么。\n\n老办法，查看源码，我点！\n```java\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@SpringBootConfiguration\n@EnableAutoConfiguration\n@ComponentScan\n```\n以上是@SpringBootApplication注解之下的几个注解，出去那些基础的之外，我们可以看见三个特别显眼的，@SpringBootConfiguration，@ComponentScan，@EnableAutoConfiguration，我们逐个查看他们的源码。\n\n#### @SpringBootConfiguration\n\n他的源码：\n\n```java\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Configuration\n```\n乏善可陈。。。根据其下的@Configuration可以猜到，它是起到一个标注作用的注解，标志当前应用为一个springboot应用。\n\n我们回到上一层查看其他注解的源码。\n\n#### @ComponentScan\n\n这个更没啥好说的了，源码都没必要看了，他的作用是扫描指定包下的组件，将它们加载到Spring的IOC容器之中，很重要，但不是我们探究的重点。\n\n我们查看最后一个注解的源码。\n\n#### @EnableAutoConfiguration\n看得出来，他的作用是启用自动配置，我们重点关注如何启用，怎么启用，启用了什么。\n他的源码：\n\n```java\n@AutoConfigurationPackage\n@Import({AutoConfigurationImportSelector.class})\n```\n看起来重要的注解就这两个，第一个看翻译是自动配置包，我们点进去查看他的源码：\n\n```java\n@Import({Registrar.class})\n```\n噢，这是一个注册器，根据相关源码猜测是将bean注册导入到容器之中（若有错误希望指正）。\n\n我们回头，看看import导入的东西。\n\n自动配置导入选择器，我们猜测它是导入了需要的配置文件，查看源码：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200929162249237.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhdzk2eA==,size_16,color_FFFFFF,t_70#pic_center)\n我这里截图还没有截全。。。我们发现其中有相当多的方法，我们的目的是查看如何加载组件的，因此寻找configuration相关的方法。\n\n找到了！getCandidateConfigurations，获取候选配置，这个方法中又使用了SpringFactoriesLoader，我们继续深入。\n```public static final String FACTORIES_RESOURCE_LOCATION = \"META-INF/spring.factories\";```\n看到了看起来是文件的东西！我们使用全局搜索，发现它在springboot的jar包内，我们再点开来看看\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200929162722643.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhdzk2eA==,size_16,color_FFFFFF,t_70#pic_center)我们根据源头打开spring.factories ， 看到了很多自动配置的文件；这就是自动配置根源所在！可以随便点开看看，都可以看到这些一个个的都是JavaConfig配置类，而且都注入了一些Bean。\n\n至此，我们大概明白了Spring boot的自动装配原理了：\n\n自动配置真正实现是从classpath中搜寻所有的META-INF/spring.factories配置文件 ，并将其中对应的 org.springframework.boot.autoconfigure. 包下的配置项，通过反射实例化为对应标注了 @Configuration的JavaConfig形式的IOC容器配置类 ， 然后将这些都汇总成为一个实例并加载到IOC容器中。\n\n所以其实刚刚那一大串套娃注解其实都是为了拿到spring.factories。。。我不太懂设计模式，不太懂这样做的意义是什么样的哈哈哈。\n\n## 结论\n\n1. SpringBoot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值\n\n2. 将这些值作为自动配置类导入容器 ， 自动配置类就生效 ， 帮我们进行自动配置工作；\n\n3. 整个J2EE的整体解决方案和自动配置都在springboot-autoconfigure的jar包中；\n\n4. 它会给容器中导入非常多的自动配置类 （xxxAutoConfiguration）, 就是给容器中导入这个场景需要的所有组件 ， 并配置好这些组件 ；\n\n5. 有了自动配置类 ， 免去了我们手动编写配置注入功能组件等的工作；\n\n思维导图：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200929164052679.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhdzk2eA==,size_16,color_FFFFFF,t_70#pic_center)\n\n\n### run方法\n分析该方法主要分两部分，一部分是SpringApplication的实例化，二是run方法的执行；\nSpringApplication\n\n这个类主要做了以下四件事情：\n\n1、推断应用的类型是普通的项目还是Web项目\n\n2、查找并加载所有可用初始化器 ， 设置到initializers属性中\n\n3、找出所有的应用程序监听器，设置到listeners属性中\n\n4、推断并设置main方法的定义类，找到运行的主类\n\n源码分析无力了。。。给大家一张图吧，说的很清楚了，大家可以跟着这张图自己读读源码。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200929163826667.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhdzk2eA==,size_16,color_FFFFFF,t_70#pic_center)\n\n","tags":["Java","源码分析","SpringBoot"],"categories":["技术分享"]},{"title":"Java new ArrayList(int initialCapacity)初始化容量问题","url":"//post/Java new ArrayList(int initialCapacity)初始化容量问题.html","content":"\n\n\n今天看了ArrayList源码，发现了一个不大不小的问题：\n\n```java\npublic ArrayList(int initialCapacity) {\n        if (initialCapacity > 0) {\n            this.elementData = new Object[initialCapacity];\n        } else if (initialCapacity == 0) {\n            this.elementData = EMPTY_ELEMENTDATA;\n        } else {\n            throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                               initialCapacity);\n        }\n    }\n```\n\n这个构造函数咋一看问题不大，给elementData底层数组分配空间嘛，初始化数组的大小了\n但是实际使用时：\n```java\nArrayList<Integer> a = new ArrayList(9);\na.set(1,5);\n```\n抛出了IndexOutOfBoundsException\n\n结合源码：\n```java\npublic E set(int index, E element) {\n        Objects.checkIndex(index, size);\n        E oldValue = elementData(index);\n        elementData[index] = element;\n        return oldValue;\n    }\n```\n其中第一行首先检测了下标，参数是index和size，而size是元素个数，也就是说，尽管设置了数组的容量，但针对ArrayList中元素的操作，是根据元素的位置，而不是根据容量来操作。也就是说，至少得有个元素才能set它，没有元素就是set个寂寞。\n\n因此```set(1,5)```在第一行直接抛出异常了\n\n综上所述ArrayList(int initialCapacity) 只是**让ArrayList有了容纳 initialCapacity个元素的潜力，并不能对其中的“位置”操作**。\n\nPS：这个问题在Java核心技术卷1中就有提到，但我当时直接忘了，果然看了源码才理解的透彻。\n","tags":["Java","源码分析"],"categories":["问题记录"]}]