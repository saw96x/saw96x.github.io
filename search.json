[{"title":"Java new ArrayList(int initialCapacity)初始化容量问题","url":"//post/Java new ArrayList(int initialCapacity)初始化容量问题.html","content":"\n今天看了ArrayList源码，发现了一个不大不小的问题：\n```java\npublic ArrayList(int initialCapacity) {\n        if (initialCapacity > 0) {\n            this.elementData = new Object[initialCapacity];\n        } else if (initialCapacity == 0) {\n            this.elementData = EMPTY_ELEMENTDATA;\n        } else {\n            throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                               initialCapacity);\n        }\n    }\n```\n\n这个构造函数咋一看问题不大，给elementData底层数组分配空间嘛，初始化数组的大小了\n但是实际使用时：\n```java\nArrayList<Integer> a = new ArrayList(9);\na.set(1,5);\n```\n抛出了IndexOutOfBoundsException\n\n结合源码：\n```java\npublic E set(int index, E element) {\n        Objects.checkIndex(index, size);\n        E oldValue = elementData(index);\n        elementData[index] = element;\n        return oldValue;\n    }\n```\n其中第一行首先检测了下标，参数是index和size，而size是元素个数，也就是说，尽管设置了数组的容量，但针对ArrayList中元素的操作，是根据元素的位置，而不是根据容量来操作。也就是说，至少得有个元素才能set它，没有元素就是set个寂寞。\n\n因此```set(1,5)```在第一行直接抛出异常了\n\n综上所述ArrayList(int initialCapacity) 只是**让ArrayList有了容纳 initialCapacity个元素的潜力，并不能对其中的“位置”操作**。\n\nPS：这个问题在Java核心技术卷1中就有提到，但我当时直接忘了，果然看了源码才理解的透彻。\n","tags":["Java","源码分析"]}]