[{"title":"剑指 Offer 03. 数组中重复的数字的4种解法（Java语言）","url":"//post/剑指 Offer 03. 数组中重复的数字的4种解法（Java语言）.html","content":"\n## 题目详情\n\n找出数组中重复的数字。\n\n在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。\n\n示例 1：\n\n输入：\n[2, 3, 1, 0, 2, 5, 3]\n输出：2 或 3 \n\n## 解法一：暴力法，双层循环\n直接进行两层循环，对每个数字都逐一比较，空间复杂度O(1)，时间复杂度O(n^2)，总的来说是下下策，执行用时吓死人\n![在这里插入图片描述](https://img-blog.csdnimg.cn/3075c099b4af457dbd8c8ffe43a3945f.PNG#pic_center)\nJava代码\n```java\npublic int findRepeatNumber_1(int[] nums) {\n    for (int i = 0; i < nums.length; i++)\n      for (int j = i + 1; j < nums.length; j++)\n        if (nums[i] == nums[j])\n          return nums[i];\n    return -1;\n  }\n```\n## 解法二 排序后相邻的两两比较\n很容易想到的方法，排序后两两比较，空间复杂度O(1)，时间复杂度O(nlogn)，只能说是中下策，但执行用时已经有了相当的改善\n![在这里插入图片描述](https://img-blog.csdnimg.cn/9f01f52a148f4f3399936eedf4904588.PNG#pic_center)\nJava代码\n```java\npublic int findRepeatNumber_2(int[] nums) {\n    Arrays.sort(nums);\n    for (int i = 0; i < nums.length - 1; i++) {\n      if (nums[i] == nums[i + 1])\n        return nums[i];\n    }\n    return -1;\n  }\n```\n## 解法三 利用数组实现一个map映射\n首先，判断重复，常见的办法就是利用HashMap或是HashSet来判断，但我们观察数组发现，给定的值都是0~n-1，那么我们没必要使用集合类来加重负担，直接用数组就可以完成映射，给定的数组元素为键，出现次数为值。\n空间复杂度为O(n)，时间复杂度为O(n)，在大多数面试中已经算是可以让人接受的答案了。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/44d453122fbd47539088318a84a3b140.PNG#pic_center)\n```java\npublic int findRepeatNumber_3(int[] nums) {\n    int[] map = new int[nums.length];\n    for (int i = 0; i < nums.length; i++) {\n      if (map[nums[i]] == 0)\n        map[nums[i]]++;\n      else\n        return nums[i];\n    }\n    return -1;\n  }\n```\n## 解法四 利用重排后的元素碰撞\n解法三已经达到了空间时间复杂度都是O(n)的情况，实际上还能继续优化，达到O(1)的空间复杂度。\n我们知道，数组中的元素是0~n-1，那么可以想到，如果没有重复的元素，那么排序后，每个元素都应该和它的下标相同，那么如果有重复的元素，那么两个元素就会撞到一起。\n基于这种思路，我们设计如下算法：对每个元素都进行处理，把它交换到它应该在的位置，如果交换前发现那个位置上的元素和它相等，也就是撞车了，那么很明显这个元素就是重复的数字。\n每个数字只要进行交换就能找到自己的位置，时间复杂度是O(n)，且没有用到额外的空间，因此空间复杂度只有O(1)\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/5be8fe2d4adf4ba1afedb4e5c97c069e.PNG#pic_center)\n```java\npublic int findRepeatNumber_4(int[] nums) {\n    for (int i = 0; i < nums.length; i++) {\n      while (nums[i] != i) {\n        //两个数撞了\n        if (nums[i] == nums[nums[i]]) {\n          return nums[i];\n        }\n        //把一个数交换到它应该在的位置\n        int temp = nums[nums[i]];\n        nums[nums[i]] = nums[i];\n        nums[i] = temp;\n      }\n    }\n    return -1;\n  }\n```\n","tags":["数据结构与算法","剑指Offer"],"categories":["技术学习"]},{"title":"Springboot的自动装配原理浅析","url":"//post/Springboot的自动装配原理浅析.html","content":"\n最近在学习Springboot，不少文章和视频在完成了第一个快速入门的项目之后就直接进入了Springboot运行的原理部分，因此决定写一篇文章加深理解。\n\n原理的理解主要使用了查看源码和画流程图的方式。\n\n### pom.xml\n对于一个maven项目，我们一般首要分析其pom文件，查看相关依赖。\n\n```xml\n<dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n            <exclusions>\n                <exclusion>\n                    <groupId>org.junit.vintage</groupId>\n                    <artifactId>junit-vintage-engine</artifactId>\n                </exclusion>\n            </exclusions>\n        </dependency>\n    </dependencies>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n            </plugin>\n        </plugins>\n    </build>\n```\n可以看到依赖方面都是很简单的内容，加入了测试启动器和web启动器以及springboot的build插件，但我们发现了一个不一般的地方，他们都没有版本号！这是为什么呢？\n   我们往上查看，可以发现这样的父依赖。\n\n```xml\n<parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.3.4.RELEASE</version>\n        <relativePath/> <!-- lookup parent from repository -->\n    </parent>\n```\n   我们点进去查看，会发现。。。还有一层父依赖！\n   ```xml\n   <parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-dependencies</artifactId>\n    <version>2.3.4.RELEASE</version>\n  </parent>\n   ```\n   继续点进去查看。\n```xml\n<properties>\n    <activemq.version>5.15.13</activemq.version>\n    <antlr2.version>2.7.7</antlr2.version>\n    <appengine-sdk.version>1.9.82</appengine-sdk.version>\n    <artemis.version>2.12.0</artemis.version>\n    <aspectj.version>1.9.6</aspectj.version>\n    <assertj.version>3.16.1</assertj.version>\n    <atomikos.version>4.0.6</atomikos.version>\n    <awaitility.version>4.0.3</awaitility.version>\n    <bitronix.version>2.1.4</bitronix.version>\n    <build-helper-maven-plugin.version>3.1.0</build-helper-maven-plugin.version>\n    <byte-buddy.version>1.10.14</byte-buddy.version>\n    <caffeine.version>2.8.5</caffeine.version>\n    <cassandra-driver.version>4.6.1</cassandra-driver.version>\n    ...........\n```\n```\n这样的信息就是这些依赖尽头的主体了，这个文件有大量的配置信息，标注了每个可能用到的依赖的版本号，因此我们不用指定依赖的版本，springboot会根据你使用的版本自动给你安排合适的版本，再也不用担心依赖版本的冲突导致的崩溃啦！\n\npom.xml文件我们就说到这里，接下来才是重头戏了！\n\n思维导图：\n\t![在这里插入图片描述](https://img-blog.csdnimg.cn/20200929160256862.png#pic_center)\n\n### 启动类的@SpringBootApplication注解\n启动类包括两个重要的部分，一个是@SpringBootApplication注解，另一个是其中的run方法，我们先从这个注解开始说起。\n\n首先，这个注解的作用，猜也猜得到，是标注这个应用是一个springboot应用，这样springboot就可以帮我们对其进行自动配置，我们想要了解，spring boot是如何通过注解来自动装配的，装配了什么。\n\n老办法，查看源码，我点！\n```java\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@SpringBootConfiguration\n@EnableAutoConfiguration\n@ComponentScan\n```\n以上是@SpringBootApplication注解之下的几个注解，出去那些基础的之外，我们可以看见三个特别显眼的，@SpringBootConfiguration，@ComponentScan，@EnableAutoConfiguration，我们逐个查看他们的源码。\n\n#### @SpringBootConfiguration\n\n他的源码：\n\n```java\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Configuration\n```\n乏善可陈。。。根据其下的@Configuration可以猜到，它是起到一个标注作用的注解，标志当前应用为一个springboot应用。\n\n我们回到上一层查看其他注解的源码。\n\n#### @ComponentScan\n\n这个更没啥好说的了，源码都没必要看了，他的作用是扫描指定包下的组件，将它们加载到Spring的IOC容器之中，很重要，但不是我们探究的重点。\n\n我们查看最后一个注解的源码。\n\n#### @EnableAutoConfiguration\n看得出来，他的作用是启用自动配置，我们重点关注如何启用，怎么启用，启用了什么。\n他的源码：\n\n```java\n@AutoConfigurationPackage\n@Import({AutoConfigurationImportSelector.class})\n```\n看起来重要的注解就这两个，第一个看翻译是自动配置包，我们点进去查看他的源码：\n\n```java\n@Import({Registrar.class})\n```\n噢，这是一个注册器，根据相关源码猜测是将bean注册导入到容器之中（若有错误希望指正）。\n\n我们回头，看看import导入的东西。\n\n自动配置导入选择器，我们猜测它是导入了需要的配置文件，查看源码：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200929162249237.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhdzk2eA==,size_16,color_FFFFFF,t_70#pic_center)\n我这里截图还没有截全。。。我们发现其中有相当多的方法，我们的目的是查看如何加载组件的，因此寻找configuration相关的方法。\n\n找到了！getCandidateConfigurations，获取候选配置，这个方法中又使用了SpringFactoriesLoader，我们继续深入。\n```public static final String FACTORIES_RESOURCE_LOCATION = \"META-INF/spring.factories\";```\n看到了看起来是文件的东西！我们使用全局搜索，发现它在springboot的jar包内，我们再点开来看看\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200929162722643.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhdzk2eA==,size_16,color_FFFFFF,t_70#pic_center)我们根据源头打开spring.factories ， 看到了很多自动配置的文件；这就是自动配置根源所在！可以随便点开看看，都可以看到这些一个个的都是JavaConfig配置类，而且都注入了一些Bean。\n\n至此，我们大概明白了Spring boot的自动装配原理了：\n\n自动配置真正实现是从classpath中搜寻所有的META-INF/spring.factories配置文件 ，并将其中对应的 org.springframework.boot.autoconfigure. 包下的配置项，通过反射实例化为对应标注了 @Configuration的JavaConfig形式的IOC容器配置类 ， 然后将这些都汇总成为一个实例并加载到IOC容器中。\n\n所以其实刚刚那一大串套娃注解其实都是为了拿到spring.factories。。。我不太懂设计模式，不太懂这样做的意义是什么样的哈哈哈。\n\n## 结论\n\n1. SpringBoot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值\n\n2. 将这些值作为自动配置类导入容器 ， 自动配置类就生效 ， 帮我们进行自动配置工作；\n\n3. 整个J2EE的整体解决方案和自动配置都在springboot-autoconfigure的jar包中；\n\n4. 它会给容器中导入非常多的自动配置类 （xxxAutoConfiguration）, 就是给容器中导入这个场景需要的所有组件 ， 并配置好这些组件 ；\n\n5. 有了自动配置类 ， 免去了我们手动编写配置注入功能组件等的工作；\n\n思维导图：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200929164052679.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhdzk2eA==,size_16,color_FFFFFF,t_70#pic_center)\n\n\n### run方法\n分析该方法主要分两部分，一部分是SpringApplication的实例化，二是run方法的执行；\nSpringApplication\n\n这个类主要做了以下四件事情：\n\n1、推断应用的类型是普通的项目还是Web项目\n\n2、查找并加载所有可用初始化器 ， 设置到initializers属性中\n\n3、找出所有的应用程序监听器，设置到listeners属性中\n\n4、推断并设置main方法的定义类，找到运行的主类\n\n源码分析无力了。。。给大家一张图吧，说的很清楚了，大家可以跟着这张图自己读读源码。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200929163826667.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhdzk2eA==,size_16,color_FFFFFF,t_70#pic_center)\n\n","tags":["Java","源码分析","SpringBoot"],"categories":["技术学习"]},{"title":"Java new ArrayList(int initialCapacity)初始化容量问题","url":"//post/Java new ArrayList(int initialCapacity)初始化容量问题.html","content":"\n今天看了ArrayList源码，发现了一个不大不小的问题：\n```java\npublic ArrayList(int initialCapacity) {\n        if (initialCapacity > 0) {\n            this.elementData = new Object[initialCapacity];\n        } else if (initialCapacity == 0) {\n            this.elementData = EMPTY_ELEMENTDATA;\n        } else {\n            throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                               initialCapacity);\n        }\n    }\n```\n\n这个构造函数咋一看问题不大，给elementData底层数组分配空间嘛，初始化数组的大小了\n但是实际使用时：\n```java\nArrayList<Integer> a = new ArrayList(9);\na.set(1,5);\n```\n抛出了IndexOutOfBoundsException\n\n结合源码：\n```java\npublic E set(int index, E element) {\n        Objects.checkIndex(index, size);\n        E oldValue = elementData(index);\n        elementData[index] = element;\n        return oldValue;\n    }\n```\n其中第一行首先检测了下标，参数是index和size，而size是元素个数，也就是说，尽管设置了数组的容量，但针对ArrayList中元素的操作，是根据元素的位置，而不是根据容量来操作。也就是说，至少得有个元素才能set它，没有元素就是set个寂寞。\n\n因此```set(1,5)```在第一行直接抛出异常了\n\n综上所述ArrayList(int initialCapacity) 只是**让ArrayList有了容纳 initialCapacity个元素的潜力，并不能对其中的“位置”操作**。\n\nPS：这个问题在Java核心技术卷1中就有提到，但我当时直接忘了，果然看了源码才理解的透彻。\n","tags":["Java","源码分析"],"categories":["技术学习"]}]