[{"title":"JVM内存结构","url":"//post/JVM内存结构.html","content":"\n本篇笔记不定期更新\n## 内存结构图\n先上图\n![在这里插入图片描述](https://img-blog.csdnimg.cn/bf995bbfbfcc4629ab3ef9f83c78d099.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhdzk2eA==,size_16,color_FFFFFF,t_70#pic_center)\n这张图差不多就把JVM的内存结构以及和class源文件，JVM执行引擎，以及操作系统自带的本地方法接口之间的关系囊括进去了。\n\n下面我们就JVM内存结构的几个组成部分来逐一简单介绍一下\n\n## 1. 程序计数器\n\n### 1.1 定义\n\nProgram Counter Register 程序计数器（寄存器）\n\n### 1.2 作用\n\n1. 在执行当前指令时，记住下一条JVM指令的执行地址，所以PCR也被称为寄存器，在物理上通过CPU寄存器实现\n2. 在多线程程序中起到一个记录上下文的作用，方便切换线程时可以继续运行\n3. 字节码解释器通过改变PCR的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要PCR来完成\n4. 如果线程正在执行Java方法，那么PCR记录的市正在执行的虚拟机字节码指令的地址，如果正在执行的是Native方法，这个计数器值则为空（Undefined）\n\n### 1.3 特点\n\n* Java支持多线程，而PCR是线程私有的，每个线程都有自己的PCR\n* 不会存在内存溢出此内存区域，是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域\n* 生命周期与线程相同\n\n## 2. 虚拟机栈\n\n栈--线程运行需要的内存空间，由栈帧组成，栈帧看为栈内的元素\n\n栈帧--每个方法运行时所需要的内存，参数，局部变量，返回地址等等····\n\n当调用某个方法时，会给栈帧分配内存，并将这个栈帧压入栈中，运行完毕后，会释放内存，也就是弹出栈帧。\n\n当方法调用方法时，就会压入多个栈帧\n\n### 2.1 定义\n\nJava Virtual Machine Stacks\n\n* 每个线程运行时需要的内存，称为虚拟机栈\n* 每个栈由多个栈帧（Frame）祖传，对应着每次方法调用时所占用的内存，一般来说是局部变量\n* 每个线程只能由一个活动栈帧，对应着当前正在执行的那个方法，也就是目前栈顶的那个栈帧\n* 线程私有的，生命周期与线程相同\n* 栈中有局部变量表，存放了编译期可知的各种基本数据类型、对象引用（reference类型，它不等同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）和returnAddress类型（指向了一条字节码指令的地址）。其中64位长度的long和double类型的数据会占用2个局部变量空间（Slot），其余的数据类型只占用1个。\n\n问题辨析\n\n1. 垃圾回收是否涉及栈内存？不涉及，栈内存只和方法有关，方法运行完毕后栈帧出栈，内存自动回收。\n\n2. 栈内存分配越大越好吗？不是，内存分配得越大，线程就越少，因为物理内存是确定的，内存分配的越大，能更多次的进行方法递归。一般来说，默认的分配内存已经够用了。\n\n3. 方法内的局部变量是否线程安全？\n\n   是的，因为每个线程只对应一个虚拟机栈，和其他方法的线程是互不干扰的，本质上操作的局部变量完全没有关系，因此是线程安全的。但如果不是局部变量，而是静态变量，或者是方法参数、或者是局部变量作为返回值返回了，那么就线程不安全，因为这时不同线程操纵的变量是同一个变量了。\n\n   简单来说，如果方法内局部变量没有逃离方法的作用范围，那么他就是线程安全的\n\n### 2.2 栈内存溢出\n\n   -Xss 栈内存分配大小命令\n\n   StackOverflowError\n\n   * 栈帧过多导致栈内存溢出，如递归调用但没设置中止条件，或是出现了循环引用问题\n   * 栈帧过大导致栈内存溢出\n\n### 2.3 实际演示 \n在idea中，通过断点调试，我们可以观测到栈帧的存在\n运行如下代码\n```java\npublic class StackTest {\n  public static int add(int a, int b) {\n    return a + b;\n  }\n\n  public static void main(String[] args) {\n    add(1, 2);  //在这句打断点\n  }\n}\n```\n程序运行到断点处停止，我们看debugger窗口\n![在这里插入图片描述](https://img-blog.csdnimg.cn/bd5113f93e4b4afead467b0d2084cc8c.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhdzk2eA==,size_16,color_FFFFFF,t_70#pic_center)\n可以看得到Frames这个子窗口，这表示的就是栈帧的集合，也就是虚拟机栈，我们的程序在main方法中的add暂停，所以目前栈帧中只有一个main方法，我们运行到下一步看看\n![在这里插入图片描述](https://img-blog.csdnimg.cn/52e00e7f2a634217ba041a3cb4d6d410.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhdzk2eA==,size_16,color_FFFFFF,t_70#pic_center)\n可以看到main栈帧的上方有了add，这符合栈后进先出的特点，可以预见，如果addd中继续调用方法，那么add栈帧之上又会有新的栈帧。\n\n现在我们继续运行程序，让add方法运行完毕\n![在这里插入图片描述](https://img-blog.csdnimg.cn/d94890ad9d104242b18f54d08027e2bd.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhdzk2eA==,size_16,color_FFFFFF,t_70#pic_center)\n可以看到add的栈帧消失了，也就是add方法的运行内存被释放了。\n这个小demo可以看出栈帧扮演的角色和运行方式。\n\n## 3. 本地方法栈 \n\nNative Method Stacks\n\n* 发挥的作用和虚拟机栈发挥的作用相似，区别只是本地方法栈执行本地方法，虚拟机栈执行Java方法\n\n* 本地方法：Native Method ，不是Java编写的代码，通常是操作系统自带的方法代码。\n\n* 本地方法栈为本地方法的运行提供内存空间\n* 在规范中对本地方法栈的实现方式（语言、数据结构）没有强制规定，具体的虚拟机可以自由的实现它，有的虚拟机（Sun HotSpot）甚至将本地方法栈和虚拟机栈合二为一\n\n## 4. 堆\n\n\n\n### 4.1定义\n\nHeap 堆\n\n* 通过new关键字，创建对象都会使用堆内存\n* 唯一目的就是存放对象实例，这一点在Java虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配，但随着优化技术的产生，将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了\n* 可以细分为新生代和老年代，再细一点的有Eden空间、From Survivor空间、To Survivor空间等\n* 根据规范规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，实现时可以实现成固定大小或可扩展的，目前主流虚拟机都是可扩展的\n\n特点\n\n* 它是线程共享的，堆中对象都需要考虑线程安全的问题\n* 有垃圾回收机制\n* 对多数应用而言，堆是Java虚拟机所管理的内存中最大的一块\n* 在虚拟机启动时创建\n\n### 4.2 堆内存溢出\n\n-Xmx 堆内存分配大小命令\n\nOutOfMemoryError : Java heap space\n\n垃圾回收：没人用的对象，就作为垃圾被回收\n\n堆内存溢出：大量的对象被不断创建，同时一直被使用，可能导致堆内存溢出\n\n### 4.3 堆内存诊断\n\n在idea控制台窗口即可运行\n\n1. jps工具\n   * 查看当前系统中有哪些Java进程\n2. jmap工具\n   * 查看堆内存占用情况 ，不连续，只能查看某一时刻的情况\n   * jmap -heap 进程id\n3. jconsole\n   * 图形界面，多功能检测工具，可连续监测\n\n案例：\n\n* 垃圾回收后，内存占用率仍然很高\n* 使用jvisualvm工具，通过堆dump功能查看对象在某一时刻的具体情况，从而做出诊断\n\n## 5. 方法区\n\n### 5.1 定义\n\nMethod Area\n\n方法区是所有Java虚拟机线程共享的区域，它存储了与类结构相关的信息，如成员变量，方法数据，成员方法和构造器的代码部分，运行时常量池。\n\n方法区在虚拟机启动时就被创建，逻辑上它是堆的组成部分，但具体实现不同的jvm有所不同\n\n### 5.2 组成\n\n待补充\n\n### 5.3 方法区内存溢出\n\n-XX:MaxMetaspaceSize 设置元空间大小\n\nOutOfMemoryError:Metaspace\n\n* 1.8以前会导致永久代内存溢出\n* 1.8以后会导致元空间内存溢出\n\n### 5.4 运行时常量池\n\n* 常量池，就是一张表，虚拟机指令根据这张常量表找到要执行的类名、方法名、参数类型、字面量等信息\n* 运行时常量池，常量池是 *.class 文件中的，当该类被加载，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址\n\n### 5.5 StringTable特性\n\n* 常量池中的字符串仅是符号，第一次用到时才变为对象\n* 利用串池的机制，来避免重复创建字符串对象\n* 字符串变量拼接的原理是StringBuilder（jdk1.8）\n* 字符串常量拼接的原理是编译期优化\n* 可以使用intern方法，主动将串池中还没有的字符串对象放入串池\n  * 1.8中，将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则放入串池，会把串池中的对象返回\n  * 1.6中，将这个字符串对象尝试放入串池，如果有则并不会放入，如果没有则会把此对象复制一份，再放入串池，会把串池中的对象返回\n\n### 5.6 StringTable位置\n\n* 1.8，StringTable在堆（Heap）中\n* 1.6，StringTable在永久代（PermGen）中\n\n### 5.7 StringTable垃圾回收\n\n### 5.8 StringTable性能调优\n\n* StringTable本质上是哈希表，因此调优就是调整桶的个数，适当的把桶的个数调大，减少哈希碰撞   -XX:StringTableSize=桶个数\n* 考虑将字符串对象是否入池\n* 既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当量池无法再申请到内存时会抛出OutOfMemoryError异常。\n\n## 6. 直接内存\n\n### 6.1 定义\n\nDirect Memory\n\n* 常见于NIO（一种基于通道（Channel）与缓\n  冲区（Buffer）的I/O方式，它可以使用Native函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作）操作，用于数据缓存区\n* 分配回收成本较高，但读写性能高，因为避免了在Java堆和Native堆中来回复制数据\n* 不受JVM内存回收管理\n\n### 6.2 分配和回收原理\n\n* 使用了Unsafe对象完成直接内存的分配回收，并且回收需要主动调用的freeMemory方法\n* ByteBuffer的实现类内部，使用了Cleaner（虚引用）来检测ByteBuffer对象，一旦ByteBuffer对象被垃圾回收，那么就会有ReferenceHandler线程通过Cleaner的clean方法调用freeMemory来释放直接内存\n","tags":["Java","JVM"],"categories":["技术学习"]},{"title":"JVM垃圾回收","url":"//post/JVM垃圾回收.html","content":"\n# JVM垃圾回收\n\n## 1. 如何判断对象可以回收\n\n### 1.1 简要介绍：\n\n1. 引用计数法，如果某个对象被引用了，则他的计数加1，不再被引用了，则减1，计数为0则回收。弊端：循环引用，比如a和b相互引用，即使他们两个永远都不再被使用了，但是由于存在引用计数，所以永远都不会被回收。早期python虚拟机采用这种算法。\n2. 可达性分析算法：首先确定根对象（肯定不能被垃圾回收的对象），进行垃圾回收前对所有对象进行一次扫描，如果被根对象直接或间接应用的对象就不能被回收，如果没有被引用，那么就可以被回收。JVM虚拟机采用这种算法进行\n\n### 1.2 可达性分析算法：\n\n\n\n* Java虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象\n\n* 扫描堆中的对象，看是否能够沿这GC Root对象为起点的引用链找到该对象，找不到，表示可以回收\n\n  #### 哪些对象可以作为GC Root对象\n\n SystemClass：由自举/系统类加载器加载的类。例如，rt.jar中所有诸如[java.util](https://www.baidu.com/s?wd=java.util&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao).*的类。\n JNILocal：原生代码中的本地变量，例如用户定义的JNI（Java本地接口，一般用来使Java代码和其他语言代码进行交互）代码或JVM内部代码。\n JNIGlobal：原生代码中的全局变量，例如用户定义的JNI代码或JVM内部代码。\n ThreadBlock：当前活跃的线程块中引用的对象。\n Thread：启动且未停止的线程。\n BusyMonitor：其wait()或notify()方法被调用，或被同步synchronized的对象。例如，通过调用synchronized(Object)或者进入其某个synchronized方法。静态方法对应类，非静态方法对应对象。\n JavaLocal：本地变量。例如，仍在线程的栈中的方法输入参数或本地创建的对象。\n NativeStack：（例如用户定义的JNI代码或JVM内部代码这样的）原生代码的入或出参数。通常发生在许多方法有原生部分，方法参数处理的对象成为GC根对象。例如，参数用于文件、网络I/O或反射。\n Finalizer：在队列中等待其finalizer运行的对象。\n Unfinalized：拥有finalize方法，但是还没有被终结且不在finalizer队列的对象。\n Unreachable：从其他根对象不可达的对象，但是被内存分析器标记为根对象。\n Unknown：没有根类型的对象。一些转储(dump)，例如IBM可移植对转储文件，没有根信息。对于这些转储，内存分析器解析程序将没有被其他根[对象引用](https://www.baidu.com/s?wd=对象引用&tn=SE_PcZhidaonwhc_ngpagmjz&rsv_dl=gh_pc_zhidao)的对象标记为此类根对象。\n\n### 1.3 四种引用\n\n\n\n![](https://img-blog.csdnimg.cn/12f2c23e724f4dd0b0babbfaa8df9529.PNG)\n\n此图中，实线表示强引用，虚线表示其余引用 \n\n1. 强引用\n\n   **可以被GC Root对象直接或间接的找到，这种关系是强引用**，一般情况下，我们书写的代码基本上形成的引用关系都是强引用，**只有当所有强引用都断开时，对象才会被垃圾回收**，除此之外是绝不可能将其回收的。\n\n   ```java\n   Object o = new Object();   //  强引用\n   o = null; //断开强引用，被回收\n   ```\n\n2. 软引用\n\n   在Java中，软引用本质上是一种特殊设计的类，因此软引用实际上是被手动创建出来的，使用SoftReference类创建出来\n\n   ```java\n   String str = new String(\"abc\");                                     // 强引用\n   SoftReference<String> softRef = new SoftReference<String>(str);     // str被软引用\n   ```\n\n    **如果一个对象只具有软引用（通过SoftReference建立），则内存空间足够，垃圾回收器就不会回收它；如果内存空间不足了，就会回收这些软引用对象的内存。**只要垃圾回收器没有回收它，该对象就可以被程序使用。软引用可用来实现内存敏感的高速缓存。\n\n   最具代表性的应用，如浏览器的后退按钮，点击后退要返回到上一个页面，如果重新加载，可能耗时较长，如果将其存储到内存中，则会造成浪费，这时可以使用软引用进行缓存，如果缓存资源充足，那么就将页面保存到缓存中，如果紧张，由于软引用的特性，页面缓存会被垃圾回收器回收。\n\n   可以配合**引用队列**使用，如果软引用它引用的对象被回收时，软引用本身（SoftReference实例）会被放到引用队列中，可以对其方便的进行进一步处理，比如释放SoftReference实例占用的内存。\n\n3. 弱引用\n\n   和软引用相似，弱引用对象也要手动创建出来，使用WeakReference建立\n\n   ```java\n   String str = new String(\"abc\");                                     //强引用\n   WeakReference<String> abcWeakRef = new WeakReference<String>(str);  //str被弱引用\n   ```\n\n   和软引用不同的是，**无论空间是否充足，只要垃圾回收器运行了，那么检测到弱引用，就会即刻将其回收**。但是垃圾回收器的线程优先级很低，不太经常运行，所以不会发生马上就会被清理掉的情况。如果这个对象是偶尔的使用，并且希望在使用时随时就能获取到，但又不想影响此对象的垃圾收集，那么你应该用 WeakReference 来记住此对象。  \n\n   可以配合**引用队列**使用，如果软引用它引用的对象被回收时，软引用本身（WeakReference实例）会被放到引用队列中，可以对其方便的进行进一步处理，比如释放WeakReference实例占用的内存。\n\n4. 虚引用\n\n    “虚引用”顾名思义，就是形同虚设，与其他几种引用都不同，**虚引用并不会决定对象的生命周期**。**如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收器回收。**\n\n   ```java\n   String str = new String(\"abc\");                                     //强引用\n   PhantomReference<String> ref = new PhantomReference<String>(str);  //str被虚引用\n   ```\n\n    虚引用主要用来跟踪对象被垃圾回收器回收的活动，同时，和软引用以及弱引用不同的是，**虚引用必须要和引用队列一起使用**，下面用一个例子来说明其作用和特征。\n\n   用Java中使用ByteBuffer分配直接内存的例子来说明一下，一个名叫Cleaner的虚引用关联了ByteBuffer实例对象，而我们借助ByteBuffer实例对象分配一些直接内存，当对ByteBuffer实例对象的强引用被断开后，ByteBuffer被回收了，但是其获取的直接内存不能被JVM垃圾回收器释放（因为它是底层的内存），这时候就要通过Cleaner这个虚引用，它进入引用队列，进行后续处理，通过这个虚引用获取到那块直接内存，然后将其释放。\n\n5. 终结器引用（额外）\n\n## 2. 垃圾回收算法\n\n## 3. 分代垃圾回收\n\n## 4. 垃圾回收器\n\n## 5. 垃圾回收调优\n\n","tags":["Java","JVM","源码分析"],"categories":["技术学习"]},{"title":"剑指 Offer 03. 数组中重复的数字的4种解法（Java语言）","url":"//post/剑指 Offer 03. 数组中重复的数字的4种解法（Java语言）.html","content":"\n## 题目详情\n\n找出数组中重复的数字。\n\n在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。\n\n示例 1：\n\n输入：\n[2, 3, 1, 0, 2, 5, 3]\n输出：2 或 3 \n\n## 解法一：暴力法，双层循环\n直接进行两层循环，对每个数字都逐一比较，空间复杂度O(1)，时间复杂度O(n^2)，总的来说是下下策，执行用时吓死人\n![在这里插入图片描述](https://img-blog.csdnimg.cn/3075c099b4af457dbd8c8ffe43a3945f.PNG#pic_center)\nJava代码\n```java\npublic int findRepeatNumber_1(int[] nums) {\n    for (int i = 0; i < nums.length; i++)\n      for (int j = i + 1; j < nums.length; j++)\n        if (nums[i] == nums[j])\n          return nums[i];\n    return -1;\n  }\n```\n## 解法二 排序后相邻的两两比较\n很容易想到的方法，排序后两两比较，空间复杂度O(1)，时间复杂度O(nlogn)，只能说是中下策，但执行用时已经有了相当的改善\n![在这里插入图片描述](https://img-blog.csdnimg.cn/9f01f52a148f4f3399936eedf4904588.PNG#pic_center)\nJava代码\n```java\npublic int findRepeatNumber_2(int[] nums) {\n    Arrays.sort(nums);\n    for (int i = 0; i < nums.length - 1; i++) {\n      if (nums[i] == nums[i + 1])\n        return nums[i];\n    }\n    return -1;\n  }\n```\n## 解法三 利用数组实现一个map映射\n首先，判断重复，常见的办法就是利用HashMap或是HashSet来判断，但我们观察数组发现，给定的值都是0~n-1，那么我们没必要使用集合类来加重负担，直接用数组就可以完成映射，给定的数组元素为键，出现次数为值。\n空间复杂度为O(n)，时间复杂度为O(n)，在大多数面试中已经算是可以让人接受的答案了。\n![在这里插入图片描述](https://img-blog.csdnimg.cn/44d453122fbd47539088318a84a3b140.PNG#pic_center)\n```java\npublic int findRepeatNumber_3(int[] nums) {\n    int[] map = new int[nums.length];\n    for (int i = 0; i < nums.length; i++) {\n      if (map[nums[i]] == 0)\n        map[nums[i]]++;\n      else\n        return nums[i];\n    }\n    return -1;\n  }\n```\n## 解法四 利用重排后的元素碰撞\n解法三已经达到了空间时间复杂度都是O(n)的情况，实际上还能继续优化，达到O(1)的空间复杂度。\n我们知道，数组中的元素是0~n-1，那么可以想到，如果没有重复的元素，那么排序后，每个元素都应该和它的下标相同，那么如果有重复的元素，那么两个元素就会撞到一起。\n基于这种思路，我们设计如下算法：对每个元素都进行处理，把它交换到它应该在的位置，如果交换前发现那个位置上的元素和它相等，也就是撞车了，那么很明显这个元素就是重复的数字。\n每个数字只要进行交换就能找到自己的位置，时间复杂度是O(n)，且没有用到额外的空间，因此空间复杂度只有O(1)\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/5be8fe2d4adf4ba1afedb4e5c97c069e.PNG#pic_center)\n```java\npublic int findRepeatNumber_4(int[] nums) {\n    for (int i = 0; i < nums.length; i++) {\n      while (nums[i] != i) {\n        //两个数撞了\n        if (nums[i] == nums[nums[i]]) {\n          return nums[i];\n        }\n        //把一个数交换到它应该在的位置\n        int temp = nums[nums[i]];\n        nums[nums[i]] = nums[i];\n        nums[i] = temp;\n      }\n    }\n    return -1;\n  }\n```\n","tags":["数据结构与算法","剑指Offer"],"categories":["技术学习"]},{"title":"Springboot的自动装配原理浅析","url":"//post/Springboot的自动装配原理浅析.html","content":"\n最近在学习Springboot，不少文章和视频在完成了第一个快速入门的项目之后就直接进入了Springboot运行的原理部分，因此决定写一篇文章加深理解。\n\n原理的理解主要使用了查看源码和画流程图的方式。\n\n### pom.xml\n对于一个maven项目，我们一般首要分析其pom文件，查看相关依赖。\n\n```xml\n<dependencies>\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-web</artifactId>\n        </dependency>\n\n        <dependency>\n            <groupId>org.springframework.boot</groupId>\n            <artifactId>spring-boot-starter-test</artifactId>\n            <scope>test</scope>\n            <exclusions>\n                <exclusion>\n                    <groupId>org.junit.vintage</groupId>\n                    <artifactId>junit-vintage-engine</artifactId>\n                </exclusion>\n            </exclusions>\n        </dependency>\n    </dependencies>\n\n    <build>\n        <plugins>\n            <plugin>\n                <groupId>org.springframework.boot</groupId>\n                <artifactId>spring-boot-maven-plugin</artifactId>\n            </plugin>\n        </plugins>\n    </build>\n```\n可以看到依赖方面都是很简单的内容，加入了测试启动器和web启动器以及springboot的build插件，但我们发现了一个不一般的地方，他们都没有版本号！这是为什么呢？\n   我们往上查看，可以发现这样的父依赖。\n\n```xml\n<parent>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-parent</artifactId>\n        <version>2.3.4.RELEASE</version>\n        <relativePath/> <!-- lookup parent from repository -->\n    </parent>\n```\n   我们点进去查看，会发现。。。还有一层父依赖！\n   ```xml\n   <parent>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-dependencies</artifactId>\n    <version>2.3.4.RELEASE</version>\n  </parent>\n   ```\n   继续点进去查看。\n```xml\n<properties>\n    <activemq.version>5.15.13</activemq.version>\n    <antlr2.version>2.7.7</antlr2.version>\n    <appengine-sdk.version>1.9.82</appengine-sdk.version>\n    <artemis.version>2.12.0</artemis.version>\n    <aspectj.version>1.9.6</aspectj.version>\n    <assertj.version>3.16.1</assertj.version>\n    <atomikos.version>4.0.6</atomikos.version>\n    <awaitility.version>4.0.3</awaitility.version>\n    <bitronix.version>2.1.4</bitronix.version>\n    <build-helper-maven-plugin.version>3.1.0</build-helper-maven-plugin.version>\n    <byte-buddy.version>1.10.14</byte-buddy.version>\n    <caffeine.version>2.8.5</caffeine.version>\n    <cassandra-driver.version>4.6.1</cassandra-driver.version>\n    ...........\n```\n```\n这样的信息就是这些依赖尽头的主体了，这个文件有大量的配置信息，标注了每个可能用到的依赖的版本号，因此我们不用指定依赖的版本，springboot会根据你使用的版本自动给你安排合适的版本，再也不用担心依赖版本的冲突导致的崩溃啦！\n\npom.xml文件我们就说到这里，接下来才是重头戏了！\n\n思维导图：\n\t![在这里插入图片描述](https://img-blog.csdnimg.cn/20200929160256862.png#pic_center)\n\n### 启动类的@SpringBootApplication注解\n启动类包括两个重要的部分，一个是@SpringBootApplication注解，另一个是其中的run方法，我们先从这个注解开始说起。\n\n首先，这个注解的作用，猜也猜得到，是标注这个应用是一个springboot应用，这样springboot就可以帮我们对其进行自动配置，我们想要了解，spring boot是如何通过注解来自动装配的，装配了什么。\n\n老办法，查看源码，我点！\n```java\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Inherited\n@SpringBootConfiguration\n@EnableAutoConfiguration\n@ComponentScan\n```\n以上是@SpringBootApplication注解之下的几个注解，出去那些基础的之外，我们可以看见三个特别显眼的，@SpringBootConfiguration，@ComponentScan，@EnableAutoConfiguration，我们逐个查看他们的源码。\n\n#### @SpringBootConfiguration\n\n他的源码：\n\n```java\n@Target({ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Configuration\n```\n乏善可陈。。。根据其下的@Configuration可以猜到，它是起到一个标注作用的注解，标志当前应用为一个springboot应用。\n\n我们回到上一层查看其他注解的源码。\n\n#### @ComponentScan\n\n这个更没啥好说的了，源码都没必要看了，他的作用是扫描指定包下的组件，将它们加载到Spring的IOC容器之中，很重要，但不是我们探究的重点。\n\n我们查看最后一个注解的源码。\n\n#### @EnableAutoConfiguration\n看得出来，他的作用是启用自动配置，我们重点关注如何启用，怎么启用，启用了什么。\n他的源码：\n\n```java\n@AutoConfigurationPackage\n@Import({AutoConfigurationImportSelector.class})\n```\n看起来重要的注解就这两个，第一个看翻译是自动配置包，我们点进去查看他的源码：\n\n```java\n@Import({Registrar.class})\n```\n噢，这是一个注册器，根据相关源码猜测是将bean注册导入到容器之中（若有错误希望指正）。\n\n我们回头，看看import导入的东西。\n\n自动配置导入选择器，我们猜测它是导入了需要的配置文件，查看源码：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200929162249237.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhdzk2eA==,size_16,color_FFFFFF,t_70#pic_center)\n我这里截图还没有截全。。。我们发现其中有相当多的方法，我们的目的是查看如何加载组件的，因此寻找configuration相关的方法。\n\n找到了！getCandidateConfigurations，获取候选配置，这个方法中又使用了SpringFactoriesLoader，我们继续深入。\n```public static final String FACTORIES_RESOURCE_LOCATION = \"META-INF/spring.factories\";```\n看到了看起来是文件的东西！我们使用全局搜索，发现它在springboot的jar包内，我们再点开来看看\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200929162722643.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhdzk2eA==,size_16,color_FFFFFF,t_70#pic_center)我们根据源头打开spring.factories ， 看到了很多自动配置的文件；这就是自动配置根源所在！可以随便点开看看，都可以看到这些一个个的都是JavaConfig配置类，而且都注入了一些Bean。\n\n至此，我们大概明白了Spring boot的自动装配原理了：\n\n自动配置真正实现是从classpath中搜寻所有的META-INF/spring.factories配置文件 ，并将其中对应的 org.springframework.boot.autoconfigure. 包下的配置项，通过反射实例化为对应标注了 @Configuration的JavaConfig形式的IOC容器配置类 ， 然后将这些都汇总成为一个实例并加载到IOC容器中。\n\n所以其实刚刚那一大串套娃注解其实都是为了拿到spring.factories。。。我不太懂设计模式，不太懂这样做的意义是什么样的哈哈哈。\n\n## 结论\n\n1. SpringBoot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值\n\n2. 将这些值作为自动配置类导入容器 ， 自动配置类就生效 ， 帮我们进行自动配置工作；\n\n3. 整个J2EE的整体解决方案和自动配置都在springboot-autoconfigure的jar包中；\n\n4. 它会给容器中导入非常多的自动配置类 （xxxAutoConfiguration）, 就是给容器中导入这个场景需要的所有组件 ， 并配置好这些组件 ；\n\n5. 有了自动配置类 ， 免去了我们手动编写配置注入功能组件等的工作；\n\n思维导图：\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200929164052679.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhdzk2eA==,size_16,color_FFFFFF,t_70#pic_center)\n\n\n### run方法\n分析该方法主要分两部分，一部分是SpringApplication的实例化，二是run方法的执行；\nSpringApplication\n\n这个类主要做了以下四件事情：\n\n1、推断应用的类型是普通的项目还是Web项目\n\n2、查找并加载所有可用初始化器 ， 设置到initializers属性中\n\n3、找出所有的应用程序监听器，设置到listeners属性中\n\n4、推断并设置main方法的定义类，找到运行的主类\n\n源码分析无力了。。。给大家一张图吧，说的很清楚了，大家可以跟着这张图自己读读源码。\n\n![在这里插入图片描述](https://img-blog.csdnimg.cn/20200929163826667.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3Nhdzk2eA==,size_16,color_FFFFFF,t_70#pic_center)\n\n","tags":["Java","源码分析","SpringBoot"],"categories":["技术学习"]},{"title":"Java new ArrayList(int initialCapacity)初始化容量问题","url":"//post/Java new ArrayList(int initialCapacity)初始化容量问题.html","content":"\n\n\n今天看了ArrayList源码，发现了一个不大不小的问题：\n\n```java\npublic ArrayList(int initialCapacity) {\n        if (initialCapacity > 0) {\n            this.elementData = new Object[initialCapacity];\n        } else if (initialCapacity == 0) {\n            this.elementData = EMPTY_ELEMENTDATA;\n        } else {\n            throw new IllegalArgumentException(\"Illegal Capacity: \"+\n                                               initialCapacity);\n        }\n    }\n```\n\n这个构造函数咋一看问题不大，给elementData底层数组分配空间嘛，初始化数组的大小了\n但是实际使用时：\n```java\nArrayList<Integer> a = new ArrayList(9);\na.set(1,5);\n```\n抛出了IndexOutOfBoundsException\n\n结合源码：\n```java\npublic E set(int index, E element) {\n        Objects.checkIndex(index, size);\n        E oldValue = elementData(index);\n        elementData[index] = element;\n        return oldValue;\n    }\n```\n其中第一行首先检测了下标，参数是index和size，而size是元素个数，也就是说，尽管设置了数组的容量，但针对ArrayList中元素的操作，是根据元素的位置，而不是根据容量来操作。也就是说，至少得有个元素才能set它，没有元素就是set个寂寞。\n\n因此```set(1,5)```在第一行直接抛出异常了\n\n综上所述ArrayList(int initialCapacity) 只是**让ArrayList有了容纳 initialCapacity个元素的潜力，并不能对其中的“位置”操作**。\n\nPS：这个问题在Java核心技术卷1中就有提到，但我当时直接忘了，果然看了源码才理解的透彻。\n","tags":["Java","源码分析"],"categories":["技术学习"]}]